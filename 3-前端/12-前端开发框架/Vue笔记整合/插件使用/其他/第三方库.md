# Vue中引用qs第三方库

1.进入项目根目录，打开cmd，输入`npm install qs`安装qs
2.打开你想应用组件处，`import qs from 'qs'`，导入[第三方库](https://so.csdn.net/so/search?q=第三方库&spm=1001.2101.3001.7020)，如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20201025225549251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2Njk0MDU2,size_16,color_FFFFFF,t_70#pic_center)



### 常用方法：

1.qs.parse():将查询字符串转换成json字符串，如下：
![](%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.assets/image-20240313212419912.png)

2.qs.stringify():将json字符串转换成查询字符串，如下：
![image-20240313212424961](%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.assets/image-20240313212424961.png)

### **qs与JSON的区别**

![img](%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.assets/a0b9e782957d49a4904e0594bf865db9.png)



# 前端储存

**pina  状态管理  相当于静态变量   通过 路由跳转来进行刷新页面 状态能保存。但是直接通过刷新，相当于重新部署，要保存状态只能通过浏览器（locatestorage等）**

## **sessionStorage**

> 概念： sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。
> 简单来说，就是用户访问成功之后，在浏览器窗上储存的一个数据，然后当回话结束，窗口被关闭之后，数据也随之销毁，可见**sessionStorage**只适合存储即用即销毁的临时数据。
> 特别注意一点：存储在sessionStorage或localStorage中的数据**特定于页面的协议**，http与https会存储不一样的sessionStorage，且返回的是一个storage对象。

![](%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.assets/image-20231205100305119.png)

**sessionStorage的简单使用**

**api使用方法**

```text
//存储
sessionStorage.setItem('key', 'value');

//获取
sessionStorage.getItem('key');

//删除指定数据
sessionStorage.removeItem('key');

//删除所有保存的数据
sessionStorage.clear();
```

**object使用方法**

```text
//存储
var stroage = window.sessionStorage
stroage['name'] = "张三"

//获取
console.log(sessionStorage.name);

//删除指定数据
delete sessionStorage.name
//或者
delete sessionStorage['name']

//删除所有保存的数据
for(var key in sessionStorage){
 delete sessionStorage[key];
}
console.log(sessionStorage);
```

**实例**

```html
<input type="text" id="getInput">

var getInputId = document.getElementById("getInput")

//判断是否存在sessionStorage
if(sessionStorage.getItem('inputVal')){
    getInputId.value = sessionStorage.getItem('inputVal')
}

getInputId.addEventListener('change',function(){
    if(getInput.value){
        //添加sessionStorage
        sessionStorage.setItem('inputVal',getInput.value)
    }
})
```

> 以上实例展示了sessionStroage的存储过程，以及获取方式，在关闭窗口之后，sessionStroge也被清楚，但是只刷新当前页面的话，数据依旧存在，由此可见sessionStroage的特性

 登录实例

```vue
 confirm(){
                this.confirm_disabled=true;
                this.$refs.loginForm.validate((valid) => {
                    if (valid) { //valid成功为true，失败为false
                        //去后台验证用户名密码
                        this.$axios.post(this.$httpUrl+'/user/login',this.loginForm).then(res=>res.data).then(res=>{
                            console.log(res)
                            if(res.code==200){
                                // 存储
                                sessionStorage.setItem("CurUser",JSON.stringify(res.data.user))

                                console.log(res.data.menu)
                                // 状态管理模式 保存到store中
                                this.$store.commit("setMenu",res.data.menu)
                                // 跳转到主页
                                this.$router.replace('/Index');
                            }else{
                                this.confirm_disabled=false;
                                alert('校验失败，用户名或密码错误！');
                                return false;
                            }
                        });
                    } else {
                        this.confirm_disabled=false;
                        console.log('校验失败');
                        return false;
                    }
                });

            }
```

## **localStorage**

> 概念：了解sessionStroage之后，localStroage就正好解决了数据不能长久存储的问题，而且除非主动删除，否则数据会一直存在
> 需要注意：localStroage不能存储过多数据，否则会占据大量资源，致使页面卡顿，其次localStorage存储的数据不能被爬虫抓取到，不利于seo，localStorage只支持string类型的存储。
> **localStroage**的放回依然是一个stroage对象

![](%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.assets/image-20231205100327157.png)

**localStorage的简单使用**

> localStorage的使用与sessionStroage相同，因此只举例api写法

```js
//存储
localStorage.setItem('key', 'value');

//获取
localStorage.getItem('key');

//删除指定数据
localStorage.removeItem('token')
//删除所有保存的数据
localStorage.clear();
```

**实例**

> 需求：制作一个有历史搜索的输入框，类似于淘宝的搜索
> 分析：获取输入框数据，并进行存储，历史记录有个数限制，达到限制后，删除末尾，插入首位，对于重复的搜索去重

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .history_content{
            width: 300px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div>
        <input type="text" id="getInput" placeholder="请输入搜索内容"> <span id="handleBtn">搜索</span>
    </div>
    
    <div class="history_content" id="history_content">

    </div>
    <script>
        var getInputId = document.getElementById('getInput')
        var history_content_id = document.getElementById('history_content')
        var handleBtn_id = document.getElementById('handleBtn')
        
        handleBtn_id.addEventListener('click',function(){
            if(getInputId.value){
                var searchList;
                if(localStorage.length<1) {
                    searchList = [];
                    searchList.push(getInputId.value)
                }else if(JSON.parse(localStorage.searchList).length > 6){
                    searchList = JSON.parse(localStorage.searchList)
                    if(searchList.indexOf(getInputId.value)<0){
                        searchList.unshift(getInputId.value)
                        searchList.pop(-1)
                    }
                }else{
                    searchList = JSON.parse(localStorage.searchList)
                    if(searchList.indexOf(getInputId.value)<0){
                        searchList.unshift(getInputId.value)
                    }
                }
                localStorage['searchList'] = JSON.stringify(searchList)
                showContent()
            }else{
                alert("请输入搜索内容！")
            }
        })

        function showContent(){
            var str ="";
            JSON.parse(localStorage.searchList).forEach(item => {
                str += `<p>${item}</p>`
            });
            console.log(str);
            history_content_id.innerHTML = str
        }
        showContent()

    </script>
</body>
</html>
```

### 例子

### 登录表单是如何做到每次打开浏览器, 自动填写的

另一种方式是使用浏览器的本地存储功能，比如localStorage或sessionStorage。当用户输入账号密码时，这些值会被存储在本地存储中，然后在页面加载时检查本地存储中是否存在这些值，并将它们填充到相应的输入框中。

```js
// 当用户输入账号密码时保存到本地存储
$('#check1').on('change', function() {
    if ($(this).is(':checked')) {
        localStorage.setItem('username', $('#login_username').val());
        localStorage.setItem('password', $('#login_password').val());
    } else {
        /localStorage.removeItem('username');
        localStorage.removeItem('password');
    }
});

// 页面加载时检查本地存储中是否有账号密码，并填充到输入框中
$(document).ready(function() {
    // 页面加载时检查本地存储中是否有用户名和密码，并填充到输入框中
      if (localStorage.getItem('username')) {
        $('#login_username').val(localStorage.getItem('username'));
      }
      if (localStorage.getItem('password')) {
        $('#login_password').val(localStorage.getItem('password'));
      }
});
```

#





## js-cookie的使用方法

[js-cookie的使用方法 - 掘金 (juejin.cn)](https://juejin.cn/post/7222602874631159865)

pina  状态管理  相当于静态变量   

+ 通过 路由跳转来进行刷新页面 状态能保存。
+ 实现路由跳转到新页面，返回旧页面，保留之前的数据记录

浏览器刷新  

+ 但是直接通过刷新，相当于重新部署，要保存状态只能通过浏览器（locatestorage等

### 1、下载js-cookie

```
npm install js-cookie
```

### 2、引入js-cookie

```javascript
import Cookies from "js-cookie";
```

### 3、使用

```csharp
// 写入cookie
Cookies.set('name', 'value')
// 读取
Cookies.get('name') // => 'value'
Cookies.get('nothing') // => undefined
// 读取所有可见的cookie
Cookies.get()
// 删除某项cookie值
Cookies.remove('name')
```

### 4、cookie在全局使用（方法二）在main.js中引入

```javascript
javascript
import Cookies from 'js-cookie'
```

### 5、cookie设置过期时间

```csharp
//1、存cookie  set方法支持的属性有 ：  expires->过期时间    path->设置为指定页面创建cookie   domain-》设置对指定域名及指定域名的子域名可见  secure->值有false和true ,表示设置是否只支持https,默认是false
Cookies.set('key', 'value');  //创建简单的cookie
Cookies.set('key', 'value', { expires: 27 });//创建有效期为27天的cookie
Cookies.set('key', 'value', { expires: 17, path: ''  }); //可以通过配置path,为当前页创建有效期7天的cookie

//2、取cookie
Cookies.get('key'); // 获取指定key 对应的value
Cookies.get(); //获取所有value

//3、删除cookie
Cookies.remove('key');//删除普通的cookie
Cookies.remove('name', { path: '' }); // 删除存了指定页面path的cookie


注意：如果存的是对象，如： userInfo = {age:111,score:90};  Cookie.set('userInfo',userInfo)

取出来的userInfo需要进行JSON的解析,解析为对象：let res = JSON.parse( Cookie.get('userInfo') );

当然你也可以使用：Cookie.getJSON('userInfo');
Cookies.get('name'); // => '{"foo":"bar"}'
Cookies.get(); // => { name: '{"foo":"bar"}' }
//-------------------------------------------------------//
Cookies.getJSON('name'); // => { foo: 'bar' }
Cookies.getJSON(); // => { name: { foo: 'bar' } }
```

需求：在开发的业务中，业务需要在前端进行数据的缓存，到期就删除再进行获取新数据。 前端设置数据定时失效的可以有下面2种方法：

1. 当数据较大时，可以利用localstorage，存数据时候写入一个时间，获取的时候再与当前时间进行比较
2. 如果数据不超过cookie的限制大小，可以利用cookie比较方便，直接设置有效期即可。

### 利用localstorage实现：步骤

1.存储数据时加上时间戳 在项目开发中，我们可以写一个公用的方法来进行存储的时候加上时间戳

```javascript
//export抛出
export function setLocalStorageAndTime (key, value) {
 window.localStorage.setItem(key, JSON.stringify({ data: value, time: new Date().getTime() }))
}
```

项目中

存储

```php
// 有数据再进行存储
  setLocalStorageAndTime('XXX', {name: 'XXX'})
```

读取

```javascript
// 判断是否返回为null或者失效
getLocalStorageAndTime('XXX', 86400000)
获取数据时与当前时间进行比较

export function getLocalStorageAndTime (key, exp = 86400000) {
 // 获取数据
 let data = window.localStorage.getItem(key)
 if (!data) return null
 let dataObj = JSON.parse(data)
 // 与过期时间比较
 if (new Date().getTime() - dataObj.time > exp) {
  // 过期删除返回null
  removeLocalStorage(key)
  console.log('信息已过期')
  return null
 } else {
  return dataObj.data
 }
}
```

### 利用cookie实现

js-cookie 的示例中只有以天为单位的有效期：

```c
Cookies.set('name', 'value', { expires: 7 }); // 7 天后失效
```

官方文档只要设置天数，没有时分秒，这样我们想设置更小单位的时候无法下手，其实也可以设置时间戳来处理时间的，下面这种方式可以设置任意单位的有效期：

```javascript
let seconds = 10;
let expires = new Date(new Date() * 1 + seconds * 1000);
Cookies.set('username', 'tanggaowei', { expires: expires }); // 10 秒后失效
```

### 贴上利用js-cookie的二次封装, 记得 npm i js-cookie

```js
vbnet复制代码import Cookies from 'js-cookie'

/*
* 设置cookies
* */
export function getCookies (key) {
 return Cookies.get(key)
}
/*
* 设置Cookies
* */
export function setCookies (key, value, expiresTime) {
 let seconds = expiresTime
 let expires = new Date(new Date() * 1 + seconds * 1000)
 return Cookies.set(key, value, { expires: expires })
}
/*
* 移除Cookies
* */
export function removeCookies (key) {
 return Cookies.remove(key)
}
```

域domain与路径path 默认值： path: ‘/’

domain表示的是cookie所在的域，默认为请求的地址，如网址为www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。

path表示cookie所在的目录，asp.net默认为/，就是根目录。在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，现设一个cookie1的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/和/test/dd/的子页面不能访问cookie2。这是因为cookie能让其path路径下的页面访问。

cookie.set()更多参数 语法： cookies.set（名称，[值]，[options]） 更多options的参数配置：

maxAge：一个数字，表示自Date.now()到期起的毫秒数

expires：一个Date对象，指示cookie的过期日期（默认在会话结束时过期）。默认：天

path：一个字符串，指示cookie的路径（/默认情况下）。

domain：一个字符串，指示cookie的域（无默认值）。

secure：一个布尔值，指示cookie是否仅通过HTTPS发送（false默认情况下，对于HTTP，true默认情况下，对于HTTPS）。在下面阅读有关此选项的更多信息。 httpOnly：一个布尔值，指示cookie是否仅通过HTTP（S）发送，并且不提供给客户端JavaScript（true默认情况下）。

sameSite：布尔值或字符串，指示cookie是“相同站点” cookie（false默认情况下）。可以将其设置为’strict’，‘lax’或true（映射到’strict’）。

signed：一个布尔值，指示是否要对cookie进行签名（false默认情况下）。如果为真，.sig则还将发送另一个具有后缀的同名Cookie，其27字节的url安全base64 SHA1值表示针对第一个Keygrip密钥的cookie-name = cookie-value的哈希值。此签名密钥用于检测下次接收cookie时的篡改。

overwrite：一个布尔值，指示是否覆盖以前设置的同名Cookie（false默认情况下）。如果是这样，则在设置此Cookie时，将从相同名称的同一个请求中设置的所有Cookie（无论路径或域如何）都从Set-Cookie标头中过滤掉。





# `path-to-regexp`库

>  path-to-regexp **该方法的作用是把字符串转为正则表达式。一般我们使用动态匹配路由的时候会用到这个。**

## 安装

下载：

```
npm install path-to-regexp --save
```

引入：

```
var pathToRegexp = require('path-to-regexp')
或者
import pathToRegexp from 'path-to-regexp'
```

## API介绍

**1.pathToRegexp() 作用：将我们输入的url输出为匹配规则；**

```ts
var re = pathToRegexp('/foo/:bar')
console.log(re)
```

打印结果：

```
/^\/foo\/((?:[^\/]+?))(?:\/(?=$))?$/i
```

要注意两点，一点是我们自己的 url 地址，一条是匹配规则。

**2.exec():匹配url和规则是否相等**

```ts
var pathToRegexp = require('path-to-regexp')

var re = pathToRegexp('/foo/:bar');     // 匹配规则
var match1 = re.exec('/test/route');    // url 路径
var match2 = re.exec('/foo/route');     // url 路径

console.log(match1);
console.log(match2);
```

打印结果：

```
null
[ '/foo/route', 'route', index: 0, input: '/foo/route' ]
```

**3.parse() 解析url字符串中的参数部分（：id)**

```ts
var pathToRegexp = require('path-to-regexp');
var url = '/user/:id';
console.log(pathToRegexp.parse(url));
```

解析结果：

```
[ '/user',
   { name: 'id',
     prefix: '/',
     delimiter: '/',
     optional: false,
     repeat: false,
     partial: false,
     pattern: '[^\\/]+?' } ]
```

说明，返回一个数组，从第二个数据可以得到url地址携带参数的属性名称（item.name)

**4.compile():快速填充url字符串的参数值**

```ts
var pathToRegexp = require('path-to-regexp')
var url = '/user/:id/:name'
var data = {id: 10001, name: 'bob'}
console.log(pathToRegexp.compile(url)(data))
```

打印结果：

```
/user/10001/bob
```

## 使用path-to-regexp 报错

#### 报错：

![image-20240424092031986](%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.assets/image-20240424092031986.png)

#### 解决办法

```
import pathToRegexp from 'path-to-regexp'  修改为：
import * as pathToRegexp from 'path-to-regexp'
或者
import { pathToRegexp } from 'path-to-regexp';
```

## 3、vue3+vite 中重新封装面包屑组件

这段代码是一个面包屑（Breadcrumb）组件，通常用于展示当前页面在网站或应用程序中的位置路径。

它会根据当前路由的匹配项生成对应的面包屑导航。面包屑导航可以让用户清晰地了解他们在网站或应用程序

#### vue2源码：

```javascript
<template>
  <el-breadcrumb class="app-breadcrumb" separator="/">
    <transition-group name="breadcrumb">
      <el-breadcrumb-item v-for="(item,index) in levelList" :key="item.path">
        <span v-if="item.redirect==='noRedirect'||index==levelList.length-1" class="no-redirect"><i :class="item.meta.icon"></i><span style="margin-left:5px;">{{ item.meta.title }}</span></span>
        <span v-else><i :class="item.meta.icon"></i><a @click.prevent="handleLink(item)" style="margin-left:5px;">{{ item.meta.title }}</a></span>
      </el-breadcrumb-item>
    </transition-group>
  </el-breadcrumb>
</template>
 
<script>
// import pathToRegexp from 'path-to-regexp'
 
export default {
  data() {
    return {
      levelList: null
    }
  },
  watch: {
    $route(route) {
      if (route.path.startsWith('/redirect/')) {
        return
      }
      this.getBreadcrumb()
    }
  },
  created() {
    this.getBreadcrumb()
  },
  methods: {
    getBreadcrumb() {
      let matched = this.$route.matched.filter(item => item.meta && item.meta.title)
      const first = matched[0]
 
      if (!this.isDashboard(first)) {
      }
 
      this.levelList = matched.filter(item => item.meta && item.meta.title && item.meta.breadcrumb !== false)
    },
    isDashboard(route) {
      const name = route && route.name
      if (!name) {
        return false
      }
      return name.trim().toLocaleLowerCase() === 'Dashboard'.toLocaleLowerCase()
    },
    pathCompile(path) {
      const { params } = this.$route
      //pathToRegexp 把字符串转为正则表达式
      //pathToRegexp.compile() 快速填充 url 字符串的参数值
      var toPath = pathToRegexp.compile(path)
      return toPath(params)
    },
    handleLink(item) {
      const { redirect, path } = item
      if (redirect) {
        this.$router.push(redirect)
        return
      }
      this.$router.push(this.pathCompile(path))
    }
  }
}
</script>
 
<style lang="scss" scoped>
.app-breadcrumb.el-breadcrumb {
  display: inline-block;
  font-size: 14px;
  line-height: 50px;
  margin-left: 8px;
 
  .no-redirect {
    color: #97a8be;
    cursor: text;
  }
}
</style>
```

#### vue3源码：

```javascript
<template>
  <el-breadcrumb class="app-breadcrumb" separator="/">
    <transition-group name="breadcrumb">
      <el-breadcrumb-item v-for="(item,index) in levelList" :key="item.path">
        <span v-if="item.redirect==='noRedirect'||index==levelList.length-1" class="no-redirect"><i :class="item.meta.icon"></i><span style="margin-left:5px;">{{ item.meta.title }}</span></span>
        <span v-else><i :class="item.meta.icon"></i><a @click.prevent="handleLink(item)" style="margin-left:5px;">{{ item.meta.title }}</a></span>
      </el-breadcrumb-item>
    </transition-group>
  </el-breadcrumb>
</template>
 
<script>
import * as pathToRegexp from 'path-to-regexp'
import {
  reactive,
  watch,
  toRefs,
  getCurrentInstance,
  onMounted
} from 'vue'
export default {
  setup(){
    /************************ hx-定义数据data(START) ************************/
    const data = reactive({
      levelList: null
    })
    /************************ hx-定义数据data(END) ************************/
 
    /************************ hx-生命周期(START) ************************/
    const { proxy } = getCurrentInstance()
 
    onMounted(() => {
      getBreadcrumb()
    })
    const router = useRouter()
    watch(() => router.currentRoute.value.path,(toPath) => {
      //要执行的方法
      if (toPath.startsWith('/redirect/')) {
        return
      }
      getBreadcrumb()
 
    },{immediate: true,deep: true})
    /************************ hx-生命周期(END) ************************/
 
    /************************ hx-methods(START) ************************/
    function getBreadcrumb() {
      let matched = router.matched.filter(item => item.meta && item.meta.title)
      const first = matched[0]
 
      if (!isDashboard(first)) {}
 
      data.levelList = matched.filter(item => item.meta && item.meta.title && item.meta.breadcrumb !== false)
    }
    function isDashboard(route) {
      const name = route && route.name
      if (!name) {
        return false
      }
      return name.trim().toLocaleLowerCase() === 'Dashboard'.toLocaleLowerCase()
    }
    function pathCompile(path) {
      const { params } = route
      debugger
      //pathToRegexp 把字符串转为正则表达式
      //pathToRegexp.compile() 快速填充 url 字符串的参数值
      var toPath = pathToRegexp.compile(path)
      return toPath(params)
    }
    function handleLink(item) {
      const { redirect, path } = item
      if (redirect) {
        router.push(redirect)
        return
      }
      router.push(pathCompile(path))
    }
 
    /************************ hx-methods(END) ************************/
 
 
    return {
      //数据
      ...toRefs(data),
      //methods
      handleLink
    }
  }
}
</script>
 
<style lang="scss" scoped>
.app-breadcrumb.el-breadcrumb {
  display: inline-block;
  font-size: 14px;
  line-height: 50px;
  margin-left: 8px;
 
  .no-redirect {
    color: #97a8be;
    cursor: text;
  }
}
</style>
```



# vue项目的进度条插件 -- nprogress

### 简介

在Vue项目中，nprogress是一个轻量级的Ajax进度条组件。
**官网**：https://www.npmjs.com/package/nprogress

### 一、安装

```bash
npm install --save nprogress
1
```

### 二、引入与使用

```javascript
import nprogress from 'nprogress' // 进度条
import 'nprogress/nprogress.css' //样式必须引入


// 使用
nprogress.start();  // 开启进度条
nprogress.done();  // 进度完成

nprogress.set(0.4);  // 在nprogress.start()之后调用，让进度条卡在40%的位置。
```

**修改进度条的样式：**

```css
/* 修改进度条样式 */
#nprogress .bar {
  background-color: red !important;
  height: 3px !important;
}
```

### 三、实际例子

封装的[Ajax请求](https://so.csdn.net/so/search?q=Ajax请求&spm=1001.2101.3001.7020)来举例。
可以看到，我在axios的[请求拦截器](https://so.csdn.net/so/search?q=请求拦截器&spm=1001.2101.3001.7020)里调用nprogress.start()，在响应拦截器里调用nprogress.done();
这样，就完成了Ajax的请求的进度条。
getBaseUrl.js是我封装的electron桌面软件读取外部配置文件的js文件，[electron框架的自定义外部配置文件的配置与读取](https://blog.csdn.net/weixin_45689946/article/details/128482084?spm=1001.2014.3001.5501)

```javascript
import Vue from 'vue'
import axios from 'axios'
import qs from 'qs'
import * as common from './common.js'
import router from '../router/index'
import nprogress from 'nprogress'
import 'nprogress/nprogress.css'
import { readConfig } from '@/utils/getBaseUrl.js'

axios.defaults.timeout = 150000
axios.defaults.headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8;multipart/form-data'

const applicationType = 'website' // 如果最后打包的是网站，就打开这个
    // let applicationType = "exe"  // 如果最后打包的是exe应用，就打开这个

axios.defaults.baseURL = 'http://127.0.0.1:8535/emrapi'

// 判断应用最后打包后，是网站，或者是exe应用。exe应用就不能访问网络，就需要在config.json里动态配置后端地址。
if (applicationType === 'exe') {
    (async function() {
        const res = await readConfig()
        axios.defaults.baseURL = res.baseUrl
        Vue.prototype.$baseURL = res.baseUrl
        window.$config = res
    })()
}
Vue.prototype.$baseURL = axios.defaults.baseURL

// // 请求拦截器
axios.interceptors.request.use(
    config => {
        // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了
        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断
        const emrKey = localStorage.getItem('emrKey')
        nprogress.start()
        if (config.method === 'get') {
            config.data = { unused: 0 } // 这个是关键点，加入这行就可以了  解决get  请求添加不上content_type
                // 设置get请求,不设置的话，url的一些特殊字符传输的时候会报错
            let url = config.url
                // get参数编码
            if (config.method === 'get' && config.params) {
                url += '?'
                const keys = Object.keys(config.params)
                for (const key of keys) {
                    url += `${key}=${encodeURI(config.params[key])}&`
                }
                url = url.substring(0, url.length - 1)
                config.params = {}
            }
            config.url = url
        }
        emrKey && (config.headers.emrKey = emrKey)
        return config
    },
    error => {
        return Promise.error(error)
    })

// 响应拦截器
axios.interceptors.response.use(
    response => {
        nprogress.done()
            // nprogress.set(0.8)
        if (['', '200', null, undefined].includes(response.data.code)) {
            return Promise.resolve(response)
        } else {
            if (response.data.code) {
                switch (response.data.code) {
                    // 401: 登录失效
                    // 未登录则跳转登录页面，并携带当前页面的路径
                    // 在登录成功后返回当前页面，这一步需要在登录页操作。
                    case 401:
                    case '401':
                        common.notify('error', '登录超时，请重新登录！')
                        setTimeout(() => {
                            router.replace({
                                path: '/',
                                query: { redirect: router.currentRoute.fullPath }
                            })
                        }, 500)
                        break
                        // 403 权限不足
                    case 403:
                    case '403':
                        common.notify('error', '操作失败，权限不足！！！')
                        break
                        // 404请求不存在
                    case 404:
                    case '404':
                        common.notify('error', '网络请求不存在')
                        break
                        // 其他错误，直接抛出错误提示
                    default:
                        common.notify('error', response.data.message || '未知错误！')
                }
            }
            return Promise.reject(error.response)
        }
    },
    // 服务器状态码不是200的情况
    error => {
        nprogress.done()
            // nprogress.set(0.8)
        return Promise.reject(error)
    }
)

/**
 * get方法，对应get请求
 * @param {String} url [请求的url地址]
 * @param {Object} params [请求时携带的参数]
 */
function get(url, params, headers) {
    headers = headers || {}
    return new Promise((resolve, reject) => {
        axios.get(url, {
            params: params,
            headers: headers
        }).then(res => {
            resolve(res.data)
        }).catch(err => {
            reject(err.data)
        })
    })
}
/**
 * post方法，对应post请求
 * @param {String} url [请求的url地址]
 * @param {Object} data [请求时携带的参数]
 */
function post(url, data, headers) {
    headers = headers || {}
    return new Promise((resolve, reject) => {
        axios.post(url, qs.stringify(data, { arrayFormat: 'repeat' }), {
                headers: headers
            }).then(res => {
                resolve(res.data)
            })
            .catch(err => {
                reject(err.data)
            })
    })
}

function jsonPost(url, data, headers) {
    headers = headers || { 'Content-Type': 'application/json;charset=utf-8' }
    return new Promise((resolve, reject) => {
        axios.post(url, data, {
                headers: headers
            }).then(res => {
                resolve(res.data)
            })
            .catch(err => {
                reject(err.data)
            })
    })
}

export default {get, post, jsonPost }

/*
使用，在全局中声明。
import http from "..."
Vue.prototype.$http= http;

在vue文件中使用：
this.$http.get(url, { username: "张三", age: "12" }).then(function(res) { ... }).catch(function(err) { ... })
*/
```

### 实际效果、

![image-20240424201213030](%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.assets/image-20240424201213030.png)
可以看到，在页面的顶部出现了红色的Ajax请求的进度条。





