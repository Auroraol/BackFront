JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。

**原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。**

TypeScript 包含的数据类型如下表：

| 数据类型 | 关键字 | 描述 |
| --- | --- | --- |
| 任意类型 | any | 声明为 any 的变量可以赋予任意类型的值。 |
| 数字类型 | number | 双精度 64 位浮点值。它可以用来表示整数和分数。```typescript
let binaryLiteral: number = 0b1010; // 二进制
let octalLiteral: number = 0o744;    // 八进制
let decLiteral: number = 6;    // 十进制
let hexLiteral: number = 0xf00d;    // 十六进制
```
 |
| 字符串类型 | string | 一个字符系列，使用单引号（`'`）或双引号（`"`）来表示字符串类型。反引号（```）来定义多行文本和内嵌表达式。```typescript
let name: string = "Runoob";
let years: number = 5;
let words: string = `您好，今年是 ${ name } 发布 ${ years + 1} 周年`;
```
 |
| 布尔类型 | boolean | 表示逻辑值：true 和 false。```typescript
let flag: boolean = true;
```
 |
| 数组类型 | 无 | 声明变量为数组。```typescript
// 在元素类型后面加上[]
let arr: number[] = [1, 2];

// 或者使用数组泛型
let arr: Array<number> = [1, 2];
```
 |
| 元组 | 无 | 元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。```typescript
let x: [string, number];
x = ['Runoob', 1];    // 运行正常
x = [1, 'Runoob'];    // 报错
console.log(x[0]);    // 输出 Runoob
```
 |
| 枚举 | enum | 枚举类型用于定义数值集合。```typescript
enum Color {Red, Green, Blue};
let c: Color = Color.Blue;
console.log(c);    // 输出 2
```
 |
| void | void | 用于标识方法返回值的类型，表示该方法没有返回值。```typescript
function hello(): void {
    alert("Hello Runoob");
}
```
 |
| null | null | 表示对象值缺失。 |
| undefined | undefined | 用于初始化变量为一个未定义的值 |
| never | never | never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。 |


<a name="615132fe"></a>
## 布尔型
```typescript
let isDone: boolean = false;
```

<a name="55d4790c"></a>
## 数字
和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。
```typescript
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
```

<a name="cc4dd1da"></a>
## 字符串
```typescript
let myName: string = 'Tom';
let sentence: string = `Hello, my name is ${myName}.`
```

<a name="f8obE"></a>
## Null 和 Undefined
<a name="null"></a>
### null
在 JavaScript 中 null 表示 "什么都没有"。

null是一个只有一个值的特殊类型。表示一个空对象引用。

用 typeof 检测 null 返回是 object。

<a name="undefined"></a>
### undefined
在 JavaScript 中, undefined 是一个没有设置值的变量。

typeof 一个没有值的变量会返回 undefined。

**Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。**

而在TypeScript中启用严格的空校验（`--strictNullChecks`）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下：
```typescript
// 启用 --strictNullChecks
let x: number;
x = 1; // 编译正确
x = undefined;    // 编译错误
x = null;    // 编译错误
```

上面的例子中变量 x 只能是数字类型。如果一个类型可能出现 null 或 undefined， 可以用 | 来支持多种类型，示例代码如下：
```typescript
// 启用 --strictNullChecks
let x: number | null | undefined;
x = 1; // 编译正确
x = undefined;    // 编译正确
x = null;    // 编译正确
```

<a name="yfdQG"></a>
## 数组
指定一个类型的数组，或通过泛型指定：
```typescript
let list1: number[] = [1, 2, 3]
let list2: Array<number> = [4, 5, 6]
```

编译成JS：
```javascript
var list1 = [1, 2, 3];
var list2 = [4, 5, 6];
```

<a name="fJgla"></a>
### 只读数组
TypeScript 具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：
```typescript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!

ro = []; // okay
```

上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。但是可以用类型断言重写：
```typescript
a = ro as number[];
```

<a name="lAR4U"></a>
### 用接口表示数组
接口也可以用来描述数组：
```typescript
interface NumberArray {
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];
```
`NumberArray` 表示：只要 `index` 的类型是 `number`，那么值的类型必须是 `number`。

<a name="VEwuR"></a>
### 任意类型元素的数组
一个比较常见的做法是，用 any 表示数组中允许出现任意类型：
```typescript
let list: any[] = ['Xcat Liu', 25, { website: 'https://www.xiaoyulive.top' }];
```

<a name="VZGdc"></a>
## 元组
元组相当于是一个定义了每个下标的元素的类型的数组
```typescript
let x: [string, boolean] = ['show', false]
```

编译成JS：
```javascript
var x = ['show', false];
```

也可先声明，然后整体赋值或按照索引赋值：
```typescript
let x: [string, boolean]

x = ['show', false]

x[0] = 'show'
x[1] = false
```

<a name="Hl110"></a>
### 越界的元素
当试图添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：
```typescript
let x: [string, boolean] = ['show', false]

x.push(true)
x.push('hide')
// [ 'show', false, true, 'hide' ]
```

<a name="OMsJx"></a>
## 枚举
使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。

枚举类型支持正向映射和反向映射：
```typescript
enum Color { Red = 1, Green = 2, Blue = 3 }

console.log(Color.Blue) // 3
console.log(Color[1]) // Red
```

编译成JS：
```javascript
var Color;
(function (Color) {
    Color[Color["Red"] = 1] = "Red";
    Color[Color["Green"] = 2] = "Green";
    Color[Color["Blue"] = 3] = "Blue";
})(Color || (Color = {}));
console.log(Color[1]); // Red
console.log(Color.Blue); // 3
```

<a name="v3ArZ"></a>
### 手动赋值
我们也可以给枚举项手动赋值：
```typescript
enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};
console.log(Days["Sun"] === 7); // true
console.log(Days["Mon"] === 1); // true
console.log(Days["Tue"] === 2); // true
console.log(Days["Sat"] === 6); // true
```

上面的例子中，**未手动赋值的枚举项会接着上一个枚举项递增，步长为1**。

如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：
```typescript
enum Days {Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat};
console.log(Days["Sun"] === 3); // true
console.log(Days["Wed"] === 3); // true
console.log(Days[3] === "Sun"); // false
console.log(Days[3] === "Wed"); // true
```

上面的例子中，递增到 `3` 的时候与前面的 `Sun` 的取值重复了，但是 TypeScript 并没有报错，导致 `Days[3]` 的值先是 `"Sun"`，而后又被 `"Wed"` 覆盖了。编译的结果是：
```typescript
var Days;
(function (Days) {
    Days[Days["Sun"] = 3] = "Sun";
    Days[Days["Mon"] = 1] = "Mon";
    Days[Days["Tue"] = 2] = "Tue";
    Days[Days["Wed"] = 3] = "Wed";
    Days[Days["Thu"] = 4] = "Thu";
    Days[Days["Fri"] = 5] = "Fri";
    Days[Days["Sat"] = 6] = "Sat";
})(Days || (Days = {}));
```

所以使用的时候需要注意，最好不要出现这种覆盖的情况。

手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：
```typescript
enum Days {Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = <any>"S"};
```

```typescript
var Days;
(function (Days) {
    Days[Days["Sun"] = 7] = "Sun";
    Days[Days["Mon"] = 8] = "Mon";
    Days[Days["Tue"] = 9] = "Tue";
    Days[Days["Wed"] = 10] = "Wed";
    Days[Days["Thu"] = 11] = "Thu";
    Days[Days["Fri"] = 12] = "Fri";
    Days[Days["Sat"] = "S"] = "Sat";
})(Days || (Days = {}));
```

当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 `1`：
```typescript
enum Days {Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat};
console.log(Days["Sun"] === 7); // true
console.log(Days["Mon"] === 1.5); // true
console.log(Days["Tue"] === 2.5); // true
console.log(Days["Sat"] === 6.5); // true
```

<a name="rubdr"></a>
### 常数项和计算所得项
枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。

前面我们所举的例子都是常数项，一个典型的计算所得项的例子：
```typescript
enum Color {Red, Green, Blue = "blue".length};
```

上面的例子中，`"blue".length` 就是一个计算所得项。

上面的例子不会报错，但是**如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错**：
```typescript
enum Color {Red = "red".length, Green, Blue};
// index.ts(1,33): error TS1061: Enum member must have initializer.
// index.ts(1,40): error TS1061: Enum member must have initializer.
```

如果枚举有 `const` 修饰，也会报错：
```typescript
const enum Color {Red, Green, Blue = "blue".length};
```

<a name="C6ch8"></a>
### 常数枚举
常数枚举是使用 `const enum` 定义的枚举类型：
```typescript
const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
```

常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。

上例的编译结果是：
```typescript
var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
```

<a name="rr571"></a>
## Any
任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下几种情况。

1. 通过 any 可以指定一个不确定类型的变量
```typescript
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay
```

2. 跟普通的JS一样可以动态扩展。

如果是对象类型，编译报错：
```typescript
let obj: object = { a: 0, b: 2}
obj.c = 3 // Error: Property 'c' does not exist on type 'object'.
```
如果是any则编译通过：
```typescript
let obj: any = { a: 0, b: 2}
obj.c = 3 // okay
```

3. 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：
```typescript
let something;
something = 'one';
something = 1;
```

注意，如果声明的时候同时赋值，将触发**类型推断**：
```typescript
let something = 'one';
something = 1; // Type '1' is not assignable to type 'string'.ts(2322)
```

4. 改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查。

示例代码如下：
```typescript
let x: any = 4;
x.ifItExists();    // 正确，ifItExists方法在运行时可能存在，但这里并不会检查
x.toFixed();    // 正确
```

5. 定义存储各种类型数据的数组时。

示例代码如下：
```typescript
let arrayList: any[] = [1, false, 'fine'];
arrayList[1] = 100;
```

<a name="3wwLb"></a>
## Void
某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：
```typescript
function warnUser(): void {
    console.log("This is my warning message");
}
```

声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：
```typescript
let unusable: void = undefined;
```

<a name="yXkUb"></a>
## Never
never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。

never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。即使 any也不可以赋值给never。

下面是一些返回never类型的函数：
```typescript
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
```

<a name="t7P25"></a>
## Object
object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。

使用object类型，就可以更好的表示像Object.create这样的API。例如：
```typescript
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```

<a name="TCac3"></a>
## 装箱与拆箱
以下，使用 Boolean 进行演示，其他基本类型（除了 null 和 undefined）一样，不再赘述。

使用构造函数 Boolean 创造的对象不是布尔值：
```typescript
let createdByNewBoolean: boolean = new Boolean(1);
// error TS2322: Type 'Boolean' is not assignable to type 'boolean'.
```

事实上 new Boolean() 返回的是一个 Boolean 对象：
```typescript
let createdByNewBoolean: Boolean = new Boolean(1);
```

直接调用 Boolean 也可以返回一个 boolean 类型：
```typescript
let createdByBoolean: boolean = Boolean(1);
```

但是一个原始数据类型可以使用装箱类型声明：
```typescript
let createdByNewBoolean: Boolean = false;
```

<a name="Kefpx"></a>
## 联合类型
联合类型（Union Types）表示取值可以为多种类型中的一种。
```typescript
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

myFavoriteNumber = true;
// error TS2322: Type 'boolean' is not assignable to type 'string | number'.
//   Type 'boolean' is not assignable to type 'number'.
```

联合类型使用 `|` 分隔每个类型。

这里的 `let myFavoriteNumber: string | number` 的含义是，允许 `myFavoriteNumber` 的类型是 `string` 或者 `number`，但是不能是其他类型。

<a name="e9Fnn"></a>
### 访问联合类型的属性或方法
当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型里共有的属性或方法**：
```typescript
function getLength(something: string | number): number {
    return something.length;
}

//error TS2339: Property 'length' does not exist on type 'string | number'.
//   Property 'length' does not exist on type 'number'.
```

上例中，`length` 不是 `string` 和 `number` 的共有属性，所以会报错。

访问 `string` 和 `number` 的共有属性是没问题的：
```typescript
function getString(something: string | number): string {
    return something.toString();
}
```

联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：
```typescript
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
console.log(myFavoriteNumber.length); // 5

myFavoriteNumber = 7;
console.log(myFavoriteNumber.length); // 编译时报错
// error TS2339: Property 'length' does not exist on type 'number'.
```

上例中，第二行的 `myFavoriteNumber` 被推断成了 `string`，访问它的 `length` 属性不会报错。

而第五行的 `myFavoriteNumber` 被推断成了 `number`，访问它的 `length` 属性时就报错了。

<a name="b2eAK"></a>
## 类型断言
类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。

类型断言有两种形式。 其一是 `尖括号` 语法：
```typescript
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
```

另一个为 `as` 语法：
```typescript
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
```

在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用 as 语法。

<a name="shJxi"></a>
### 应用: 将一个联合类型的变量指定为一个更加具体的类型
之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型里共有的属性或方法**

而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法, 此时可以使用类型断言，将 something 断言成 string：
```typescript
function getLength(something: string | number): number {
  if ((<string>something).length) {
    return (<string>something).length;
  } else {
    return something.toString().length;
  }
}
```

**类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的**：
```typescript
function toBoolean(something: string | number): boolean {
    return <boolean>something;
}

// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.
//   Type 'number' is not comparable to type 'boolean'.
```


<a name="EIGPr"></a>
## 参考资料

- [TypeScript 基础类型 | 菜鸟教程](https://www.runoob.com/typescript/ts-type.html)
- [JavaScript typeof, null, 和 undefined | 菜鸟教程](https://www.runoob.com/js/js-typeof.html)

