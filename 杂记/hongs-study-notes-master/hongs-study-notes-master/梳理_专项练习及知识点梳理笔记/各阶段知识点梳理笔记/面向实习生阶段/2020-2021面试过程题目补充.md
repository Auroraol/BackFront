> 面试过程中遇到的题目记录,也有同学面试过程遇到的 

# #目录

>[TOC]

# 一、jquery  

怎么用的  

##### 1.JQ入口函数意义=>

-   入口函数,通常使用和window.onload一样的功效

-   区别:在jquery文件加载后,同时当前的window下面已经有了$和jq对象后,才开始运行



# 二、VUE

vue生命周期

创建前这时候做了什么 ?  初始化什么东西    什么时候挂载data

销毁前做什么操作的?

data   return为什么是函数或者对象

>创建前(befroecreate)
>
>​	实例刚在内存中被创建出来,此时,还没有初始化好data和method,换句话说就当前实例只是一个空壳,无法访问到数据和真实的dom,一般不做操作挂在数据,绑定事件等
>
>创建后(created)
>
>​	在这个阶段vue实例已经 创建,初始化了data和method,但是这个时候仍然不能获取dom元素,这时候可以更改数据,不会触发其他的钩子函数,一般可以在这里做一些初始数据的获取,接下去开始找实例或者组件对应的模板,之后就开始进入下一个生命周期
>
>渲染前(befroemount)
>
>​	这时候虚拟dom已经创建完成了,完成了模板编译.马上就要渲染,在这里也可以更改数据,不会触发updated,一般在这里可以做初始数据的获取
>
>渲染后(Mountd)
>
>​	mounted是我们平常用的最多的函数,一般我们的异步请求都写在这里.接下来开始渲染render,渲染真实的dom,将编译好的模板,挂载到页面指定的容器显示
>
>更新前(beforeupdate)
>
>​	状态更新前执行此函数,此时dat中的状态值是最新的,但是界面上显示的数据还是旧的,因为此时还没有渲染don节点
>
>更新后(updated)
>
>​	实例更新完毕后调用此函数,dom会和更改过的内容同步然后界面重新渲染
>
>销毁前(beforeDestroy)
>
>​	当经过某种途径调用$destroy方法后(清除vue实例和dom的关联),立即执行beforeDestroy,这时候vue实例已经从运行阶段进入了销毁阶段
>
>一般在这里进行一些善后工作,例如清除计时器、清除非指令绑定的时间等等   
>
>销毁后(destroyed)
>
>​	组件的数据绑定、监听去掉后只剩下dom空壳,这个时候,执行destroyed







# 三、flex与居中

##### 水平居中 

>行内元素:text-align :center
>
>块级元素:margin:0 auto
>
>​		position:absolute+left:50%+transform:translateX(-50%)
>
>​		display:flex+justify-content:center

##### 垂直居中

> 行内元素:line-height:==height
>
> 块级元素:
>
> ​		position:absolute+top:50%+transform:translateY(-50%)
>
> ​		display:flex+align-item:center
>
> ​		display:table+dispaly:table-cell+vertical-align:middle



# 四、nginx怎么操作

怎么修改配置文件

### 1在Nginx中添加一个server类，如下：

#### 2.Niginx配置文件及其跨域原理=>

###### 		① server表示启动一个代理服务器

###### 		② 该代理服务器也是静态文服 (静态文件要通过代理服务器来访问)

  			   1)因为代理服务器只能监听代理服务器的端口
  					  2)所以前端发出的所有请求一定是基于80端口去发出
  		   			  3)这样子,前端的所有跨域请求才可以被监听到
  					  4)才能实现 前端和代理服务器之间的不跨域

###### 		 ③ 80 表示监听80端口 所以最终我们的前端资源一定是部署在80端口上

 			    1)通过相对路径 html
 			  		 2)通过绝对路径  静态文服

###### 		 ④ location /cross

   			  1)服务端的接口的uri ,不一定要cross(联想alias,它只是一个规则,并没有表示真正的意图)
   					     http://localhost/cross/cross 后面的cross才是我们正要去访问的uri

###### 		  ⑤ proxy_pass

​    			  1) 表示我们真正想要请求的地址是......

###### 		  ⑥ add_header

   			   2) 就是我们在请求成功之后 响应头要添加的内容

# 五、E-vchart怎么使用

> v-charts是基于echarts的二次封装，使用起来异常方便，地址：https://v-charts.js.org/#/。



# 陆、es6的新增功能

##### 箭头函数箭头指向

> 箭头函数并没有绑定自己的this,在箭头函数中调用this时候,仅仅是简单的沿着作用域链向上寻找最近的一个this来使用,换句话说就是及那头函数的this指向是在定义函数的时候绑定的
>
> 而普通函数的this执行时只想调用它的对象



# 柒、npm 

> NPM代表节点包管理器（*Node Package Manager*）。它是JavaScript编程语言的默认包管理器。 NPM用于安装/更新Javascript的包和模块。

# 捌、webpack5新特性

使用持久化缓存提高构建性能；

使用更好的算法和默认值改进长期缓存（long-term caching）；

清理内部结构而不引入任何破坏性的变化；

引入一些breaking changes，以便尽可能长的使用v5版本。

# 玖、redis数据库

### redis 常见数据结构以及使用场景分析

#### 1. String

> **常用命令:** set,get,decr,incr,mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。

#### 2.Hash

> **常用命令：** hget,hset,hgetall 等。

Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：



```csharp
key=JavaUser293847
value={
  “id”: 1,
  “name”: “SnailClimb”,
  “age”: 22,
  “location”: “Wuhan, Hubei”
}
```

#### 3.List

> **常用命令:** lpush,rpush,lpop,rpop,lrange等

list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

#### 4.Set

> **常用命令：** sadd,spop,smembers,sunion 等

set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：



```undefined
sinterstore key1 key2 key3     将交集存在key1内
```

#### 5.Sorted Set

> **常用命令：** zadd,zrange,zrem,zcard等

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

**举例：** 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。

### redis 设置过期时间

Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。

如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？

**定期删除+惰性删除。**

通过名字大概就能猜出这两个删除方式的意思了。

- **定期删除**：redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？

**redis 内存淘汰机制。**

### redis 内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？）

redis 配置文件 redis.conf 中有相关注释，大家可以自行查阅或者通过这个网址查看： [http://download.redis.io/redis-stable/redis.conf](https://links.jianshu.com/go?to=http%3A%2F%2Fdownload.redis.io%2Fredis-stable%2Fredis.conf)

**redis 提供 6种数据淘汰策略：**

1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

**备注： 关于 redis 设置过期时间以及内存淘汰机制，我这里只是简单的总结一下，后面会专门写一篇文章来总结！**

### redis 持久化机制（怎么保证 redis 挂掉之后再重启数据可以进行恢复）

很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。

Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。**Redis的一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF）**.这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。

**快照（snapshotting）持久化（RDB）**

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。

快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：



```bash
save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

**AOF（append-only file）持久化**

与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：



```undefined
appendonly yes
```

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。

在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：



```bash
appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no      #让操作系统决定何时进行同步
```

为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

**Redis 4.0 对于持久化机制的优化**

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

**补充内容：AOF 重写**

AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。

AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任伺读入、分析或者写入操作。

在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作

### redis 事务

Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity)、一致性(Consistency)和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。

### 重点:缓存雪崩和缓存穿透问题解决方案

**缓存雪崩**

> 
>
> 简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
>
> ​	因为缓存层承载了大量的请求，有效的保护了存储 层，但是如果缓存由于某些原因，整体不能够提供服务，于是所有的请求，就会到达存储层，存储层的调用量就会暴增，造成存储层也会挂掉的情况。缓存雪崩的英文解释是奔逃的野牛，指的是缓存层当掉之后，并发流量会像奔腾的野牛一样，大量后端存储。
>
> 存在这种问题的一个场景是：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，大量数据会去直接访问DB，此时给DB很大的压力。



解决办法：

- 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
- 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
- 事后：利用 redis 持久化机制保存的数据尽快恢复缓存

> **2.解决方法**
>
> （1）设置redis集群和DB集群的高可用，如果redis出现宕机情况，可以立即由别的机器顶替上来。这样可以防止一部分的风险。
>
> （2）使用互斥锁
>
> 在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个key只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用synchronized或者lock来解决，如果是分布式环境，可以是用redis的setnx命令来解决。
>
> （3）不同的key,可以设置不同的过期时间，让缓存失效的时间点不一致，尽量达到平均分布。
>
> （4）永远不过期
>
> redis中设置永久不过期，这样就保证了，不会出现热点问题，也就是物理上不过期。
>
> （5）资源保护
>
> 使用netflix的hystrix，可以做各种资源的线程池隔离，从而保护主线程池。



![img](https:////upload-images.jianshu.io/upload_images/14534869-cefa2f5519af3a09.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1137/format/webp)

image

**缓存穿透**

> 简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
>
> ​		  一般的缓存系统，都是按照key值去缓存查询，如果不存在对应的value，就应该去DB中查找 。这个时候，如果请求的并发量很大，就会对后端的DB系统造成很大的压力。这就叫做缓存穿透关键词：缓存value为空；并发量很大去访问DB。

解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。



### 如何解决 Redis 的并发竞争 Key 问题

所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）

基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

在实践中，当然是从以可靠性为主。所以首推Zookeeper。

参考：

- https://www.jianshu.com/p/8bddd381de06

### 如何保证缓存与数据库双写时的数据一致性？

你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是**先更新数据库，然后再删除缓存。**

**这种情况不存在并发问题么？**

不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生

（1）缓存刚好失效
 （2）请求A查询数据库，得一个旧值
 （3）请求B将新值写入数据库
 （4）请求B删除缓存
 （5）请求A将查到的旧值写入缓存

ok，如果发生上述情况，确实是会发生脏数据。

然而，发生这种情况的概率又有多少呢？

发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。

**如何解决上述并发问题？**

首先，给缓存设有效时间是一种方案。其次，采用异步延时删除策略，保证读请求完成以后，再进行删除操作。



# 拾、sql笔试题

A表 记录了某学校专业课程信息(课程编号,课程名称)  主键  课程编号

B表 激励了该学校的学生信息(学生编号 姓名 性别 年龄 班级编号 班级名称) 主键 学生编号 

C表 记录了学生成绩(学生编号 课程编号 成绩)



## 1.请用sql语句创建上述A,B,C三表

```sql
create table `A`{
	`课程编号` varchar(50) not null,
	`课程名称` varchar(50) not null,
	primary key (`课程编号`)
}

create table `B`{
	`学生编号` int(11) not null,
	`姓名` varchar(50) not null,
	`性别` char(2) check(`性别`=`男` or `性别`=`女`) not null,
	`年龄` int(11) not null,
	`班级编号` varchar(50) not null,
	`班级名称` varchar(50) not null,
	primary key (`学生编号`)
}
create table `C`{
	`学生编号` int(11) not null,
	`课程编号` varchar(50) not null,
	`成绩`  numeric(3,1)  或者float(1) not null
}
```

## 2.在A,B,C表中构建出5个课程,5个学生记录

```sql
insert into A(`课程编号`,`课程名字`) values
(`高数二下`,`高数二下的名字`), (`离散数学`,`离散数学的名字`), (`yw`,`语文`), (`rjgc`,`软件工程`), (`xx`,`美术`)
insert into B(`学生编号`,`姓名`,`性别`) values
(`001`,`洪吉林`,`男`),(`002`,`洪上述`,`男`),(`003`,`洪嗷嗷`,`男`),(`004`,`洪男`,`男`),(`005`,`洪女`,`女`)
insert into C(`学生编号`,`课程编号`,`成绩`) values 
(`高数二下`,`洪吉林`,`100`),(`高数离散数学`,`洪女`,`50`),(`高数离散数学`,`洪男`,`50`)
```

## 3.请写一个sql语句取出满足条件的信息字段(班级名称 姓名 性别 课程名称 成绩)

##### 条件1:

​	1.课程编号"高数二下"的成绩>=78 或者 课程编号"离散数学" 的成绩>=85

 2.  女性学生

     ```sql
     select 班级名称,姓名,性别,课程名称,成绩 from C join B on C.学生编号=B.学生编号 join A on C.课程编号=A.课程编号 where A.课程名称=`高数二下` and C.成绩 >= 78 or A.课程名称=`离散数学` and C.成绩 >=87 and B.性别=`女` 
     ```



##### 条件2:

​	1.所有课程成绩都在75分以上

	2. 女性学生

```sql
select 班级名称,姓名,性别,课程名称,成绩 from C join B on C.学生编号=B.学生编号 where B.性别=`女` where C.成绩>=75
```

## 4.按照学生总成绩高低排序,列出(班级 姓名 性别 成绩)

```sql
select sum(C.成绩) from C group by C.学生编号 order by sum(C.成绩) desc
```

# 十一、算法题

## Ⅰ-关于交集算法

>假定二维空间平面内有n个圆,现在我们需要将存在`交集`的圆进行分组,输出结果为n个组,每个组包含i个圆. 
>交集算法: 两圆心的距离 小于 两圆半径之和. 
>假设圆数据为: (用数组表示圆)
>
>~~~json
>[
>{ X: 0, Y: 0, Radius: 1 },
>    { X: 3, Y: 2, Radius: 2 },
>    { X: 2, Y: 1, Radius: 3 },
>    { X: 5, Y: 2, Radius: 4 },
>    { X: 1, Y: 3, Radius: 5 },
>    { X: 2, Y: 4, Radius: 6 },
>    { X: 2323, Y: 121, Radius: 7 },
>    { X: 2323, Y: 121, Radius: 7 },
>    { X: 2322, Y: 121, Radius: 7 },
>]
>那么输出的结果为:  
>```json
>​​​​​[ [ { X: 0, Y: 0, Radius: 1 },​​​​​
>​​​​​    { X: 2, Y: 1, Radius: 3 },​​​​​
>​​​​​    { X: 1, Y: 3, Radius: 5 },​​​​​
>​​​​​    { X: 2, Y: 4, Radius: 6 },​​​​​
>​​​​​    { X: 3, Y: 2, Radius: 2 },​​​​​
>​​​​​    { X: 5, Y: 2, Radius: 4 } ],​​​​​
>​​​​​  [ { X: 2323, Y: 121, Radius: 7 },​​​​​
>​​​​​    { X: 2323, Y: 121, Radius: 7 },​​​​​
>​​​​​    { X: 2322, Y: 121, Radius: 7 } ] ]​​​​​
>```
>假设代码结构为如下:  
>```json
>    { X: 1, Y: 0.7, Radius: 0.6 },
>    { X: 0, Y: 0, Radius: 0.6 },
>    { X: 1, Y: 0, Radius: 0.5 },
>```
>//圆1和圆2并不交集.  
>//圆2和圆3存在交集  
>//圆1和圆3存在交集  
>//那么结果为  
>[cir1,cir2,cir3]//他们应该是一组的.  
>'''
>用JavaScript设计代码并实现它.
>~~~

## Ⅱ-需要做一个累加算法，一个外层函数 可以传入参数n 返回一个函数 这个函数里面有个变量i 每次调用这个外层函数的时候 里面的变量i自加1

> 此部分用到高阶函数柯里化相关知识点
>
> 相关知识点在本人[Es6笔记](https://gitee.com/hongjilin/hongs-study-notes/blob/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%91%98%E5%BD%95%E4%B8%8E%E7%AC%94%E8%AE%B0/A_ES6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85%E4%B8%8E%E6%89%80%E9%81%87%E9%97%AE%E9%A2%98.md)
>
> ![image-20210425184604712](2020-2021面试过程题目补充中的图片/image-20210425184604712.png)

