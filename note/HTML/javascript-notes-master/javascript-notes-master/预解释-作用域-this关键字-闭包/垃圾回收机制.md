**垃圾回收机制**

JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存；

在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。

- 局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使
用这些变量，直至函数执行结束。
- 此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；
- 但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略;**标记清除**和**引用计数**。


----------


- **标记清除**（浏览器实现）
- **引用计数**（浏览器实现）
- **性能问题**
- **开发过程中怎样管理内存**（代码实现）
- **总结**

# 标记清除（浏览器实现）

JavaScript 中最常用的垃圾收集方式是标记清除。

- 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
- 而当变量离开环境时，则将其标记为“离开环境”。

可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。

- 1、垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
- 2、它会去掉环境中的变量以及被环境中的变量引用的变量的标记。
- 3、在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
- 4、最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

# 引用计数（浏览器实现）

另一种不太常见的垃圾收集策略叫做引用计数。

引用计数的含义是跟踪记录每个值被引用的次数。

- 当声明了一个变量并将一个引用类型值赋给该变量时，则这个引用数据值的引用次数就是 1。
- 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。
- 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。
- 当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
- 这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

这种方式有一个严重的问题；循环引用；

	function problem(){
		var objectA = new Object();
		var objectB = new Object();
		objectA.someOtherObject = objectB;
		objectB.anotherObject = objectA;
	}

- objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。
- 但在采用引用计数策略的实现中，当函数执行完毕后， objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。
- 假如这个函数被重复多次调用，就会导致大量内存得不到回收。

# 性能问题；

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一次;

不禁让人联想到 IE 因此而声名狼藉的性能问题。IE 的垃圾收集器是根据内存分配量运行的，具体一点说就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64KB 的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。

随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：**触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正**。IE7 中的各项临界值在初始时与 IE6 相等。

- 如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。
- 如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。

> 这一看似简单的调整，极大地提升了 IE在运行包含大量 JavaScript 的页面时的性能。

事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在IE 中，调用 window.CollectGarbage() 方法会立即执行垃圾收集。在 Opera 7 及更高版本中，调用 window.opera.collect() 也会启动垃圾收集例程。

# 开发过程中怎样管理内存（代码实现,比较重要的思想）

使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。


** 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）**。

** 这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用；**

	function createPerson(name){
		var localPerson = new Object();
		localPerson.name = name;
		return localPerson;
	}
	var globalPerson = createPerson("Nicholas");
	// 手工解除 globalPerson 的引用
	globalPerson = null;

在这个例子中，变量 globalPerson 取得了 createPerson() 函数返回的值。在 createPerson()函数内部，我们创建了一个对象并将其赋给局部变量 localPerson ，然后又为该对象添加了一个名为name 的属性。最后，当调用这个函数时， localPerson 以函数值的形式返回并赋给全局变量globalPerson 。

由于 localPerson 在 createPerson() 函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。

但是对于全局变量 globalPerson 而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。

> 不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

# 总结

JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下 5种基本数据类型： Undefined 、 Null 、 Boolean 、 Number 和 String 。

基本类型值和引用类型值具有以下特点：

- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
- 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符；如果要绝对准确的判断某个变量的数据类型，可以使用
	
	var testStr = 'cccccccc';
	var testAry = [2,3,4,5];
	var testObj = {
	    name:"zhu",
	    age:26,
	    gender:"man"
	};
	
	console.log({}.toString.call(testStr));//[object String]
	console.log({}.toString.call(testAry));//[object Array]
	console.log({}.toString.call(testObj));//[object Object]

所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，**这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量**。以下是关于执行环境的几点总结：

- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
- 变量的执行环境有助于确定应该何时释放内存。

JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结。

- 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
- “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
- 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。
- 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
- 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。