# ------------------==(Java肆)==---------------------

# 继承与重写=>day7_29笔记总结

## 一.访问修饰符

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)  | 其他包 |
| :---------- | :----- | :------- | :------------- | :-------------- | :----- |
| `public`    | √      | √        | √              | √               | √      |
| `protected` | √      | √        | √              | √/×（子类可以） | ×      |
| `default`   | √      | √        | √              | ×               | ×      |
| `private`   | √      | ×        | ×              | ×               | ×      |

## 二.重写

###### **2.1)方法的重载:** 

​	在同一个类中,出现多个同名的方法,参数列表不同,与返回值类型,修饰	符无关

>- 方法名称必须相同。
>- 参数列表必须不同。
>- 方法的返回类型可以相同也可以不相同。
>- 仅仅返回类型不同不足以称为方法的重载

###### **2.2)方法的重写:**

​	 子类中出现和父类中一模一样的方法(包括返回值类型,方法名,参数列表)

######  2.3)**方法重写的注意事项:**

1.重写的方法必须要和父类一模一样(包括返回值类型,方法名,参数列表)

2.重写的方法可以使用@Override注解来标识

3.**子类中重写的方法的访问权限不能低于父类中方法的访问权限**

**权限修饰符 : private <  默认(什么都不写) <  protected < public**

######  2.4)为什么要重写方法:

1.当父类中的方法无法满足子类需求的时候,需要方法重写

2.当子类具有特有的功能的时候,就需要方法重写

###### 2.5)重写的应用

子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。

## 三.抽象类

### 1、概述

当父类知道子类应该包含什么样的方法，但无法确定子类如何实现这些方法；在分析事物时，会发现事物的共性，将共性抽取出，实现的时候，就会有这样的情况：方法功能声明相同，但方法功能主体不同，这时，将方法声明抽取出，那么，此方法就是一个抽象方法。

###### **1、抽象的定义格式**

>- 抽象方法的定义格式：public abstract 返回值类型 方法名（参数）；
>- 抽象类的定义格式：abstract class 类名{}

###### **2、抽象的特点**

>- 抽象类和抽象方法都需要被 abstract 修饰，抽象方法一定要定义在抽象类中
>- 抽象不能直接创建对象，因为调用抽象方法没有意义
>- 只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象，否则该子类还是一个抽象类
>- 之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单

###### **3、抽象类的注意事项**

>- 抽象类一定是个父类，因为是不断抽取而来的
>- 抽象类中可以不定义抽象方法，其存在的意义就是不让该类创建对象，方法可以直接让子类去使用
>- 抽象关键字 abstract 不可以和以下关键字共存：
>  private：私有的方法子类是无法继承到的，也不存在覆盖，如果 abstract 和 private 一起使用修饰方法， abstract 既要子类去实现这个方法，而 private 修饰子类根本无法得到父类这个方法，互相矛盾
>  final：final 修饰的类不能被继承，而抽象类一定是父类
>  static：static 修饰的表示静态的，不能被修改的，但可以直接被类所调用，而abstract修饰的是抽象的，即没有方法实体，也不能直接被调用

### **2、代码实例**

###### 			1.先创建Develop.java父类，创建Develop抽象类，并创建抽象方法

```java
package MyAbstract;
/**
 * 定义开发人员类，所有开发人员都具有工作的共性，
 * 对工作共性进行抽取，然后形成一个Develop类
 * 定义方法：工作
 * 抽象类不能实例化对象，即不能new，抽象方法没有主体，不能运行
 * 抽象类的使用：可以定义类继承抽象类，将抽象方法进行重写，创建子类的对象
 */
public abstract class Develop {
    //定义工作方法，但具体怎么工作，并不明白，所以干脆不说，即抽象方法
    //必须使用abstract关键字修饰
    //抽象的方法必须存在抽象类中，类也必须使用abstract关键字修饰
    public abstract void work();
}
```

###### 			2.再创建Php.java子类，重写父类的抽象方法

```java
package MyAbstract;
/**
 * 定义PHP开发人员
 * 继承抽象类Develop，重写抽象的方法
 */
public class Php extends Develop {
    //重写父类的抽象方法，去掉abstract关键字，加上方法主体
    public void work()
    {
        System.out.println("正在开发网页！");
    }
}
```

###### 			3.在Main.java中调用

```java
package MyAbstract;
public class Main {
    public static void main(String[] args)
    {
        Php ph = new Php();
        ph.work();
    }
}
```

###### 实例解析=>

- 将共性“研发人员”抽取出来形成一个Develop类并定义方法：工作
- 抽象类不能实例化，即不能 new 抽象方法没有主体
- 可以定义类来继承抽象类，将抽象类进行重写，然后创建子类的对象
- 重写父类的抽象方法时，去掉abstract关键字，加上方法主体

## 四.final修饰符

​	1.修饰的类,不能在被继承

​	2.修饰的方法不能被子类重写

​	3.修饰的变量将变成厂里,只能在初始化时进行赋值



