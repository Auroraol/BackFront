# ---------------==(Java叁)==------------------

# 对象和封装=>day7_30笔记总结

## 一.封装

##### 	1.封装的概念

> 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包	   		装、隐藏起来的方法。
>
> 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。
>
> 要访问该类的代码和数据，必须通过严格的接口控制。
>
> 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。
>
> 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。



##### 	2.封装的优点

			1. 良好的封装能够减少耦合。
   			2. 类内部的结构可以自由修改。
   			3.  可以对成员变量进行更精确的控制。
   			4.  隐藏信息，实现细节。



## 二.final的使用

##### 	1.修饰类

当用final去修饰一个类的时候，表示这个类不能被继承。注意：

a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。

b. final类中的成员方法都会被隐式的指定为final方法。说明：在自己设计一个类的时候，要想好这个类将来是否			会被继承，如果可以被继承，则该类不能使用fianl修饰，在这里呢，一般来说工具类我们往往都会设计成为一			个fianl类。在JDK中，被设计为final类的有String、System等。代码：



![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2411423419,2520809892&fm=173&app=25&f=JPEG?w=640&h=360&s=A5F26D32073A64294451C0DA0000C0B3)



##### 2.修饰方法

被final修饰的方法不能被重写。注意：

a. 一个类的private方法会隐式的被指定为final方法。

b. 如果父类中有final修饰的方法，那么子类不能去重写。

**代码：**



![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=876634331,3528497804&fm=173&app=25&f=JPEG?w=640&h=336&s=C6D0ED32877A44280ED888DE0000C0B3)

##### **3. 修饰成员变量**

a. 必须要赋初始值，而且是只能初始化一次。

**代码：**



![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=433607551,3063868730&fm=173&app=25&f=JPEG?w=640&h=360&s=E952ED1A053E64291CF889DA020090B3)

##### 4.**修饰成员变量**

a. 必须初始化值。

b. 被fianl修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。

c. 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。

d. 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。

**代码：**



![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=682519727,1257936163&fm=173&app=25&f=JPEG?w=640&h=336&s=C6D2ED3A0F2255205EE194DA0000D0B1)



## 三.Static(静态关键字)的使用

##### 	1.static的作用:

static的主要作用在于创建独立于具体对象的域变量或者方法

##### 	2.static要解决什么问题？

我们知道，当我们通过new关键字去创建对象的时候，那么数据的存储空间才会被分配，类中的成员方法才能被对象		所使用。但是呢有两种特殊的情况：

1. 我们通过new关键字创建的对象共享同一个资源，而不是说每个对象都拥有自己的数据，或者说根本就不需要去创建对象，这个资源和对象之间是没有关系的。
2. 希望某个方法不与包含它的类的任何对象联系在一起。总结下来就是说：**即使没有创建对象，也能使用属性和调用方法**，static目的就是在于解决这个问题。

#####     3.static特点=>

1. static可以修饰变量，方法
2. 被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。
3. 在类被加载的时候，就会去加载被static修饰的部分。
4. 被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。

##### 4.**static静态变量**

> 被static修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被static修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。

##### 5.**静态变量和实例变量的区别**

1. 实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，**在内存中，创建几次对象，就有几份成员变量**。

   2.静态变量：静态变量由于不属于任何实例对象，是属于类的，所以在内存中只会有一份，在类的加载过程中，JVM为静态变量分配一次内存空间

##### 6.**static静态方法**

> 被static修饰的方法也叫做静态方法，因为对于静态方法来说是不属于任何实例对象的，那么就是说在静态方法内部是不能使用this的，因为既然不属于任何对象，那么就更谈不上this了。

##### 7.**static使用注意事项**

1. 在静态方法中没有this关键字因为静态是随着类的加载而加载，而this是随着对象的创建而存在的。
2. 静态比对象优先存在。静态可以访问静态的，但是静态不能访问非静态的。
3. 非静态的可以去访问静态的

##### 8.总结

1. 静态只能访问静态。
2. 非静态既可以访问非静态的，也可以访问静态的。



## 四.构造函数单例模式(提升知识点)

### 	1、概述

单例模式的**定义**就是**确保某一个类只有一个实例，并且提供一个全局访问点。**属于设计模式三大类中的**`创建型模式`**。
 单例模式具有典型的三个**特点**：

- 只有一个实例。
- 自我实例化。
- 提供全局访问点。

其**UML**结构图非常简单，就只有一个类，如下图：

![img](https:////upload-images.jianshu.io/upload_images/10149931-8d107c95af96efb0.png?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)



### 2、优缺点

- **优点**：由于单例模式只生成了一个实例，所以能够节约系统资源，减少性能开销，提高系统效率，同时也能够严格控制客户对它的访问。
- **缺点**：也正是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，这样扩展起来有一定的困难。

### 3、常见实现方式

常见的单例模式实现方式有五种：`饿汉式`、`懒汉式`、`双重检测锁式`、`静态内部类式`和`枚举单例`。而在这五种方式中**`饿汉式`**和**`懒汉式`**又最为常见。下面将一一列举这五种方式的实现方法：

- **饿汉式**：**线程安全**，调用效率高。但是不能延时加载。示例：



```java
public class SingletonDemo1 {

    //线程安全的
    //类初始化时，立即加载这个对象
    private static SingletonDemo1 instance = new SingletonDemo1();

    private SingletonDemo1() {
    }

    //方法没有加同步块，所以它效率高
    public static SingletonDemo1 getInstance() {
        return instance;
    }
}
```

由于该模式在加载类的时候对象就已经创建了，所以加载类的速度比较慢，但是获取对象的速度比较快，且是**线程安全**的。

- **懒汉式**：**线程不安全**。示例：



```java
public class SingletonDemo2 {

    //线程不安全的

    private static SingletonDemo2 instance = null;

    private SingletonDemo2() {
    }

    //运行时加载对象
    public static SingletonDemo2 getInstance() {
        if (instance == null) {
            instance = new SingletonDemo2();
        }
        return instance;
    }

}
```

由于该模式是在运行时加载对象的，所以加载类比较快，但是对象的获取速度相对较慢，且**线程不安全**。**如果想要线程安全的话可以加上`synchronized`关键字**，但是这样会付出惨重的效率代价。

- **懒汉式（双重同步锁）**



```java
public class SingletonDemo3 {

    private static volatile SingletonDemo3 instance = null;

    private SingletonDemo3() {
    }

    //运行时加载对象
    public static SingletonDemo3 getInstance() {
        if (instance == null) {
            synchronized(SingletonDemo3.class){
                 if(instance == null){
                     instance = new SingletonDemo3();
                 }
            }
        }
        return instance;
    }

}
```

```java
//调用
Book book=Book.getInfo();
```

由于剩下的几种实现方式暂没有接触过，可暂时参考[一张图搞定Java设计模式，单例模式](https://links.jianshu.com/go?to=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1570148907639754%26wfr%3Dspider%26for%3Dpc)。

**注**：注意单例模式所属类的**构造方法是私有的**，所以单例类是**不能被继承的**。

### 4、常见应用场景

- 网站计数器。
- 项目中用于读取配置文件的类。
- 数据库连接池。因为数据库连接池是一种数据库资源。
- Spring中，每个`Bean`默认都是单例的，这样便于Spring容器进行管理。
- Servlet中`Application`
- Windows中任务管理器，回收站。
   等等。