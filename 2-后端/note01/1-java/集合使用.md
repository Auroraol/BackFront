#  概述

Java集合常用的只有List，Map，Set，Queue。其中以List和Map最为常用。

# JAVA 集合框架

![img](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/1626705129923-24a40f64-2e72-4642-97de-82c9985a1422.gif)

# **Collection/Map**

## Collection

![image.png](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/1675944306163-614400c9-97eb-4f5d-8a9d-9b8a0e56ca94.png)

## Map

![image.png](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/1675944878649-6fedcfdc-40fd-441f-b4b8-4455a6b4873a.png)

# 常用集合

集合的选用主要考虑的就是：

+ 读写性能（取决于底层数据结构。线程安全集合还需额外考虑锁的性能），场景是否要求线程安全，场景是否要求有序。

常用集合的特点：

（1）线程不安全（因为最多的场景，集合都是使用在线程内部的，不涉及线程安全问题，即[栈封闭](https://www.yuque.com/bianyuan-yjrbs/cag5ka/ckb1zxg81p12qqbo)）

（2）底层数据结构的性能高

![image-20231116133730192](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/image-20231116133730192.png)

## Collection

### List

> 常用的ArrayList, LinkedList

+ 1)改查的操作多，尾部增删，选择ArrayList  

+ 2)**随机位置**增删的操作多，选择LinkedList.  

+ 3)考虑线程安全，选择Vector(弃用),  CopyOnWriteArrayList，或者synchronizedList

#### 创建与初始化

```java
// 使用ArrayList类创建List对象。ArrayList是基于数组实现的可变列表。可以根据需要进行动态添加、删除和修改元素。
List<String> list1 = new ArrayList<>();  // 只能先声明
 
// 使用LinkedList类创建List对象。LinkedList是基于链表实现的可变列表。与ArrayList相比，LinkedList在插入和删除元素时更高效，但在访问和查找元素时相对较慢。
List<String> list2 = new LinkedList<>();  // 只能先声明
 
// 创建不可变List对象。Arrays.asList() 方法将传递的元素转换为列表对象，并返回一个不可变的List。在这种列表中，无法添加或删除元素，也无法修改已有元素的值。
List<String> list3 = Arrays.asList("a", "b", "c");  //可以初始化  //中必须是具体的值
 
// 使用Collections类创建只读List对象，防止对列表进行任何修改操作。
List<String> list4 = Collections.unmodifiableList(Arrays.asList("a", "b", "c"));
```

#### 常用方法

##### 增加元素

- **add(Object e)：**向集合末尾处，添加指定的元素
- **addAll()方法：**将指定集合中的所有元素添加到List的末尾
- **ListIterator的add()方法：**将指定元素插入到ListIterator当前位置
- **add(int index, Object e):** 向集合指定索引处，添加指定的元素，原有元素依次后移

```java
/*
* add(int index, E)
* 将元素插入到列表的指定索引上
* 带有索引的操作,防止越界问题
* java.lang.IndexOutOfBoundsException
* ArrayIndexOutOfBoundsException
* StringIndexOutOfBoundsException
*/
public static void function(){
        List<String> list = new ArrayList<String>();
        list.add("abc1");
        list.add("abc2");
        list.add("abc3");
        list.add("abc4");
        System.out.println(list);

        list.add(1,"itcast");
        System.out.println(list);
}
```

```java
 List<String> list1 = new ArrayList<String>();
// 使用add()方法添加元素
list1.add("a");
list1.add("b");
 
// 使用addAll()方法添加元素 
List<String> subList = Arrays.asList("c", "d"); //不可变 List 视图 //数组
list1.addAll(subList);
 
// 使用ListIterator的add()方法添加元素
ListIterator<String>  List<String> list = new ArrayList<String>(); listIterator = list1.listIterator();
while (listIterator.hasNext()) {
    String s = listIterator.next();
    if (s.equals("b")) {
        listIterator.add("e");
    }
}
```

#### 删除元素

- **remove(Object e)**：将指定元素对象，从集合中删除，返回值为被删除的元素
- **remove(int index)**：将指定索引处的元素，从集合中删除，返回值为被删除的元素
- **removeAll()方法：**删除List中包含在指定集合中的所有元素
- **retainAll()方法：**仅保留List中包含在指定集合中的元素
- **ListIterator的remove()方法**：删除ListIterator上一次调用next()或previous()方法返回的元素

```java
/*
* E remove(int index)
* 移除指定索引上的元素
* 返回被删除之前的元素
*/
public static void function_1(){
        List<Double> list = new ArrayList<Double>();
        list.add(1.1);
        list.add(1.2);
        list.add(1.3);
        list.add(1.4);

        Double d = list.remove(0);
        System.out.println(d);
        System.out.println(list);
}
```

```java
// 使用remove()方法删除元素
list1.remove("a");
 
// 使用removeAll()方法删除元素
List<String> subList = Arrays.asList("b", "c");
list1.removeAll(subList);
 
// 使用retainAll()方法删除元素
List<String> subList2 = Arrays.asList("d", "e");
list1.retainAll(subList2);
 
// 使用ListIterator的remove()方法删除元素
ListIterator<String> listIterator = list1.listIterator();
while (listIterator.hasNext()) {
    String s = listIterator.next();
    if (s.equals("d")) {
        listIterator.remove();
    }
}
```

#### 替换元素

+ set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素

```java
/*
* E set(int index, E)
* 修改指定索引上的元素
* 返回被修改之前的元素
*/
public static void function_2(){
        List<Integer> list = new ArrayList<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);

        Integer i = list.set(0, 5);
        System.out.println(i);
        System.out.println(list);
}
```

#### 获取元素

+ get(int index)：获取指定索引处的元素，并返回该元素
+ indexOf():  查找元素索引

```java
// 使用get()方法获取元素
String s = list1.get(0);
 
// 使用indexOf()方法查找元素
int index = list1.indexOf("a");
```

#### LinkedList特有方法:获取,添加,删除

```java
/*
* LinkedList 链表集合的特有功能
* 自身特点: 链表底层实现,查询慢,增删快
* 
* 子类的特有功能,不能多态调用
*/
public class LinkedListDemo {
    public static void main(String[] args) {
        function_3();
    }
    /*
    * E removeFirst() 移除并返回链表的开头
    * E removeLast() 移除并返回链表的结尾
    */
    public static void function_3(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");

        String first = link.removeFirst();
        String last = link.removeLast();
        System.out.println(first);
        System.out.println(last);

        System.out.println(link);
    }

    /*
    * E getFirst() 获取链表的开头
    * E getLast() 获取链表的结尾
    */
    public static void function_2(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");

        if(!link.isEmpty()){
            String first = link.getFirst();
            String last = link.getLast();
            System.out.println(first);
            System.out.println(last);
        }
    }

    public static void function_1(){
        LinkedList<String> link = new LinkedList<String>();
        link.addLast("a");
        link.addLast("b");
        link.addLast("c");
        link.addLast("d");

        link.addFirst("1");
        link.addFirst("2");
        link.addFirst("3");
        System.out.println(link);
    }

    /*
    * addFirst(E) 添加到链表的开头
    * addLast(E) 添加到链表的结尾
    */
    public static void function(){
        LinkedList<String> link = new LinkedList<String>();

        link.addLast("heima");

        link.add("abc");
        link.add("bcd");

        link.addFirst("itcast");
        System.out.println(link);
    }
}
```

### **Set**

>常用的HashSet

+ HashSet(无序)
+ LinkedHashSet(保持顺序)
+ TreeSet(排序)

#### HashSet

无序

```java
public static void main(String[] args) {
    HashSet<String> set = new HashSet<String>();
    set.add(new String("abc"));
    set.add(new String("abc"));
    set.add(new String("bbc"));
    set.add(new String("bbc"));
    System.out.println(set);
}
```

#### LinkedHashSet

保持顺序

```java
public class LinkedHashSetDemo {
    public static void main(String[] args) {
        LinkedHashSet<Integer> link = new LinkedHashSet<Integer>();
        link.add(123);
        link.add(44);
        link.add(33);
        link.add(33);
        link.add(66);
        link.add(11);
        System.out.println(link);
    }
}
```

#### TreeSet

排序

```java
package com.SetExercise;

import org.junit.Test;

import java.util.Comparator;
import java.util.TreeSet;

/**
 * @author wty
 * @date 2022/10/10 10:20
 */

public class TreeSetExercise {
    @Test
    @SuppressWarnings({"all"})
    public void getTreeSet() {
        // 当使用无参构造器创建TreeSet的时候是无序的
        TreeSet treeSet = new TreeSet();
        // 添加数据
        treeSet.add("Derrick");
        treeSet.add("Rose");
        treeSet.add("Jam");
        treeSet.add("Timmy");
        treeSet.add("Tom");

        System.out.println(treeSet);


        System.out.println("---字符串按照首字母顺序比较---");
        // 添加的元素按照字符串大小来排序
        // 可以传入一个比较器(匿名内部类)，并指定规则
        TreeSet treeSet1 = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o, Object t1) {
                return ((String) o).compareTo((String) t1);
            }
        });
        treeSet1.add("Derrick");
        treeSet1.add("Rose");
        treeSet1.add("Jam");
        treeSet1.add("Timmy");
        treeSet1.add("Tom");

        System.out.println(treeSet1);
        // 源码解读
        /**
         *     public TreeMap(Comparator<? super K> var1) {
         *         this.comparator = var1; 把new Comparator() 给到TreeMap的comparator属性
         *     }
         */

        System.out.println("---字符串长度大小比较---");
        TreeSet treeSet2 = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o, Object t1) {
                String str_a = (String) o;
                String str_t1 = (String) t1;
                int a = ((String) o).length();
                int b = ((String) t1).length();
                int result = a - b;
                return result = result == 0 ? str_a.compareTo(str_t1) : result;
            }
        });
        treeSet2.add("Derrick");
        treeSet2.add("Amy");
        treeSet2.add("Rose");
        treeSet2.add("Jam"); // 相同长度加不进去
        treeSet2.add("Timmy");
        treeSet2.add("Tom");// 相同长度加不进去


        System.out.println(treeSet2);


    }
}
```

### Queue

>  常用Queue

+ BlockingQueue：阻塞队列。适用场景：消费生产场景。
+ ConcurrentLinkedQueue：适用场景：比BlockingQueue的并发负载量更高的场景。 
+ BlockingDeque：双端队列。

## list 和 set 公用方法

####  **1. 添加元素：**

+ `add(E e):` 将指定的元素添加到Set集合中。如果元素已经存在，则不进行添加，返回false；否则添加成功，返回true。

#### 2. **删除元素：**

- `remove(Object o)`: 从Set集合中移除指定的元素。
- `clear()`: 清空Set集合中的所有元素。

#### 3. **判断元素是否存在：**

- `contains(Object o)`: 判断Set集合中是否包含指定的元素。
- `isEmpty()`: 判断 Set集合是否为空，即不包含任何元素。

#### 4. 获取集合大小：

- `size()`: 返回Set集合中的元素个数。

#### **5. 遍历集合：**

- 使用迭代器（Iterator）或增强型for循环来遍历Set集合中的元素。

- 注意：因为set集合没有下标，所以不可以使用普通for循环进行集合的遍历，但是可以使用增强for进行循环，如下图：

- ```java
  //set.for
  for (String s : set) {
      System.out.println(s);
  }
  ```

 

### Collections

排序操作（主要针对[List接口](https://so.csdn.net/so/search?q=List接口&spm=1001.2101.3001.7020)相关）

```java
reverse(List list)：反转指定List集合中元素的顺序
shuffle(List list)：对List中的元素进行随机排序（洗牌）
sort(List list)：对List里的元素根据自然升序排序
sort(List list, Comparator c)：自定义比较器进行排序
swap(List list, int i, int j)：将指定List集合中i处元素和j出元素进行交换
rotate(List list, int distance)：将所有元素向右移位指定长度，如果distance等于size那么结果不变
```

 查找，替换操作

```java
int binarySearch(List list, Object key), 对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll),根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)，根据定制排序，返回最大元素，排序规则由Comparatator类控制
类比int min(Collection coll, Comparator c)
void fill(List list, Object obj),用元素obj填充list中所有元素
int frequency(Collection c, Object o)，统计元素出现次数
int indexOfSubList(List list, List target), 统计targe在list中第一次出现的索引，找不到则返回-1，
类比int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素。
```

 同步控制

Collections工具类中提供了多个`synchronizedXxx`方法，该方法返回指定集合对象对应的同步对象，从而解决多线程并发访问集合时线程的安全问题。`HashSet`、`ArrayList`、`HashMap`都是线程不安全的，如果需要考虑同步，则使用这些方法。这些方法主要有：`synchronizedSet`、`synchronizedSortedSet`、`synchronizedList`、`synchronizedMap`、`synchronizedSortedMap`。
特别需要指出的是，在使用迭代方法遍历集合时需要手工同步返回的集合。

 设置不可变（只读）集合

Collections提供了三类方法返回一个不可变集合，

```java
emptyXXX(),返回一个空的只读集合（这不知用意何在？）
singleXXX()，返回一个只包含指定对象，只有一个元素，只读的集合。
unmodifiablleXXX()，返回指定集合对象的只读视图。
```

## Map

> 常用的HashMap、LinkedHashMap

+ HashMap(无序) 特点：key不能重复，值可以重复，而且key是无序的, 当key重复时，进行值的覆盖
+ LinkedHashMap(保持顺序）
+ TreeMap(排序)
+ HashTable(不允许null,多线程)
+ 考虑线程安全, 选择ConcurrentHashMap

### Map接口中的常用方法

+ put方法：将指定的键与值对应起来，并添加到集合中，方法返回值为键所对应的值
  + 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中
  + 使用put方法时，若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值

+ get方法：获取指定键(key)所对应的值(value)

+ remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)

```java
public class MapDemo {
    public static void main(String[] args) {
//创建Map对象
        Map<String, String> map = new HashMap<String,String>();
//给map中添加元素
        map.put("星期一", "Monday");
        map.put("星期日", "Sunday");
        System.out.println(map); // {星期日=Sunday, 星期一=Monday}
//当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null
        System.out.println(map.put("星期一", "Mon")); // Monday
        System.out.println(map); // {星期日=Sunday, 星期一=Mon}
//根据指定的key获取对应的value
        String en = map.get("星期日");
        System.out.println(en); // Sunday
//根据key删除元素,会返回key对应的value值
        String value = map.remove("星期日");
        System.out.println(value); // Sunday
        System.out.println(map); // {星期一=Mon}
    }
}
```

例子

```c++
class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> map = new HashMap<>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        
        int ans = 0;
        int n = s.length();
        for (int i = 0; i < n; ++i) {
            int value = map.get(s.charAt(i));
            if (i < n - 1 && value < map.get(s.charAt(i + 1))) {
                ans -= value;
            } else {
                ans += value;
            }
        }
        return ans;
    }
}

```

### TreeMap(排序)

```java
package com.Map;

import org.junit.Test;

import java.util.Comparator;
import java.util.TreeMap;

/**
 * @author wty
 * @date 2022/10/10 12:33
 */
public class TreeMapExercise {
    @Test
    public void getTreeMap() {
        // 无参数，无序取出
        TreeMap treeMap = new TreeMap();
        treeMap.put("1", "Jack");
        treeMap.put("no2", "Tom");
        treeMap.put("李小璐", "PGONE");
        treeMap.put("smith", "史密斯");

        System.out.println(treeMap);

        // 按照key字符串首字母倒叙排序
        TreeMap treeMap2 = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o2).compareTo((String) o1);
            }
        });
        System.out.println("按照key字符串首字母倒叙排序");
        treeMap2.put("1", "Jack");
        treeMap2.put("no2", "Tom");
        treeMap2.put("李小璐", "PGONE");
        treeMap2.put("smith", "史密斯");
        treeMap2.put("alice", "漫游记");
        System.out.println(treeMap2);

        // 按照key字符串长度排序，相同长度按首字母倒叙排序
        TreeMap treeMap3 = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                String str_o1 = (String) o1;
                String str_o2 = (String) o2;

                int a = str_o1.length();
                int b = str_o2.length();

                int result = a == b ? str_o1.compareTo(str_o2) : a - b;

                return result;
            }
        });
        System.out.println("按照key字符串长度排序，相同长度按首字母顺叙排序");
        treeMap3.put("1", "Jack");
        treeMap3.put("no2", "Tom");
        treeMap3.put("李小璐", "PGONE");
        treeMap3.put("smith", "史密斯");
        treeMap3.put("alice", "漫游记");
        treeMap3.put("tonny", "理发师");
        System.out.println(treeMap3);
    }
}
```

### 排序

```java
Map<String, Integer> map = new TreeMap<>();
// 填充map
Map<String, Integer> sortedMap = new LinkedHashMap<>();
map.entrySet().stream()
    .sorted(Map.Entry.comparingByKey())
    .forEachOrdered(x -> sortedMap.put(x.getKey(), x.getValue()));
根据值排序：

Map<String, Integer> map = new TreeMap<>();
// 填充map
Map<String, Integer> sortedMap = new LinkedHashMap<>();
map.entrySet().stream()
    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())) // 逆序
    .forEachOrdered(x -> sortedMap.put(x.getKey(), x.getValue()));
```



### Map遍历

(1) 如果只获取 key 或者 value, 推荐使用 `keySet()` 或 `values()` 方法;
(2) 如果需要同时获取 key 和value, 推荐使用 Lambda 或者 entrySet;
(3) 如果需要在遍历过程中删除元素, 推荐使用 Iterator;
(4) 如果需要在遍历过程中添加元素, 可以新建一个临时 Map 存放新增的元素, 遍历结束后, 再把临时 Map 添加到原 Map 中

#### 1 通过 keySet() 或 values() 方法遍历

如果只需要获取 Map 的 key 或者 value, 通过 Map 的 `keySet()` 或 `values()` 方法无疑是最方便的:

```java
public class TestMap {
    /**
     * Map 的扩容比较消耗性能, 因此若能确定存储数据的大小,
     * 在初始化时指定初始容量是一个不错的实践技巧
     */
    private static Map<Integer, Integer> map = new HashMap<>(16);

    /** keySet 获取 key */
    public void testKeySet() {
        for (Integer key : map.keySet()) {
          System.out.println(key);
        }
    }
    /** values 获取 value */
    public void testValues() {
        for (Integer value : map.values()) {
            System.out.println(value);
        }
    }
}
```

#### 2 通过 keySet 的 get(key) 获取值(不推荐使用)

如果需要同时获取 key 和 value, 可以通过先获取 key, 然后再通过 Map 的 `get(key)` 获取对应的 value.

```java
    /** keySet get(key) 获取key and value */
    public void testKeySetAndGetKey() {
        for (Integer key : map.keySet()) {
            System.out.println(key + ":" + map.get(key));
        }
    }
```

#### 3 通过 entrySet 遍历(推荐)

通过对 Map 的 entrySet 进行遍历, 也可以同时拿到 key 和 value.

**该方法是最常用的遍历 Map 的方法, 大多情况下, 其性能要优于第2种.**

```java
  /** 
    * entrySet 获取 key 和 value, Entry 是 Map 内部存储数据的逻辑容器
    */ 
  public void testEntry() {
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
      System.out.println(entry.getKey() + ":" + entry.getValue());
    }
  }
```

#### 4 通过迭代器 Iterator 遍历

`foreach` 的操作虽然看起来很简洁, 但有一个劣势: **遍历 Map 时, 如果改变其大小, 就会抛出并发修改异常**. 

但如果在遍历时只需要删除 Map 中的元素, 那就可以用 Iterator 的 `remove()` 方法删除元素:

```java
    /** Iterator 获取 key 和 value */
    public void testIterator() {
        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, Integer> entry = it.next();
            System.out.println(entry.getKey() + ":" + entry.getValue());
            // 删除元素
            // it.remove();
        }
    }
```

#### 5 通过 Lambda 表达式遍历

```java
    /** Lambda 获取key and value */
    public void testLambda() {
        map.forEach((key, value) -> {
            System.out.println(key + ":" + value);
        });
    }
```

# 注意事项

## 集合判空

**判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。**

## **集合转 Map**

**在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。**

```java
class Person {
    private String name;
    private String phoneNumber;
     // getters and setters
}

List<Person> bookList = new ArrayList<>();
bookList.add(new Person("jack","18163138123"));
bookList.add(new Person("martin",null));

// 防止空指针异常,使用java8方式
bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));
```

## **集合遍历**

**不要在 foreach 循环里直接进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。**

```java
List<Integer> list = new ArrayList<>();
for (int i = 1; i <= 10; ++i) {
    list.add(i);
}
list.removeIf(filter -> filter % 2 == 0); /* 删除list中的所有偶数 */
System.out.println(list); /* [1, 3, 5, 7, 9] */
```

## 集合去重

**可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains() 进行遍历去重或者判断包含操作。**

```java
// Set 去重代码示例 (推荐)
public static <T> Set<T> removeDuplicateBySet(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new HashSet<>();
    }
    return new HashSet<>(data);
}

// List 去重代码示例
public static <T> List<T> removeDuplicateByList(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new ArrayList<>();

    }
    List<T> result = new ArrayList<>(data.size());
    for (T current : data) {
        if (!result.contains(current)) {
            result.add(current);
        }
    }
    return result;
}
```

## 集合转数组

**使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。**

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};

List<String> list = Arrays.asList(s);
Collections.reverse(list);

//没有指定类型的话会报错
s = list.toArray(new String[0]);
```

## **数组转集合**

**使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。**

```java
String[] myArray = {"Apple", "Banana", "Orange"};
List<String> myList = Arrays.asList(myArray);
//上面两个语句等价于下面一条语句
List<String> myList = Arrays.asList("Apple","Banana", "Orange");

//
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

正确方式/最简便的方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"));
```

**使用 Java8 的 Stream(推荐)**

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList()); //流对象

//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```

**使用 Java9 的 List.of()方法**

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

### 相互转换

[java集合之间的相互转换——高效、完整_集合之间的转换-CSDN博客](https://blog.csdn.net/qq_36095679/article/details/98176723)

#### 1、数组 —》 List

> 将数组转换成集合,**数组必须是引用数据类型**，如果基本数据类型的数组转换成集合,会将整个数组当作一个对象转换 ；
>
> Arrays.asList()返回一个受指定数组支持的固定大小的列表。**所以不能做Add、Remove等操**

```java
private static void arrToList(){
        // 基本数据类型的数组转换成集合,会将整个数组当作一个对象转换
        // 输出：[[I@3830f1c0]
        int[] arr = {1, 2, 3, 4, 5};
        List<int[]> list = Arrays.asList(arr);
        System.out.println(list); 
 
        // 将数组转换成集合,数组必须是引用数据类型
        // 輸出：[1, 2, 3, 4, 5]
        Integer[] arr2 = {1, 2, 3, 4, 5};
        // Arrays.asList()返回一个受指定数组支持的固定大小的列表。所以不能做Add、Remove等操作。
        List<Integer> list2 = new ArrayList<>(Arrays.asList(arr2));
        list3.add(7);
        System.out.println(list2);
    }
```

总结:

```java
List list = new ArrayList<>(Arrays.asList(数组名));
```

#### 2、List —》 数组

```java
 private static void arrToList(){
        // 数组必须是引用数据类型
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            list.add("1-"+i);
        }
     
     	//核心
        String[] arr = new String[list.size()];
        list.toArray(arr);
        System.out.println(Arrays.toString(arr));
    }
```

#### 3、List —》 Set / Set —》 List

> **将 List 集合转为 Set 集合，是可以直接去重的。**

```java
 private static void listToSet(){
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            list.add("1-"+i);
        }
        // 直接new一个对象，将list放入即可
        Set<String> set = new HashSet<>(list);
        System.out.println(set.toString());
    }
```

> Set 集合转 List 集合类似，直接 new 一个 List 对象，将 set 集合放入即可

####  4、List -》 Map

> **如果我们的 List 存放的对象，我们想要将其转化为 Map 集合，key为对象的某个属性。**(使用Stream流实现)

实体类：

```java
/**
 * @author MouFangCai
 * @date 2019/8/2 10:41
 */
public class TestEntity {
    private Integer id;
    private String name;
 
    @Override
    public String toString() {
        return "TestEntity{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
 
    public Integer getId() {
        return id;
    }
 
    public void setId(Integer id) {
        this.id = id;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
}
```

#### 5、Map —》 List / Set

```java
 private static void mapToList(){
        Map<Integer, TestEntity> map = new HashMap<>();
        for (int i = 0; i < 4; i++) {
            TestEntity testEntity = new TestEntity();
            testEntity.setId(i);
            testEntity.setName("name-"+i);
            map.put(i, testEntity);
        }
        // 直接获取map的key的set集合
        Set<Integer> set1 = map.keySet();
        // 将map的values 转换为Set集合
        Set<TestEntity> set = new HashSet<>(map.values());
        // 将map的values 转换为List集合
        List<TestEntity> list = new ArrayList<>(map.values());
 
        System.out.println(set.toString());
        System.out.println(list.toString());
    }
```

#### 6、List —》 List / Set

> 需求：**List1 集合存放是对象**，我们希望直接从集合里获取到 **对象的某个属性的 List2 集合** **(使用Stream流实现)**

```java
 private static void listToList(){
        List<TestEntity> list = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            TestEntity testEntity = new TestEntity();
            testEntity.setId(i);
            testEntity.setName("name-"+i);
            list.add(testEntity);
        }
        // 获取到 name的list集合
        List<String> list1 = list.stream().map(TestEntity::getName).collect(Collectors.toList());
        // 获取到 name的set集合
        Set<String> set = list.stream().map(TestEntity::getName).collect(Collectors.toSet());
        System.out.println(list1.toString());
    }
```

## 迭代器 Iterator 接口

1、概述

- **Iterator : 迭代器**
- 对 collection 进行迭代的迭代器
- 依赖于集合而存在

2、[Iterator](https://so.csdn.net/so/search?q=Iterator&spm=1001.2101.3001.7020) 接口成员方法

- `boolean hasNext()`
- `E next()`

```java
package liebiao;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListDemo {
    public static void main(String[] args) {
        List l = new ArrayList();//创建集合对象
        l.add("苍井空");
        l.add("是");
        l.add("一个");
        l.add("漂亮的");
        l.add("女孩");

        System.out.println(l);
        System.out.println("---------------------");

        //遍历集合
        Iterator it = l.iterator();
        //System.out.println(it);
        while (it.hasNext()) {//使用hasNext()检查序列中是否还有元素。
            String s = (String) it.next();//使用next()获得序列中的下一个元素。
            System.out.println(s);
        }
    }
}
123456789101112131415161718192021222324252627
```

3、Iterator 接口的使用

案例：封装一个 Students 类

```java
package liebiao;

public class Students {
    private String name;
    private int age;

    public Students() {//无参构造函数
        super();
    }

    public Students(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    // 成员方法
    // getXxx()/setXxx()
    //Alt + Insert（idea 工具）
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

存储自定义对象，并遍历

```java
package liebiao;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListDemo {
    public static void main(String[] args) {
        List l = new ArrayList();//创建集合对象
        Students s1 = new Students("苍井空", 18);
        Students s2 = new Students("波多野结衣", 19);
        Students s3 = new Students("泷泽萝拉", 20);
        Students s4 = new Students("水菜丽", 21);

        l.add(s1);
        l.add(s2);
        l.add(s3);
        l.add(s4);

        //遍历集合
        Iterator it = l.iterator();
        while (it.hasNext()) {
            Students s = (Students) it.next();
            System.out.println("姓名：" + s.getName() + "----年龄：" + s.getAge());
        }
    }
}
123456789101112131415161718192021222324252627
```

4、Iterator 接口的原理

### 二、序列 List 接口

1、概述

- **List ：序列**
- List 接口是 Collection 的子类，也是抽象类
- List 接口可以对列表中的每一个元素的插入位置进行控制，可以根据元素的索引访问元素
- 与 Set 不同，List 列表允许有重复的元素

2、List 案例

- 存储字符串并遍历
- 存储自定义对象并遍历

3、List 接口的成员方法

- `void add(int index,E element)`
- `E remove(int index)`
- `E get(int index)`
- `E set(int index,E element)`
- `ListIterator listIterator()`

- 获取10个 1~30 之间的随机数，要求不能重复（用集合实现）

```java
package suijishu;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class RandomDemo {
    public static void main(String[] args) {
        Random r = new Random();//产生随机数
        List<Integer> l = new ArrayList<>();//泛型创建List 集合，List，有序可以重复的集合
        while (l.size() < 10) {
            Integer i = r.nextInt(30) + 1;
            if (!l.contains(i)) {
                l.add(i);
            }
        }
        for (Integer inte : l) {//增强for 循环，遍历集合
            System.out.println(inte);
        }
    }
}
```

### 三、ListIterator 接口

1、概述

- ListIterator 接口是 List 接口的子类

2、ListIterator 接口的成员方法

- `boolean hasPrevious()`
- `E previous()`
- `ConcurrentModificationException`（并行修改例外）

3、列表迭代器

```java
package liebiao;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

class ListDemo {
    public static void main(String[] args) {
        List l = new ArrayList();//创建List 集合对象

        l.add("hello");
        l.add("java");

        ListIterator it = l.listIterator();
        while (it.hasNext()) {
            String s = (String) it.next();
            System.out.println(s);
        }
        System.out.println("------------------------");

        System.out.println(it.previous());//获取上一个元素
        System.out.println("==========================");

        while (it.hasPrevious()) {//是否有上一个元素
            String s = (String) it.previous();
            System.out.println(s);
        }
    }
}
```

# Stream流 collect() 方法

```java
//1.
<R> R collect(Supplier<R> supplier,
                  BiConsumer<R, ? super T> accumulator,
                  BiConsumer<R, R> combiner);
//2.
<R, A> R collect(Collector<? super T, A, R> collector);
```

​    Stream 流的注意事项：**Stream不调用终止方法，中间的操作不会执行**。    

​    Stream 流提供了一个 **collect() 方法，**可以收集流中的数据到【**集合**】或者【**数组**】中去。

###  **1.收集 Stream 流中的数据到集合中**

```java
//1.收集数据到list集合中
stream.collect(Collectors.toList())
//2.收集数据到set集合中
stream.collect(Collectors.toSet())
//3.收集数据到指定的集合中
Collectors.toCollection(Supplier<C> collectionFactory)
stream.collect(Collectors.joining())
```

 **示例如下：** 

```java
/**
 * 收集Stream流中的数据到集合中
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 */
public class CollectDataToCollection{
 
    public static void main(String[] args) {
        //Stream 流
        Stream<String> stream = Stream.of("aaa", "bbb", "ccc", "bbb");
        //收集流中的数据到集合中
        //1.收集流中的数据到 list
        List<String> list = stream.collect(Collectors.toList());
        System.out.println(list);
 
        //2.收集流中的数据到 set
        Set<String> collect = stream.collect(Collectors.toSet());
        System.out.println(collect);
 
        //3.收集流中的数据(ArrayList)(不收集到list,set等集合中,而是)收集到指定的集合中
        ArrayList<String> arrayList = stream.collect(Collectors.toCollection(ArrayList::new));
        System.out.println(arrayList);
 
        //4.收集流中的数据到 HashSet
        HashSet<String> hashSet = stream.collect(Collectors.toCollection(HashSet::new));
        System.out.println(hashSet);
    }
}
```

 **测试结果：**

```java
[aaa, bbb, ccc, bbb]
[aaa, ccc, bbb]
[aaa, bbb, ccc, bbb]
[aaa, ccc, bbb]
```

###  **2.收集 Stream 流中的数据到数组中**

```java
//1.使用无参,收集到数组,返回值为 Object[](Object类型将不好操作)
Object[] toArray();
//2.使用有参,可以指定将数据收集到指定类型数组,方便后续对数组的操作
<A> A[] toArray(IntFunction<A[]> generator);
```

 **示例如下：** 

```java
/**
 * 收集Stream流中的数据到数组中
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        //Stream 流
        Stream<String> stream = Stream.of("aaa", "bbb", "ccc", "bbb");
         
        //2.1 使用 toArray()无参
        Object[] objects = stream.toArray();
        for (Object o: objects) {//此处无法使用.length() 等方法
            System.out.println("data:"+o);
        }
 
        //2.2 使用有参返回指定类型数组
        //无参不好的一点就是返回的是 Object[] 类型,操作比较麻烦.想要拿到长度，Object是拿不到长度的
        String[] strings = stream.toArray(String[]::new);
        for(String str : strings){
            System.out.println("data:"+str + ",length:"+str.length());
        }
    }
}
```

 **测试结果：**

```java
data:aaa
data:bbb
data:ccc
data:bbb
-----------------
data:aaa,length:3
data:bbb,length:3
data:ccc,length:3
data:bbb,length:3
```

### **3.Stream流中数据聚合/分组/分区/拼接操作**

​    除了 collect() 方法将数据收集到集合/数组中。对 Stream流 的收集还有其他的方法。比如说：聚合计算，分组，多级分组，分区，拼接等。

**附：Student实体类（接下来介绍，将根据Student类来进行聚合、分组、分区、拼接介绍）**

```java
/**
 * TODO Student实体类
 *
 * @author liuzebiao
 * @Date 2020-1-10 13:38
 */
public class Student {
 
    private String name;
 
    private int age;
 
    private int score;
 
    public Student(String name, int age, int score) {
        this.name = name;
        this.age = age;
        this.score = score;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public int getAge() {
        return age;
    }
 
    public void setAge(int age) {
        this.age = age;
    }
 
    public int getScore() {
        return score;
    }
 
    public void setScore(int score) {
        this.score = score;
    }
 
 
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", score=" + score +
                '}';
    }
}
```

#### 1.聚合操作

​    当我们使用 Stream 流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作。比如获取最大值，获取最小值，求总和，求平均值，统计数量等操作。

```java
//最大值
Collectors.maxBy();
//最小值
Collectors.minBy();
//总和
Collectors.summingInt();/Collectors.summingDouble();/Collectors.summingLong();
//平均值
Collectors.averagingInt();/Collectors.averagingDouble();/Collectors.averagingLong();
//总个数
Collectors.counting();
```

 **示例如下：** 

```java
/**
 * Stream流数据--聚合操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 58, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 99),
                new Student("柳岩", 52, 77)
        );
 
        //聚合操作
        //获取最大值(Stream流 max()方法亦可)
        //max()方法实现
        //Optional<Student> max = studentStream.max((s1, s2) -> s1.getScore() - s2.getScore());
        //(聚合)实现
        Optional<Student> max = studentStream.collect(Collectors.maxBy((s1, s2) -> s1.getScore() - s2.getScore()));
        System.out.println("最大值:"+max.get());
 
        //获取最小值(Stream流 min()方法亦可)
        //min()方法实现
        //Optional<Student> min = studentStream.max((s1, s2) -> s2.getScore() - s1.getScore());
        //(聚合)实现
        Optional<Student> min = studentStream.collect(Collectors.minBy((s1, s2) -> s1.getScore() - s2.getScore()));
        System.out.println("最小值:"+min.get());
 
        //求总和(使用Stream流的map()和reduce()方法亦可求和)
        //map()和reduce()方法实现
        //Integer reduce = studentStream.map(s -> s.getAge()).reduce(0, Integer::sum);
        //(聚合)简化前
        //Integer ageSum = studentStream.collect(Collectors.summingInt(s->s.getAge()));
        //(聚合)使用方法引用简化
        Integer ageSum = studentStream.collect(Collectors.summingInt(Student::getAge));
        System.out.println("年龄总和:"+ageSum);
 
        //求平均值
        //(聚合)简化前
        //Double avgScore = studentStream.collect(Collectors.averagingInt(s->s.getScore()));
        //(聚合)使用方法引用简化
        Double avgScore = studentStream.collect(Collectors.averagingInt(Student::getScore));
        System.out.println("分数平均值:"+avgScore);
 
        //统计数量(Stream流 count()方法亦可)
        //count()方法实现
        //long count = studentStream.count();
        //(聚合)统计数量
        Long count = studentStream.collect(Collectors.counting());
        System.out.println("数量为:"+count);
    }
}
```

 **测试结果：**

```java
最大值:Student{name='迪丽热巴', age=56, score=99}
最小值:Student{name='柳岩', age=52, score=77}
年龄总和:222
分数平均值:89.75
数量为:4
```

#### 2.分组操作

​    当我们使用 Stream 流处理数据后，可以根据某个属性来将数据进行分组。

```java
//接收一个 Function 参数
groupingBy(Function<? super T, ? extends K> classifier)
```

 **示例如下：** 

```java
/**
 * Stream流数据--分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 56),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 99),
                new Student("柳岩", 52, 53)
        );
        
        //1.按照具体年龄分组
        Map<Integer, List<Student>> map = studentStream.collect(Collectors.groupingBy((s -> s.getAge())));
        map.forEach((key,value)->{
            System.out.println(key + "---->"+value);
        });
 
        //2.按照分数>=60 分为"及格"一组  <60 分为"不及格"一组
        Map<String, List<Student>> map = studentStream.collect(Collectors.groupingBy(s -> {
            if (s.getScore() >= 60) {
                return "及格";
            } else {
                return "不及格";
            }
        }));
        map.forEach((key,value)->{
            System.out.println(key + "---->"+value.get());
        });
 
        //3.按照年龄分组,规约求每组的最大值最小值(规约：reducing)
        Map<Integer, Optional<Student>> reducingMap = studentStream.collect(
                Collectors.groupingBy(Student::getAge, 
                        Collectors.reducing(
                                BinaryOperator.maxBy(
                                        Comparator.comparingInt(Student::getScore)
                                )
                        )
                )
        );
        reducingMap .forEach((key,value)->{
            System.out.println(key + "---->"+value);
        });
    }
}
```

 **测试结果：**

```java
52---->[Student{name='赵丽颖', age=52, score=56}, Student{name='柳岩', age=52, score=53}]
56---->[Student{name='杨颖', age=56, score=88}, Student{name='迪丽热巴', age=56, score=99}]
-----------------------------------------------------------------------------------------------
不及格---->[Student{name='赵丽颖', age=52, score=56}, Student{name='柳岩', age=52, score=53}]
及格---->[Student{name='杨颖', age=56, score=88}, Student{name='迪丽热巴', age=56, score=99}]
-----------------------------------------------------------------------------------------------
52---->Student{name='赵丽颖', age=52, score=95}
56---->Student{name='杨颖', age=56, score=88}
```

#### 3.多级分组操作

​    当我们使用 Stream 流处理数据后，可以根据某个属性来将数据进行分组。

```java
//接收两个参数: 1.Function 参数  2.Collector多级分组
groupingBy(Function<? super T, ? extends K> classifier,Collector<? super T, A, D> downstream) 
```

 **示例如下：** 

```java
/**
 * Stream流数据--多级分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 55),
                new Student("柳岩", 52, 33)
        );
 
        //多级分组
        //1.先根据年龄分组,然后再根据成绩分组
        //分析:第一个Collectors.groupingBy() 使用的是(年龄+成绩)两个维度分组,所以使用两个参数 groupingBy()方法
        //    第二个Collectors.groupingBy() 就是用成绩分组,使用一个参数 groupingBy() 方法
        Map<Integer, Map<Integer, Map<String, List<Student>>>> map = studentStream.collect(Collectors.groupingBy(str -> str.getAge(), Collectors.groupingBy(str -> str.getScore(), Collectors.groupingBy((student) -> {
            if (student.getScore() >= 60) {
                return "及格";
            } else {
                return "不及格";
            }
        }))));
 
        map.forEach((key,value)->{
            System.out.println("年龄:" + key);
            value.forEach((k2,v2)->{
                System.out.println("\t" + v2);
            });
        });
    }
}
```

 **测试结果：**

```java
年龄:52
	{不及格=[Student{name='柳岩', age=52, score=33}]}
	{及格=[Student{name='赵丽颖', age=52, score=95}]}
年龄:56
	{不及格=[Student{name='迪丽热巴', age=56, score=55}]}
	{及格=[Student{name='杨颖', age=56, score=88}]}
```

#### 4.分区操作

前面学习了 Stream流中数据的分组操作，可以根据属性完成对数据的分组。接下来我们介绍分区操作，我们通过使用 **Collectors.partitioningBy()** ，根据返回值是否为 true，把集合分为两个列表，一个 true 列表，一个 false 列表。

![img](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6YjM0ODExMDE3NQ==,size_16,color_FFFFFF,t_70.png)

​    **分组和分区的区别就在：**分组可以有多个组。**分区只会有两个区( true 和 false)**

```java
//1.一个参数
partitioningBy(Predicate<? super T> predicate)
 
//2.两个参数(多级分区)
partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D> downstream)
```

 **示例如下：** 

```java
/**
 * Stream流数据--多级分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 55),
                new Student("柳岩", 52, 33)
        );
 
        //分区操作
        Map<Boolean, List<Student>> partitionMap = studentStream.collect(Collectors.partitioningBy(s -> s.getScore() > 60));
        
        partitionMap.forEach((key,value)->{
            System.out.println(key + "---->" + value);
        });
    }
}
```

 **测试结果：**

```java
false---->[Student{name='迪丽热巴', age=56, score=55}, Student{name='柳岩', age=52, score=33}]
true---->[Student{name='赵丽颖', age=52, score=95}, Student{name='杨颖', age=56, score=88}]
```

#### 5.拼接操作

​    **Collectors.joining()** 会根据指定的连接符，将所有元素连接成一个字符串。

```java
//无参数--等价于 joining("");
joining()
//一个参数
joining(CharSequence delimiter)
//三个参数(前缀+后缀)
joining(CharSequence delimiter, CharSequence prefix,CharSequence suffix)
```

 **示例如下：** 

```java
/**
 * Stream流数据--多级分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 55),
                new Student("柳岩", 52, 33)
        );
        
        //拼接操作
        //无参:join()
        String joinStr1 = studentStream.map(s -> s.getName()).collect(Collectors.joining());
        System.out.println(joinStr1);
        //一个参数:joining(CharSequence delimiter)
        String joinStr2 = studentStream.map(s -> s.getName()).collect(Collectors.joining(","));
        System.out.println(joinStr2);
        //三个参数:joining(CharSequence delimiter, CharSequence prefix,CharSequence suffix)
        String joinStr3 = studentStream.map(s -> s.getName()).collect(Collectors.joining("—","^_^",">_<"));
        System.out.println(joinStr3);
    }
}
```

 **测试结果：**

```cobol
赵丽颖杨颖迪丽热巴柳岩
赵丽颖,杨颖,迪丽热巴,柳岩
^_^赵丽颖—杨颖—迪丽热巴—柳岩>_<
```

# 核心代码:crossed_swords:

> 包括: 去重,排序,遍历,转换等

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * @Author: LFJ
 * @Date: 2023-11-16 15:43
 */

//一、本案例对象
class City {
	private  String name;
	private int  total;
	private int  num;

	public City(String name, int total) {
		this.name = name;
		this.total = total;

	}

	public City(String name, int total, int num) {
		this.name = name;
		this.total = total;
		this.num = num;
	}

	public String getCity() {
		return name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getTotal() {
		return total;
	}

	public void setTotal(int total) {
		this.total = total;
	}

	public int getNum() {
		return num;
	}

	public void setNum(int num) {
		this.num = num;
	}
}

//// 获取list中所有对象的某个属性
//      List<String> list= cities.stream().map(City::getCity).collect(Collectors.toList());
//		List<String> list= cities.stream().map(o->o.getCity()).collect(Collectors.toList());
//
// 分组
//		Map<String, List<City>> map =  cities.stream().collect(Collectors.groupingBy(City :: getCity));
//		Map<String, List<City>> map =  cities.stream().filter(v -> StringUtils.isNotEmpty(v.getCity())).collect(Collectors.groupingBy(City :: getCity));


//二、去重
class ListUtil {

//	public static List<String> list = Arrays.asList("1","2","2","3","3","4","4","5","6","7","8");
	public static List<String> list = new ArrayList<String>(Arrays.asList("1","2","2","3","3","4","4","5","6","7","8"));
	public static List<City> cities = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",22));
				add(new City("武汉",55));
				add(new City("上海",33));
				add(new City("北京",33));
				add(new City("深圳",43));
			}
		};
	}

	public static void main(String[] args) {
		System.out.println(ListUtil.distinctElements(list));
		System.out.println(ListUtil.getNoDuplicateElements(list));
		System.out.println(ListUtil.getDuplicateElements(list));
		System.out.println(ListUtil.getDuplicateElementsForObject(cities));
		System.out.println(ListUtil.getNoDuplicateElementsForObject(cities));
		System.out.println(ListUtil.getElementsAfterDuplicate(cities));
		System.out.println(ListUtil.getDuplicateObject(cities));
		System.out.println(ListUtil.getNoDuplicateObject(cities));
		System.out.println(ListUtil.distinctObject(cities));
	}

	/**-----------基础数据类型--------------*/
	// 方法1
	//去重后的集合 [1, 2, 3, 4, 5, 6, 7, 8]
	public static <T> List<T> distinctElements(List<T> list) {
		return list.stream().distinct().collect(Collectors.toList());
	}

	//方法2 lambda表达式  对象数据类型, 推荐使用这个
	//lambda表达式 去除集合所有重复的值  [1, 5, 6, 7, 8]
	public static <T> List<T> getNoDuplicateElements(List<T> list) {
		// 获得元素出现频率的 Map，键为元素，值为元素出现的次数  得到{1=1, 2=2, 3=2, 4=2, 5=1, 6=1, 7=1, 8=1}
		Map<T, Long> map = list.stream().collect(Collectors.groupingBy(p -> p,Collectors.counting()));  //  // xx -> xx 就表示直接用list中的数据, 这里就是 1 2 3...
		//
		System.out.println("getDuplicateElements2: "+map);
		return map.entrySet().stream() // Set<Entry>转换为Stream<Entry>  //map.entrySet()得到每个键值对
				.filter(entry -> entry.getValue() == 1) // 过滤出元素出现次数等于 1 的 entry //及只出现一次的
				.map(entry -> entry.getKey()) // 获得 entry 的键 //及重复元素）对应的 Stream
				.collect(Collectors.toList()); // 转化为 List
	}

	//lambda表达式 查找出重复的集合 [2, 3, 4]
	public static <T> List<T> getDuplicateElements(List<T> list) {
		return list.stream().collect(Collectors.collectingAndThen(Collectors
				.groupingBy(p -> p, Collectors.counting()), map->{
			map.values().removeIf(size -> size ==1); // >1 查找不重复的集合；== 1 查找重复的集合

			List<T> tempList = new ArrayList<>(map.keySet());
			return tempList;
		}));
	/*
	list.stream(): 将列表转换为流，以便进行流式操作。
	Collectors.groupingBy(p -> p, Collectors.counting()): 对元素进行分组并计数。

	Collectors.collectingAndThen(...): 这是一个收集器，它接受两个参数：第一个是主要的收集器（在这里是 groupingBy），第二个是转换函数，将主要收集器的结果进行最终的转换。

	map -> { ... }: 这是转换函数，接受 groupingBy 的结果，即 Map<T, Long>，其中键是元素，值是元素出现的次数。

	map.values().removeIf(size -> size == 1): 这一行代码移除了出现次数为1的元素。map.values() 返回了所有的计数，
											然后使用 removeIf 方法移除出现次数为1的元素。

	List<T> tempList = new ArrayList<>(map.keySet()): 最后，将修改后的键集合转换为一个新的列表。
	 */
	}

	// 方法3
	//利用set集合
	public static <T> Set<T> getDuplicateElements2(List<T> list) {
		Set<T> set = new HashSet<>();
		Set<T> exist = new HashSet<>();
		for (T s : list) {
			if (set.contains(s)) {
				exist.add(s);
			} else {
				set.add(s);
			}
		}
		return exist;
	}

	//利用LinkedHashSet集合  [1, 2, 3, 4, 5, 6, 7, 8]   保存顺序  //简单数据类型, 推荐使用这个
	public static <T> Set<T> getDuplicateElements3(List<T> list) {
		Set<T> exist = new LinkedHashSet<>(list);
		return exist;
	}

	/**
	 * -----------对象--------------
	 */

	//原属重复的 属性集合   [上海, 武汉]
	public static List<Object> getDuplicateElementsForObject(List<City> list) {
		Map<Object, Long> map = list.stream().collect(Collectors.groupingBy(p -> p.getCity(),Collectors.counting()));
		return map.entrySet().stream()
				.filter(entry -> entry.getValue() > 1) // >1 查找重复的集合；== 查找不重复的集合
				.map(entry -> entry.getKey())
				.collect(Collectors.toList());
	}

	//原属未重复的 属性集合   [深圳, 北京]
	public static List<String> getNoDuplicateElementsForObject(List<City> list){
		Map<String,List<City>> map = list.stream().collect(Collectors.groupingBy(City::getCity));
		return map.entrySet().stream().filter(entry -> entry.getValue().size() == 1)
				.map(entry -> entry.getKey()) // 获得 entry 的键（重复元素）对应的 Stream
				.collect(Collectors.toList()); // 转化为 List

	}

	//原属去重后的 属性集合(重复的保留一个) [上海, 武汉, 北京, 深圳]
	public static List<String> getElementsAfterDuplicate(List<City> list) {
		return list.stream().map(o->o.getCity()).distinct().collect(Collectors.toList());
	}

	//对象中某个原属重复的 对象集合
	// [[City(city=上海, total=11), City(city=上海, total=33)], [City(city=武汉, total=22), City(city=武汉, total=55)]]
	public static List<List<City>> getDuplicateObject(List<City> list) {
		return list.stream().collect(Collectors.groupingBy(City::getCity)).entrySet().stream()
				.filter(entry -> entry.getValue().size() > 1) // >1 查找重复的集合；== 查找不重复的集合
				.map(entry -> entry.getValue())
				.collect(Collectors.toList());
	}

	//对象中某个原属未重复 对象集合
	//[[City(city=深圳, total=43)], [City(city=北京, total=33)]]
	public static List<City> getNoDuplicateObject(List<City> list) {
		List<City> cities = new ArrayList<>();
		list.stream().collect(Collectors.groupingBy(City::getCity)).entrySet().stream()
				.filter(entry -> entry.getValue().size() ==1) //>1 查找重复的集合；== 查找不重复的集合;
				.map(entry -> entry.getValue())
				.forEach(p -> cities.addAll(p));
		return cities;
	}


	//根据对象的某个原属去重后的(重复的保留一个) 对象集合
	//[City(city=上海, total=11), City(city=武汉, total=22), City(city=北京, total=33), City(city=深圳, total=43)]
	public static List<City> distinctObject(List<City> list) {
		return list.stream().filter(distinctByKey(City::getCity)).collect(Collectors.toList());
	}

	public static <T> Predicate<T> distinctByKey(Function<? super T, Object> keyExtractor) {
		Map<Object, Boolean> seen = new ConcurrentHashMap<>();
		return object -> seen.putIfAbsent(keyExtractor.apply(object), Boolean.TRUE) == null;
	}
}

//三、排序
class ListUtil_sort {

	public static List<Integer> list = Arrays.asList(10,1,6,4,8,7,9,3,2,5);
	public static List<City> cities = null;
	public static List<City> cities2 = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",55));
				add(new City("南京",33));
				add(new City("深圳",33));
			}
		};

		cities2 = new ArrayList<City>(){
			{
				add(new City("上海",11,11));
				add(new City("武汉",55,22));
				add(new City("南京",33,55));
				add(new City("深圳",33,44));
			}
		};

	}
	public static void main(String[] args) {
		System.out.println(sort(list));
		System.out.println(reversed(list));
		System.out.println(sortForObject(cities));
		System.out.println(reversedForObject(cities));
		System.out.println(sortForObject2(cities2));
	}

	//list排序 升序
	public static <T> List<T> sort(List<T> list){
		return list.stream().sorted().collect(Collectors.toList());
	}

	//list排序 降序
	public static List<Integer> reversed(List<Integer> list){
		return list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());
	}

	//根据对象某个属性排序  正序
	public static List<City> sortForObject(List<City> list){
		return list.stream().sorted(Comparator.comparing(City::getTotal)).collect(Collectors.toList());
	}

	//根据对象某个属性排序  倒序
	public static List<City> reversedForObject(List<City> list){
		return list.stream().sorted(Comparator.comparing(City::getTotal).reversed()).collect(Collectors.toList());
	}

	//根据对象两个属性排序  正序
	public static List<City> sortForObject2(List<City> list){
		return list.stream().sorted(Comparator.comparing(City::getTotal).thenComparing(City::getNum)).collect(Collectors.toList());
	}
}

//四、过滤、求和、最值, 批量修改list<object>中的某一个属性
class ListUtil_sum {

	public static List<Integer> list = Arrays.asList(10,1,6,4,8,7,9,3,2,5);
	public static List<String> strList = Arrays.asList("10","1","6","4");
	public static List<City> cities = null;
	public static Map<String,Integer> cityMap = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",55));
				add(new City("武汉",45));
				add(new City("深圳",33));
			}
		};
		cityMap = new HashMap<>();
		cityMap.put("武汉",55);
		cityMap.put("上海",11);
	}
	public static void main(String[] args) {
		//System.out.println(calculation(list));
		//calculation2(cities);
		//joinStringValueByList(cities);
		//joinStringValueByList2(strList);
		System.out.println(filter(cities));
	}


	//基础数据类型求各自值
	///IntSummaryStatistics{count=4, sum=132, min=11, average=33.000000, max=55}
	public static IntSummaryStatistics calculation(List<Integer> list){
		IntSummaryStatistics stat = list.stream().collect(Collectors.summarizingInt(p -> p));
		System.out.println("max:"+stat.getMax());
		System.out.println("min:"+stat.getMin());
		System.out.println("sum:"+stat.getSum());
		System.out.println("count:"+stat.getCount());
		System.out.println("average:"+stat.getAverage());
		Integer max = list.stream().reduce(Integer::max).get();//得到最大值
		Integer min = list.stream().reduce(Integer::min).get();//得到最小值
		System.out.println("max:"+max+"；min:"+min);
		return stat;
	}

	//对象某个属性求各自值
	public static void calculation2(List<City> list){
		System.out.println("sum="+ list.stream().mapToInt(City::getTotal).sum());
		System.out.println("max="+ list.stream().mapToInt(City::getTotal).max().getAsInt());
		System.out.println("min="+ list.stream().mapToInt(City::getTotal).min().getAsInt());
		System.out.println("ave="+ list.stream().mapToInt(City::getTotal).average().getAsDouble());
	}

	// 批量修改list<object>中的某一个属性
	//对象某个属性 等于特定值的累加
	public static void calculation11(List<City> list){
		Map<String, IntSummaryStatistics> intSummaryStatistics = list.stream().
				collect(Collectors.groupingBy(i -> i.getCity(), Collectors.summarizingInt(City::getTotal)));
		System.out.println("-4-->" + intSummaryStatistics);
		System.out.println("-5-->" + intSummaryStatistics.get("武汉").getSum());
	}

	//功能描述 姓名以逗号拼接   上海,武汉,武汉,深圳
	public static String joinStringValueByList(List<City> list){
		return list.stream().map(City::getCity).collect(Collectors.joining(","));
	}

	//功能描述 姓名以逗号拼接  10,1,6,4
	public static String joinStringValueByList2(List<String> list){
		//方式一
		return String.join(",", list);
		//方式二
//		System.out.println(list.stream().collect(Collectors.joining(",")));
	}

	//功能描述 过滤
	public static List<City> filter(List<City> list){
		return list.stream().filter(a -> a.getTotal()>44).collect(Collectors.toList());  //过滤掉list中 对象.getTotal()>44的对象
	}

}

//五、List对象转换
class ObjectSwitch{
	public static List<City> cities = null;
	public static Map<String,Integer> cityMap = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",55));
				add(new City("武汉",45));
				add(new City("深圳",33));
			}
		};
		cityMap = new HashMap<>();
		cityMap.put("武汉",55);
		cityMap.put("上海",11);
	}

	public static void main(String[] args) {
		arr2list();
		listToMap(cities);
		mapToList(cityMap);
//		stringToList("上海、武汉");
	}

	// 功能描述 数组转集合
	public static void arr2list() {
		// 默认 List<Integer> list = new ArrayList<>() 只能声明, 不能同时初始化
		int [] arr = {1,2,3,4,5,6,7,8};
		// 方法1
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			list.add(arr[i]);
		}
		System.out.println(list);

		// 方法2
		List list2 = new ArrayList<>(Arrays.asList(1,2,3,4,5,6,7,8));  //asList()中必须是具体的值
		System.out.println(list2);

		// 方法3
		//基本类型
		List list3 =  Arrays.stream(arr).boxed().collect(Collectors.toList());

		// Integer
		Integer [] myArray = { 1, 2, 3 };
		List myList = Arrays.stream(myArray).collect(Collectors.toList());
		System.out.println(list3);
	}

	//功能描述 List转map
	public static void listToMap(List<City> list) {
		//用 (k1,k2)->k1 来设置，如果有重复的key,则保留key1,舍弃key2
		Map<String, City> map = list.stream().collect(Collectors.toMap(City::getCity, city -> city, (k1, k2) -> k1));
		map.forEach((k, v) -> System.out.println("k=" + k + ",v=" + v));
		/*
		list.stream(): 将输入的列表转换为流，以便进行流式操作。
		Collectors.toMap(City::getCity, city -> city, (k1, k2) -> k1):
			使用toMap收集器，将流中的对象转换为Map。这个收集器接受三个参数：
				City::getCity: 这是键的提取器，使用每个City对象的getCity()方法作为键。
				city -> city: 这是值的提取器，直接将每个City对象作为值。  // xx -> xx 就表示直接用list中的数据, 这里就是 City对象
				(k1, k2) -> k1: 可选参数, 这是一个合并函数，当遇到具有相同键的元素时，它定义了如何合并这些元素。在这里，它简单地选择保留第一个出现的元素。
		最终结果是一个Map<String, City>，其中键是城市名，而值是具有相应城市名的City对象。
		如果列表中有重复的城市名，合并函数确保只有第一个出现的对象被保留在最终的Map中。
		* */
		/*
		k=上海,v=City@723279cf
		k=武汉,v=City@10f87f48
		k=深圳,v=City@b4c966a
		*/

		//
		Map<String, String> map2 = list.stream().collect(Collectors.toMap(City::getCity, City::getName, (k1, k2) -> k1));
		map2.forEach((k,v)->System.out.println("k="+k+",v="+v));
		/*
		k=上海,v=上海
		k=武汉,v=武汉
		k=深圳,v=深圳
		*/
		//
		//转换成map的时候，可能出现key一样的情况，如果不指定一个覆盖规则，上面的代码是会报错的。转成map的时候，最好使用下面的方式
		Map<Integer, City> map3 = list.stream().collect(Collectors.toMap(City::getTotal, Function.identity(), (k1,k2)->k1));
		map3.forEach((k, v) -> System.out.println("k=" + k + ", v=" + v));
		/*
		k=33, v=City@b4c966a
		k=55, v=City@10f87f48
		k=11, v=City@723279cf
		k=45, v=City@5b6f7412
		*/

	}

	//功能描述 map转list
	public static void mapToList(Map<String,Integer> map){
		List<City> list = map.entrySet().stream().map(entry -> new City(entry.getKey(),entry.getValue())).collect(Collectors.toList());
		/*
		 * map.entrySet().stream(): 这一部分首先将map的键值对转换为一个Stream<Entry>，其中每个Entry表示map中的一对键值。
		 * .map(entry -> new City(entry.getKey(), entry.getValue())): 使用map操作将每个Entry映射为一个新的City对象。这里假设 City 类有一个接受两个参数的构造函数，分别是城市名和城市对象。
		 * .collect(Collectors.toList()): 最后，使用collect操作将流中的元素收集到一个列表中。这个列表包含了通过映射操作创建的所有City对象。
		 * 最终结果是一个City对象的列表
		 */
		map.keySet().stream().collect(Collectors.toList());  // 把map的每一个key转成list
		map.values().stream().collect(Collectors.toList());  // 把map的每一个value转成list

		System.out.println(list);  //[City@30dae81, City@1b2c6ec2]
		list.forEach(bean -> System.out.println(bean.getCity() + "," + bean.getTotal()));
		/*
		上海,11
		武汉,55
		* */
	}

	//功能描述 字符串转list
	public static void stringToList(String str){
		//不需要处理
		//<String> list = Arrays.asList(str.split(","));
		//需要处理
		List<String> list = Arrays.asList(str.split(",")).stream().map(string -> String.valueOf(string)).collect(Collectors.toList());
		list.forEach(string -> System.out.println(string));
	}
}

//六、遍历
class each_Test{
	// 遍历Collection集合
	public static <T> void eachCollection(){
		ArrayList<String> list = new ArrayList<String>();
		list.add("Hello");
		list.add("Java");
		list.add("World");
		list.add("笔记");

		// 高级for遍历
		for (String value : list) {
			System.out.println(value);
		}

		// 使用for循环遍历List
		for (int i = 0; i < list.size(); i++){
			String s = (String) list.get(i);
			System.out.println(s);
		}

	}

	// 遍历map集合
	public static void eachMap(){
		Map<String, Integer> cityMap = new HashMap<>();
		cityMap.put("武汉",55);
		cityMap.put("上海",11);

		//方法1
		cityMap.forEach((k, v) -> System.out.println("key:value = " + k + ":" + v));

		//方法2
		//获取Map中的所有key与value的对应关系
		Set<Map.Entry<String,Integer>> entrySet = cityMap.entrySet();
		//遍历Set集合
		Iterator<Map.Entry<String,Integer>> it =entrySet.iterator();
		while(it.hasNext()){
			//得到每一对对应关系
			Map.Entry<String,Integer> entry = it.next();
			//通过每一对对应关系获取对应的key
			String key = entry.getKey();
			//通过每一对对应关系获取对应的value
			Integer value = entry.getValue();
			System.out.println(key+"="+value);
		}

		//方法3
		Set<String> keySet = cityMap.keySet();  //获取Map中的所有key
		//遍历存放所有key的Set集合
		Iterator<String> it2 =keySet.iterator();
		while(it2.hasNext()){
			//得到每一个key
			String key = it2.next();
			//通过key获取对应的value
			Integer value = cityMap.get(key);
			System.out.println(key+"="+value);
		}
	}

	public static void main(String[] args) {
		eachCollection();
		eachMap();
	}
}

public class List_Test {
	public static void main(String[] args) {

	}
}
```



**组合成列表**

```java
List<ArticleTag> reqTagList = tagIds.stream().map((tagId) ->
    new ArticleTag(articleId, tagId)).collect(Collectors.toList());
```



# 常用 

```java
//		查询结果中排除与给定 id 相同的元素，并返回一个过滤后的 ArticleVo 对象列表
		List<ArticleVo> resultList = this.baseMapper
				.selectArticleVoPage(articlePageQueryWrapper).stream()
				.filter(a -> !id.equals(a.getId())).collect(Collectors.toList());
```



// 

```java
// 请求的文章标签列表 tagIds 将 tagIds 列表中的每个元素与给定的 articleId 组合成一个新的 ArticleTag 对象，并将这些对象收集到一个列表中。
          int articleId = 100;
		List<ArticleTag> reqTagList = tagIds.stream().map((tagId) ->
				new ArticleTag(articleId, tagId)).collect(Collectors.toList());
```

```java
List<ArticleTag> reqTagList = new ArrayList<>();
for (Long tagId : tagIds) {
    ArticleTag articleTag = new ArticleTag(articleId, tagId);
    reqTagList.add(articleTag);
}

```





[2418. 按身高排序](https://leetcode.cn/problems/sort-the-people/)

给你一个字符串数组 `names` ，和一个由 **互不相同** 的正整数组成的数组 `heights` 。两个数组的长度均为 `n` 。

对于每个下标 `i`，`names[i]` 和 `heights[i]` 表示第 `i` 个人的名字和身高。

请按身高 **降序** 顺序返回对应的名字数组 `names` 。

 

**示例 1：**

```
输入：names = ["Mary","John","Emma"], heights = [180,165,170]
输出：["Mary","Emma","John"]
解释：Mary 最高，接着是 Emma 和 John 。
```

**示例 2：**

```
输入：names = ["Alice","Bob","Bob"], heights = [155,185,150]
输出：["Bob","Alice","Bob"]
解释：第一个 Bob 最高，然后是 Alice 和第二个 Bob 。
```

```java
class Solution {
  public String[] sortPeople(String[] names, int[] heights) {
    return Stream.iterate(0, i -> i + 1)
        .limit(names.length)
        .sorted(Comparator.<Integer>comparingInt(i -> heights[i]).reversed())
        .map(i -> names[i])
        .toArray(String[]::new);
  }
}
```

