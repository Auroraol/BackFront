# 概述

Java集合常用的只有List，Map，Set，Queue。其中以List和Map最为常用。

# JAVA 集合框架

![img](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/1626705129923-24a40f64-2e72-4642-97de-82c9985a1422.gif)

# **Collection/Map**

## Collection

![image.png](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/1675944306163-614400c9-97eb-4f5d-8a9d-9b8a0e56ca94.png)

## Map

![image.png](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/1675944878649-6fedcfdc-40fd-441f-b4b8-4455a6b4873a.png)

# 常用集合

集合的选用主要考虑的就是：

+ 读写性能（取决于底层数据结构。线程安全集合还需额外考虑锁的性能），场景是否要求线程安全，场景是否要求有序。

常用集合的特点：

（1）线程不安全（因为最多的场景，集合都是使用在线程内部的，不涉及线程安全问题，即[栈封闭](https://www.yuque.com/bianyuan-yjrbs/cag5ka/ckb1zxg81p12qqbo)）

（2）底层数据结构的性能高

![image-20231116133730192](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/image-20231116133730192.png)

## List

> 常用的ArrayList, LinkedList

+ 1)改查的操作多，尾部增删，选择ArrayList  

+ 2)**随机位置**增删的操作多，选择LinkedList.  

+ 3)考虑线程安全，选择Vector(弃用),  CopyOnWriteArrayList，或者synchronizedList

### 创建与初始化

```java
// 使用ArrayList类创建List对象。ArrayList是基于数组实现的可变列表。可以根据需要进行动态添加、删除和修改元素。
List<String> list1 = new ArrayList<>();  // 只能先声明
 
// 使用LinkedList类创建List对象。LinkedList是基于链表实现的可变列表。与ArrayList相比，LinkedList在插入和删除元素时更高效，但在访问和查找元素时相对较慢。
List<String> list2 = new LinkedList<>();  // 只能先声明
 
// 创建不可变List对象。Arrays.asList() 方法将传递的元素转换为列表对象，并返回一个不可变的List。在这种列表中，无法添加或删除元素，也无法修改已有元素的值。
List<String> list3 = Arrays.asList("a", "b", "c");  //可以初始化  //中必须是具体的值
 
// 使用Collections类创建只读List对象，防止对列表进行任何修改操作。
List<String> list4 = Collections.unmodifiableList(Arrays.asList("a", "b", "c"));
```

### 常用方法

#### 增加元素

- **add(Object e)：**向集合末尾处，添加指定的元素
- **addAll()方法：**将指定集合中的所有元素添加到List的末尾
- **ListIterator的add()方法：**将指定元素插入到ListIterator当前位置
- **add(int index, Object e):** 向集合指定索引处，添加指定的元素，原有元素依次后移

```java
/*
* add(int index, E)
* 将元素插入到列表的指定索引上
* 带有索引的操作,防止越界问题
* java.lang.IndexOutOfBoundsException
* ArrayIndexOutOfBoundsException
* StringIndexOutOfBoundsException
*/
public static void function(){
        List<String> list = new ArrayList<String>();
        list.add("abc1");
        list.add("abc2");
        list.add("abc3");
        list.add("abc4");
        System.out.println(list);

        list.add(1,"itcast");
        System.out.println(list);
}
```

```java
 List<String> list1 = new ArrayList<String>();
// 使用add()方法添加元素
list1.add("a");
list1.add("b");
 
// 使用addAll()方法添加元素 
List<String> subList = Arrays.asList("c", "d"); //不可变 List 视图 //数组
list1.addAll(subList);
 
// 使用ListIterator的add()方法添加元素
ListIterator<String>  List<String> list = new ArrayList<String>(); listIterator = list1.listIterator();
while (listIterator.hasNext()) {
    String s = listIterator.next();
    if (s.equals("b")) {
        listIterator.add("e");
    }
}
```

#### 删除元素

- **remove(Object e)**：将指定元素对象，从集合中删除，返回值为被删除的元素
- **remove(int index)**：将指定索引处的元素，从集合中删除，返回值为被删除的元素
- **removeAll()方法：**删除List中包含在指定集合中的所有元素
- **retainAll()方法：**仅保留List中包含在指定集合中的元素
- **ListIterator的remove()方法**：删除ListIterator上一次调用next()或previous()方法返回的元素

```java
/*
* E remove(int index)
* 移除指定索引上的元素
* 返回被删除之前的元素
*/
public static void function_1(){
        List<Double> list = new ArrayList<Double>();
        list.add(1.1);
        list.add(1.2);
        list.add(1.3);
        list.add(1.4);

        Double d = list.remove(0);
        System.out.println(d);
        System.out.println(list);
}
```

```java
// 使用remove()方法删除元素
list1.remove("a");
 
// 使用removeAll()方法删除元素
List<String> subList = Arrays.asList("b", "c");
list1.removeAll(subList);
 
// 使用retainAll()方法删除元素
List<String> subList2 = Arrays.asList("d", "e");
list1.retainAll(subList2);
 
// 使用ListIterator的remove()方法删除元素
ListIterator<String> listIterator = list1.listIterator();
while (listIterator.hasNext()) {
    String s = listIterator.next();
    if (s.equals("d")) {
        listIterator.remove();
    }
}
```

#### 替换元素

+ set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素

```java
/*
* E set(int index, E)
* 修改指定索引上的元素
* 返回被修改之前的元素
*/
public static void function_2(){
        List<Integer> list = new ArrayList<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);

        Integer i = list.set(0, 5);
        System.out.println(i);
        System.out.println(list);
}
```

#### 获取元素

+ get(int index)：获取指定索引处的元素，并返回该元素
+ indexOf():  查找元素索引

```java
// 使用get()方法获取元素
String s = list1.get(0);
 
// 使用indexOf()方法查找元素
int index = list1.indexOf("a");
```

#### LinkedList特有方法:获取,添加,删除

```java
/*
* LinkedList 链表集合的特有功能
* 自身特点: 链表底层实现,查询慢,增删快
* 
* 子类的特有功能,不能多态调用
*/
public class LinkedListDemo {
    public static void main(String[] args) {
        function_3();
    }
    /*
    * E removeFirst() 移除并返回链表的开头
    * E removeLast() 移除并返回链表的结尾
    */
    public static void function_3(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");

        String first = link.removeFirst();
        String last = link.removeLast();
        System.out.println(first);
        System.out.println(last);

        System.out.println(link);
    }

    /*
    * E getFirst() 获取链表的开头
    * E getLast() 获取链表的结尾
    */
    public static void function_2(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");

        if(!link.isEmpty()){
            String first = link.getFirst();
            String last = link.getLast();
            System.out.println(first);
            System.out.println(last);
        }
    }

    public static void function_1(){
        LinkedList<String> link = new LinkedList<String>();
        link.addLast("a");
        link.addLast("b");
        link.addLast("c");
        link.addLast("d");

        link.addFirst("1");
        link.addFirst("2");
        link.addFirst("3");
        System.out.println(link);
    }

    /*
    * addFirst(E) 添加到链表的开头
    * addLast(E) 添加到链表的结尾
    */
    public static void function(){
        LinkedList<String> link = new LinkedList<String>();

        link.addLast("heima");

        link.add("abc");
        link.add("bcd");

        link.addFirst("itcast");
        System.out.println(link);
    }
}
```

## Map

> 常用的HashMap、LinkedHashMap

+ HashMap(无序)
+ LinkedHashMap(保持顺序）
+ TreeMap(排序)
+ HashTable(不允许null,多线程)
+ 考虑线程安全, 选择ConcurrentHashMap

### Map接口中的常用方法

+ put方法：将指定的键与值对应起来，并添加到集合中，方法返回值为键所对应的值
  + 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中
  + 使用put方法时，若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值

+ get方法：获取指定键(key)所对应的值(value)

+ remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)

```java
public class MapDemo {
    public static void main(String[] args) {
//创建Map对象
        Map<String, String> map = new HashMap<String,String>();
//给map中添加元素
        map.put("星期一", "Monday");
        map.put("星期日", "Sunday");
        System.out.println(map); // {星期日=Sunday, 星期一=Monday}
//当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null
        System.out.println(map.put("星期一", "Mon")); // Monday
        System.out.println(map); // {星期日=Sunday, 星期一=Mon}
//根据指定的key获取对应的value
        String en = map.get("星期日");
        System.out.println(en); // Sunday
//根据key删除元素,会返回key对应的value值
        String value = map.remove("星期日");
        System.out.println(value); // Sunday
        System.out.println(map); // {星期一=Mon}
    }
}
```

例子

```c++
class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> map = new HashMap<>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        
        int ans = 0;
        int n = s.length();
        for (int i = 0; i < n; ++i) {
            int value = map.get(s.charAt(i));
            if (i < n - 1 && value < map.get(s.charAt(i + 1))) {
                ans -= value;
            } else {
                ans += value;
            }
        }
        return ans;
    }
}

```

### TreeMap(排序)

```java
package com.Map;

import org.junit.Test;

import java.util.Comparator;
import java.util.TreeMap;

/**
 * @author wty
 * @date 2022/10/10 12:33
 */
public class TreeMapExercise {
    @Test
    public void getTreeMap() {
        // 无参数，无序取出
        TreeMap treeMap = new TreeMap();
        treeMap.put("1", "Jack");
        treeMap.put("no2", "Tom");
        treeMap.put("李小璐", "PGONE");
        treeMap.put("smith", "史密斯");

        System.out.println(treeMap);

        // 按照key字符串首字母倒叙排序
        TreeMap treeMap2 = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o2).compareTo((String) o1);
            }
        });
        System.out.println("按照key字符串首字母倒叙排序");
        treeMap2.put("1", "Jack");
        treeMap2.put("no2", "Tom");
        treeMap2.put("李小璐", "PGONE");
        treeMap2.put("smith", "史密斯");
        treeMap2.put("alice", "漫游记");
        System.out.println(treeMap2);

        // 按照key字符串长度排序，相同长度按首字母倒叙排序
        TreeMap treeMap3 = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                String str_o1 = (String) o1;
                String str_o2 = (String) o2;

                int a = str_o1.length();
                int b = str_o2.length();

                int result = a == b ? str_o1.compareTo(str_o2) : a - b;

                return result;
            }
        });
        System.out.println("按照key字符串长度排序，相同长度按首字母顺叙排序");
        treeMap3.put("1", "Jack");
        treeMap3.put("no2", "Tom");
        treeMap3.put("李小璐", "PGONE");
        treeMap3.put("smith", "史密斯");
        treeMap3.put("alice", "漫游记");
        treeMap3.put("tonny", "理发师");
        System.out.println(treeMap3);
    }
}
```

## **Set**

>常用的HashSet

+ HashSet(无序)
+ LinkedHashSet(保持顺序)
+ TreeSet(排序)

### HashSet

无序

```java
public static void main(String[] args) {
    HashSet<String> set = new HashSet<String>();
    set.add(new String("abc"));
    set.add(new String("abc"));
    set.add(new String("bbc"));
    set.add(new String("bbc"));
    System.out.println(set);
}
```

### LinkedHashSet

保持顺序

```java
public class LinkedHashSetDemo {
    public static void main(String[] args) {
        LinkedHashSet<Integer> link = new LinkedHashSet<Integer>();
        link.add(123);
        link.add(44);
        link.add(33);
        link.add(33);
        link.add(66);
        link.add(11);
        System.out.println(link);
    }
}
```

### TreeSet

排序

```java
package com.SetExercise;

import org.junit.Test;

import java.util.Comparator;
import java.util.TreeSet;

/**
 * @author wty
 * @date 2022/10/10 10:20
 */

public class TreeSetExercise {
    @Test
    @SuppressWarnings({"all"})
    public void getTreeSet() {
        // 当使用无参构造器创建TreeSet的时候是无序的
        TreeSet treeSet = new TreeSet();
        // 添加数据
        treeSet.add("Derrick");
        treeSet.add("Rose");
        treeSet.add("Jam");
        treeSet.add("Timmy");
        treeSet.add("Tom");

        System.out.println(treeSet);


        System.out.println("---字符串按照首字母顺序比较---");
        // 添加的元素按照字符串大小来排序
        // 可以传入一个比较器(匿名内部类)，并指定规则
        TreeSet treeSet1 = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o, Object t1) {
                return ((String) o).compareTo((String) t1);
            }
        });
        treeSet1.add("Derrick");
        treeSet1.add("Rose");
        treeSet1.add("Jam");
        treeSet1.add("Timmy");
        treeSet1.add("Tom");

        System.out.println(treeSet1);
        // 源码解读
        /**
         *     public TreeMap(Comparator<? super K> var1) {
         *         this.comparator = var1; 把new Comparator() 给到TreeMap的comparator属性
         *     }
         */

        System.out.println("---字符串长度大小比较---");
        TreeSet treeSet2 = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o, Object t1) {
                String str_a = (String) o;
                String str_t1 = (String) t1;
                int a = ((String) o).length();
                int b = ((String) t1).length();
                int result = a - b;
                return result = result == 0 ? str_a.compareTo(str_t1) : result;
            }
        });
        treeSet2.add("Derrick");
        treeSet2.add("Amy");
        treeSet2.add("Rose");
        treeSet2.add("Jam"); // 相同长度加不进去
        treeSet2.add("Timmy");
        treeSet2.add("Tom");// 相同长度加不进去


        System.out.println(treeSet2);


    }
}
```

## Queue

>  常用Queue

+ BlockingQueue：阻塞队列。适用场景：消费生产场景。
+  ConcurrentLinkedQueue：适用场景：比BlockingQueue的并发负载量更高的场景。 
+ BlockingDeque：双端队列。

# 注意事项

## 集合判空

**判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。**

## **集合转 Map**

**在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。**

```java
class Person {
    private String name;
    private String phoneNumber;
     // getters and setters
}

List<Person> bookList = new ArrayList<>();
bookList.add(new Person("jack","18163138123"));
bookList.add(new Person("martin",null));
// 空指针异常
bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));
```

## **集合遍历**

**不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。**

```java
List<Integer> list = new ArrayList<>();
for (int i = 1; i <= 10; ++i) {
    list.add(i);
}
list.removeIf(filter -> filter % 2 == 0); /* 删除list中的所有偶数 */
System.out.println(list); /* [1, 3, 5, 7, 9] */
```

## 集合去重

**可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains() 进行遍历去重或者判断包含操作。**

```java
// Set 去重代码示例 (推荐)
public static <T> Set<T> removeDuplicateBySet(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new HashSet<>();
    }
    return new HashSet<>(data);
}

// List 去重代码示例
public static <T> List<T> removeDuplicateByList(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new ArrayList<>();

    }
    List<T> result = new ArrayList<>(data.size());
    for (T current : data) {
        if (!result.contains(current)) {
            result.add(current);
        }
    }
    return result;
}
```

## 集合转数组

**使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。**

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};

List<String> list = Arrays.asList(s);
Collections.reverse(list);
//没有指定类型的话会报错
s=list.toArray(new String[0]);
```

## **数组转集合**

**使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。**

```java
String[] myArray = {"Apple", "Banana", "Orange"};
List<String> myList = Arrays.asList(myArray);
//上面两个语句等价于下面一条语句
List<String> myList = Arrays.asList("Apple","Banana", "Orange");

//
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

正确方式

最简便的方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"));
```

使用 Java8 的 Stream(推荐)

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());

//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```

使用 Java9 的 List.of()方法

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```







# Stream流 collect() 方法

```java
//1.
<R> R collect(Supplier<R> supplier,
                  BiConsumer<R, ? super T> accumulator,
                  BiConsumer<R, R> combiner);
//2.
<R, A> R collect(Collector<? super T, A, R> collector);
```

​    Stream 流的注意事项：**Stream不调用终止方法，中间的操作不会执行**。    

​    Stream 流提供了一个 **collect() 方法，**可以收集流中的数据到【**集合**】或者【**数组**】中去。

###  **1.收集 Stream 流中的数据到集合中**

```java
//1.收集数据到list集合中
stream.collect(Collectors.toList())
//2.收集数据到set集合中
stream.collect(Collectors.toSet())
//3.收集数据到指定的集合中
Collectors.toCollection(Supplier<C> collectionFactory)
stream.collect(Collectors.joining())
```

 **示例如下：** 

```java
/**
 * 收集Stream流中的数据到集合中
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 */
public class CollectDataToCollection{
 
    public static void main(String[] args) {
        //Stream 流
        Stream<String> stream = Stream.of("aaa", "bbb", "ccc", "bbb");
        //收集流中的数据到集合中
        //1.收集流中的数据到 list
        List<String> list = stream.collect(Collectors.toList());
        System.out.println(list);
 
        //2.收集流中的数据到 set
        Set<String> collect = stream.collect(Collectors.toSet());
        System.out.println(collect);
 
        //3.收集流中的数据(ArrayList)(不收集到list,set等集合中,而是)收集到指定的集合中
        ArrayList<String> arrayList = stream.collect(Collectors.toCollection(ArrayList::new));
        System.out.println(arrayList);
 
        //4.收集流中的数据到 HashSet
        HashSet<String> hashSet = stream.collect(Collectors.toCollection(HashSet::new));
        System.out.println(hashSet);
    }
}
```

 **测试结果：**

```java
[aaa, bbb, ccc, bbb]
[aaa, ccc, bbb]
[aaa, bbb, ccc, bbb]
[aaa, ccc, bbb]
```

###  **2.收集 Stream 流中的数据到数组中**

```java
//1.使用无参,收集到数组,返回值为 Object[](Object类型将不好操作)
Object[] toArray();
//2.使用有参,可以指定将数据收集到指定类型数组,方便后续对数组的操作
<A> A[] toArray(IntFunction<A[]> generator);
```

 **示例如下：** 

```java
/**
 * 收集Stream流中的数据到数组中
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        //Stream 流
        Stream<String> stream = Stream.of("aaa", "bbb", "ccc", "bbb");
         
        //2.1 使用 toArray()无参
        Object[] objects = stream.toArray();
        for (Object o: objects) {//此处无法使用.length() 等方法
            System.out.println("data:"+o);
        }
 
        //2.2 使用有参返回指定类型数组
        //无参不好的一点就是返回的是 Object[] 类型,操作比较麻烦.想要拿到长度，Object是拿不到长度的
        String[] strings = stream.toArray(String[]::new);
        for(String str : strings){
            System.out.println("data:"+str + ",length:"+str.length());
        }
    }
}
```

 **测试结果：**

```java
data:aaa
data:bbb
data:ccc
data:bbb
-----------------
data:aaa,length:3
data:bbb,length:3
data:ccc,length:3
data:bbb,length:3
```

### **3.Stream流中数据聚合/分组/分区/拼接操作**

​    除了 collect() 方法将数据收集到集合/数组中。对 Stream流 的收集还有其他的方法。比如说：聚合计算，分组，多级分组，分区，拼接等。

**附：Student实体类（接下来介绍，将根据Student类来进行聚合、分组、分区、拼接介绍）**

```java
/**
 * TODO Student实体类
 *
 * @author liuzebiao
 * @Date 2020-1-10 13:38
 */
public class Student {
 
    private String name;
 
    private int age;
 
    private int score;
 
    public Student(String name, int age, int score) {
        this.name = name;
        this.age = age;
        this.score = score;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public int getAge() {
        return age;
    }
 
    public void setAge(int age) {
        this.age = age;
    }
 
    public int getScore() {
        return score;
    }
 
    public void setScore(int score) {
        this.score = score;
    }
 
 
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", score=" + score +
                '}';
    }
}
```

#### 1.聚合操作

​    当我们使用 Stream 流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作。比如获取最大值，获取最小值，求总和，求平均值，统计数量等操作。

```java
//最大值
Collectors.maxBy();
//最小值
Collectors.minBy();
//总和
Collectors.summingInt();/Collectors.summingDouble();/Collectors.summingLong();
//平均值
Collectors.averagingInt();/Collectors.averagingDouble();/Collectors.averagingLong();
//总个数
Collectors.counting();
```

 **示例如下：** 

```java
/**
 * Stream流数据--聚合操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 58, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 99),
                new Student("柳岩", 52, 77)
        );
 
        //聚合操作
        //获取最大值(Stream流 max()方法亦可)
        //max()方法实现
        //Optional<Student> max = studentStream.max((s1, s2) -> s1.getScore() - s2.getScore());
        //(聚合)实现
        Optional<Student> max = studentStream.collect(Collectors.maxBy((s1, s2) -> s1.getScore() - s2.getScore()));
        System.out.println("最大值:"+max.get());
 
        //获取最小值(Stream流 min()方法亦可)
        //min()方法实现
        //Optional<Student> min = studentStream.max((s1, s2) -> s2.getScore() - s1.getScore());
        //(聚合)实现
        Optional<Student> min = studentStream.collect(Collectors.minBy((s1, s2) -> s1.getScore() - s2.getScore()));
        System.out.println("最小值:"+min.get());
 
        //求总和(使用Stream流的map()和reduce()方法亦可求和)
        //map()和reduce()方法实现
        //Integer reduce = studentStream.map(s -> s.getAge()).reduce(0, Integer::sum);
        //(聚合)简化前
        //Integer ageSum = studentStream.collect(Collectors.summingInt(s->s.getAge()));
        //(聚合)使用方法引用简化
        Integer ageSum = studentStream.collect(Collectors.summingInt(Student::getAge));
        System.out.println("年龄总和:"+ageSum);
 
        //求平均值
        //(聚合)简化前
        //Double avgScore = studentStream.collect(Collectors.averagingInt(s->s.getScore()));
        //(聚合)使用方法引用简化
        Double avgScore = studentStream.collect(Collectors.averagingInt(Student::getScore));
        System.out.println("分数平均值:"+avgScore);
 
        //统计数量(Stream流 count()方法亦可)
        //count()方法实现
        //long count = studentStream.count();
        //(聚合)统计数量
        Long count = studentStream.collect(Collectors.counting());
        System.out.println("数量为:"+count);
    }
}
```

 **测试结果：**

```java
最大值:Student{name='迪丽热巴', age=56, score=99}
最小值:Student{name='柳岩', age=52, score=77}
年龄总和:222
分数平均值:89.75
数量为:4
```

#### 2.分组操作

​    当我们使用 Stream 流处理数据后，可以根据某个属性来将数据进行分组。

```java
//接收一个 Function 参数
groupingBy(Function<? super T, ? extends K> classifier)
```

 **示例如下：** 

```java
/**
 * Stream流数据--分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 56),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 99),
                new Student("柳岩", 52, 53)
        );
        
        //1.按照具体年龄分组
        Map<Integer, List<Student>> map = studentStream.collect(Collectors.groupingBy((s -> s.getAge())));
        map.forEach((key,value)->{
            System.out.println(key + "---->"+value);
        });
 
        //2.按照分数>=60 分为"及格"一组  <60 分为"不及格"一组
        Map<String, List<Student>> map = studentStream.collect(Collectors.groupingBy(s -> {
            if (s.getScore() >= 60) {
                return "及格";
            } else {
                return "不及格";
            }
        }));
        map.forEach((key,value)->{
            System.out.println(key + "---->"+value.get());
        });
 
        //3.按照年龄分组,规约求每组的最大值最小值(规约：reducing)
        Map<Integer, Optional<Student>> reducingMap = studentStream.collect(
                Collectors.groupingBy(Student::getAge, 
                        Collectors.reducing(
                                BinaryOperator.maxBy(
                                        Comparator.comparingInt(Student::getScore)
                                )
                        )
                )
        );
        reducingMap .forEach((key,value)->{
            System.out.println(key + "---->"+value);
        });
    }
}
```

 **测试结果：**

```java
52---->[Student{name='赵丽颖', age=52, score=56}, Student{name='柳岩', age=52, score=53}]
56---->[Student{name='杨颖', age=56, score=88}, Student{name='迪丽热巴', age=56, score=99}]
-----------------------------------------------------------------------------------------------
不及格---->[Student{name='赵丽颖', age=52, score=56}, Student{name='柳岩', age=52, score=53}]
及格---->[Student{name='杨颖', age=56, score=88}, Student{name='迪丽热巴', age=56, score=99}]
-----------------------------------------------------------------------------------------------
52---->Student{name='赵丽颖', age=52, score=95}
56---->Student{name='杨颖', age=56, score=88}
```

#### 3.多级分组操作

​    当我们使用 Stream 流处理数据后，可以根据某个属性来将数据进行分组。

```java
//接收两个参数: 1.Function 参数  2.Collector多级分组
groupingBy(Function<? super T, ? extends K> classifier,Collector<? super T, A, D> downstream) 
```

 **示例如下：** 

```java
/**
 * Stream流数据--多级分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 55),
                new Student("柳岩", 52, 33)
        );
 
        //多级分组
        //1.先根据年龄分组,然后再根据成绩分组
        //分析:第一个Collectors.groupingBy() 使用的是(年龄+成绩)两个维度分组,所以使用两个参数 groupingBy()方法
        //    第二个Collectors.groupingBy() 就是用成绩分组,使用一个参数 groupingBy() 方法
        Map<Integer, Map<Integer, Map<String, List<Student>>>> map = studentStream.collect(Collectors.groupingBy(str -> str.getAge(), Collectors.groupingBy(str -> str.getScore(), Collectors.groupingBy((student) -> {
            if (student.getScore() >= 60) {
                return "及格";
            } else {
                return "不及格";
            }
        }))));
 
        map.forEach((key,value)->{
            System.out.println("年龄:" + key);
            value.forEach((k2,v2)->{
                System.out.println("\t" + v2);
            });
        });
    }
}
```

 **测试结果：**

```java
年龄:52
	{不及格=[Student{name='柳岩', age=52, score=33}]}
	{及格=[Student{name='赵丽颖', age=52, score=95}]}
年龄:56
	{不及格=[Student{name='迪丽热巴', age=56, score=55}]}
	{及格=[Student{name='杨颖', age=56, score=88}]}
```

#### 4.分区操作

​    我们在前面学习了 Stream流中数据的分组操作，我们可以根据属性完成对数据的分组。接下来我们介绍分区操作，我们通过使用 **Collectors.partitioningBy()** ，根据返回值是否为 true，把集合分为两个列表，一个 true 列表，一个 false 列表。

![img](%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6YjM0ODExMDE3NQ==,size_16,color_FFFFFF,t_70.png)

​    **分组和分区的区别就在：**分组可以有多个组。分区只会有两个区( true 和 false)

```java
//1.一个参数
partitioningBy(Predicate<? super T> predicate)
 
//2.两个参数(多级分区)
partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D> downstream)
```

 **示例如下：** 

```java
/**
 * Stream流数据--多级分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 55),
                new Student("柳岩", 52, 33)
        );
 
        //分区操作
        Map<Boolean, List<Student>> partitionMap = studentStream.collect(Collectors.partitioningBy(s -> s.getScore() > 60));
        partitionMap.forEach((key,value)->{
            System.out.println(key + "---->" + value);
        });
    }
}
```

 **测试结果：**

```java
false---->[Student{name='迪丽热巴', age=56, score=55}, Student{name='柳岩', age=52, score=33}]
true---->[Student{name='赵丽颖', age=52, score=95}, Student{name='杨颖', age=56, score=88}]
```

#### 5.拼接操作

​    **Collectors.joining()** 会根据指定的连接符，将所有元素连接成一个字符串。

```java
//无参数--等价于 joining("");
joining()
//一个参数
joining(CharSequence delimiter)
//三个参数(前缀+后缀)
joining(CharSequence delimiter, CharSequence prefix,CharSequence suffix)
```

 **示例如下：** 

```java
/**
 * Stream流数据--多级分组操作
 * 备注：切记Stream流只能被消费一次,流就失效了
 * 如下只是示例代码
 * @author liuzebiao
 * @Date 2020-1-10 13:37
 */
public class CollectDataToArray{
 
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("赵丽颖", 52, 95),
                new Student("杨颖", 56, 88),
                new Student("迪丽热巴", 56, 55),
                new Student("柳岩", 52, 33)
        );
        
        //拼接操作
        //无参:join()
        String joinStr1 = studentStream.map(s -> s.getName()).collect(Collectors.joining());
        System.out.println(joinStr1);
        //一个参数:joining(CharSequence delimiter)
        String joinStr2 = studentStream.map(s -> s.getName()).collect(Collectors.joining(","));
        System.out.println(joinStr2);
        //三个参数:joining(CharSequence delimiter, CharSequence prefix,CharSequence suffix)
        String joinStr3 = studentStream.map(s -> s.getName()).collect(Collectors.joining("—","^_^",">_<"));
        System.out.println(joinStr3);
    }
}
```

 **测试结果：**

```cobol
赵丽颖杨颖迪丽热巴柳岩
赵丽颖,杨颖,迪丽热巴,柳岩
^_^赵丽颖—杨颖—迪丽热巴—柳岩>_<
```

# 核心代码:crossed_swords:

> 包括: 去重,排序,遍历,转换等

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * @Author: LFJ
 * @Date: 2023-11-16 15:43
 */

//一、本案例对象
class City {
	private  String name;
	private int  total;
	private int  num;

	public City(String name, int total) {
		this.name = name;
		this.total = total;

	}

	public City(String name, int total, int num) {
		this.name = name;
		this.total = total;
		this.num = num;
	}

	public String getCity() {
		return name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getTotal() {
		return total;
	}

	public void setTotal(int total) {
		this.total = total;
	}

	public int getNum() {
		return num;
	}

	public void setNum(int num) {
		this.num = num;
	}
}

//// 获取list中所有对象的某个属性
//      List<String> list= cities.stream().map(City::getCity).collect(Collectors.toList());
//		List<String> list= cities.stream().map(o->o.getCity()).collect(Collectors.toList());
//
// 分组
//		Map<String, List<City>> map =  cities.stream().collect(Collectors.groupingBy(City :: getCity));
//		Map<String, List<City>> map =  cities.stream().filter(v -> StringUtils.isNotEmpty(v.getCity())).collect(Collectors.groupingBy(City :: getCity));


//二、去重
class ListUtil {

//	public static List<String> list = Arrays.asList("1","2","2","3","3","4","4","5","6","7","8");
	public static List<String> list = new ArrayList<String>(Arrays.asList("1","2","2","3","3","4","4","5","6","7","8"));
	public static List<City> cities = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",22));
				add(new City("武汉",55));
				add(new City("上海",33));
				add(new City("北京",33));
				add(new City("深圳",43));
			}
		};
	}

	public static void main(String[] args) {
		System.out.println(ListUtil.distinctElements(list));
		System.out.println(ListUtil.getNoDuplicateElements(list));
		System.out.println(ListUtil.getDuplicateElements(list));
		System.out.println(ListUtil.getDuplicateElementsForObject(cities));
		System.out.println(ListUtil.getNoDuplicateElementsForObject(cities));
		System.out.println(ListUtil.getElementsAfterDuplicate(cities));
		System.out.println(ListUtil.getDuplicateObject(cities));
		System.out.println(ListUtil.getNoDuplicateObject(cities));
		System.out.println(ListUtil.distinctObject(cities));
	}

	/**-----------基础数据类型--------------*/
	// 方法1
	//去重后的集合 [1, 2, 3, 4, 5, 6, 7, 8]
	public static <T> List<T> distinctElements(List<T> list) {
		return list.stream().distinct().collect(Collectors.toList());
	}

	//方法2 lambda表达式  对象数据类型, 推荐使用这个
	//lambda表达式 去除集合所有重复的值  [1, 5, 6, 7, 8]
	public static <T> List<T> getNoDuplicateElements(List<T> list) {
		// 获得元素出现频率的 Map，键为元素，值为元素出现的次数  得到{1=1, 2=2, 3=2, 4=2, 5=1, 6=1, 7=1, 8=1}
		Map<T, Long> map = list.stream().collect(Collectors.groupingBy(p -> p,Collectors.counting()));  //  // xx -> xx 就表示直接用list中的数据, 这里就是 1 2 3...
		//
		System.out.println("getDuplicateElements2: "+map);
		return map.entrySet().stream() // Set<Entry>转换为Stream<Entry>  //map.entrySet()得到每个键值对
				.filter(entry -> entry.getValue() == 1) // 过滤出元素出现次数等于 1 的 entry //及只出现一次的
				.map(entry -> entry.getKey()) // 获得 entry 的键 //及重复元素）对应的 Stream
				.collect(Collectors.toList()); // 转化为 List
	}

	//lambda表达式 查找出重复的集合 [2, 3, 4]
	public static <T> List<T> getDuplicateElements(List<T> list) {
		return list.stream().collect(Collectors.collectingAndThen(Collectors
				.groupingBy(p -> p, Collectors.counting()), map->{
			map.values().removeIf(size -> size ==1); // >1 查找不重复的集合；== 1 查找重复的集合

			List<T> tempList = new ArrayList<>(map.keySet());
			return tempList;
		}));
	/*
	list.stream(): 将列表转换为流，以便进行流式操作。
	Collectors.groupingBy(p -> p, Collectors.counting()): 对元素进行分组并计数。

	Collectors.collectingAndThen(...): 这是一个收集器，它接受两个参数：第一个是主要的收集器（在这里是 groupingBy），第二个是转换函数，将主要收集器的结果进行最终的转换。

	map -> { ... }: 这是转换函数，接受 groupingBy 的结果，即 Map<T, Long>，其中键是元素，值是元素出现的次数。

	map.values().removeIf(size -> size == 1): 这一行代码移除了出现次数为1的元素。map.values() 返回了所有的计数，
											然后使用 removeIf 方法移除出现次数为1的元素。

	List<T> tempList = new ArrayList<>(map.keySet()): 最后，将修改后的键集合转换为一个新的列表。
	 */
	}

	// 方法3
	//利用set集合
	public static <T> Set<T> getDuplicateElements2(List<T> list) {
		Set<T> set = new HashSet<>();
		Set<T> exist = new HashSet<>();
		for (T s : list) {
			if (set.contains(s)) {
				exist.add(s);
			} else {
				set.add(s);
			}
		}
		return exist;
	}

	//利用LinkedHashSet集合  [1, 2, 3, 4, 5, 6, 7, 8]   保存顺序  //简单数据类型, 推荐使用这个
	public static <T> Set<T> getDuplicateElements3(List<T> list) {
		Set<T> exist = new LinkedHashSet<>(list);
		return exist;
	}

	/**
	 * -----------对象--------------
	 */

	//原属重复的 属性集合   [上海, 武汉]
	public static List<Object> getDuplicateElementsForObject(List<City> list) {
		Map<Object, Long> map = list.stream().collect(Collectors.groupingBy(p -> p.getCity(),Collectors.counting()));
		return map.entrySet().stream()
				.filter(entry -> entry.getValue() > 1) // >1 查找重复的集合；== 查找不重复的集合
				.map(entry -> entry.getKey())
				.collect(Collectors.toList());
	}

	//原属未重复的 属性集合   [深圳, 北京]
	public static List<String> getNoDuplicateElementsForObject(List<City> list){
		Map<String,List<City>> map = list.stream().collect(Collectors.groupingBy(City::getCity));
		return map.entrySet().stream().filter(entry -> entry.getValue().size() == 1)
				.map(entry -> entry.getKey()) // 获得 entry 的键（重复元素）对应的 Stream
				.collect(Collectors.toList()); // 转化为 List

	}

	//原属去重后的 属性集合(重复的保留一个) [上海, 武汉, 北京, 深圳]
	public static List<String> getElementsAfterDuplicate(List<City> list) {
		return list.stream().map(o->o.getCity()).distinct().collect(Collectors.toList());
	}

	//对象中某个原属重复的 对象集合
	// [[City(city=上海, total=11), City(city=上海, total=33)], [City(city=武汉, total=22), City(city=武汉, total=55)]]
	public static List<List<City>> getDuplicateObject(List<City> list) {
		return list.stream().collect(Collectors.groupingBy(City::getCity)).entrySet().stream()
				.filter(entry -> entry.getValue().size() > 1) // >1 查找重复的集合；== 查找不重复的集合
				.map(entry -> entry.getValue())
				.collect(Collectors.toList());
	}

	//对象中某个原属未重复 对象集合
	//[[City(city=深圳, total=43)], [City(city=北京, total=33)]]
	public static List<City> getNoDuplicateObject(List<City> list) {
		List<City> cities = new ArrayList<>();
		list.stream().collect(Collectors.groupingBy(City::getCity)).entrySet().stream()
				.filter(entry -> entry.getValue().size() ==1) //>1 查找重复的集合；== 查找不重复的集合;
				.map(entry -> entry.getValue())
				.forEach(p -> cities.addAll(p));
		return cities;
	}


	//根据对象的某个原属去重后的(重复的保留一个) 对象集合
	//[City(city=上海, total=11), City(city=武汉, total=22), City(city=北京, total=33), City(city=深圳, total=43)]
	public static List<City> distinctObject(List<City> list) {
		return list.stream().filter(distinctByKey(City::getCity)).collect(Collectors.toList());
	}

	public static <T> Predicate<T> distinctByKey(Function<? super T, Object> keyExtractor) {
		Map<Object, Boolean> seen = new ConcurrentHashMap<>();
		return object -> seen.putIfAbsent(keyExtractor.apply(object), Boolean.TRUE) == null;
	}
}

//三、排序
class ListUtil_sort {

	public static List<Integer> list = Arrays.asList(10,1,6,4,8,7,9,3,2,5);
	public static List<City> cities = null;
	public static List<City> cities2 = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",55));
				add(new City("南京",33));
				add(new City("深圳",33));
			}
		};

		cities2 = new ArrayList<City>(){
			{
				add(new City("上海",11,11));
				add(new City("武汉",55,22));
				add(new City("南京",33,55));
				add(new City("深圳",33,44));
			}
		};

	}
	public static void main(String[] args) {
		System.out.println(sort(list));
		System.out.println(reversed(list));
		System.out.println(sortForObject(cities));
		System.out.println(reversedForObject(cities));
		System.out.println(sortForObject2(cities2));
	}

	//list排序 升序
	public static <T> List<T> sort(List<T> list){
		return list.stream().sorted().collect(Collectors.toList());
	}

	//list排序 降序
	public static List<Integer> reversed(List<Integer> list){
		return list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());
	}

	//根据对象某个属性排序  正序
	public static List<City> sortForObject(List<City> list){
		return list.stream().sorted(Comparator.comparing(City::getTotal)).collect(Collectors.toList());
	}

	//根据对象某个属性排序  倒序
	public static List<City> reversedForObject(List<City> list){
		return list.stream().sorted(Comparator.comparing(City::getTotal).reversed()).collect(Collectors.toList());
	}

	//根据对象两个属性排序  正序
	public static List<City> sortForObject2(List<City> list){
		return list.stream().sorted(Comparator.comparing(City::getTotal).thenComparing(City::getNum)).collect(Collectors.toList());
	}
}

//四、过滤、求和、最值, 批量修改list<object>中的某一个属性
class ListUtil_sum {

	public static List<Integer> list = Arrays.asList(10,1,6,4,8,7,9,3,2,5);
	public static List<String> strList = Arrays.asList("10","1","6","4");
	public static List<City> cities = null;
	public static Map<String,Integer> cityMap = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",55));
				add(new City("武汉",45));
				add(new City("深圳",33));
			}
		};
		cityMap = new HashMap<>();
		cityMap.put("武汉",55);
		cityMap.put("上海",11);
	}
	public static void main(String[] args) {
		//System.out.println(calculation(list));
		//calculation2(cities);
		//joinStringValueByList(cities);
		//joinStringValueByList2(strList);
		System.out.println(filter(cities));
	}


	//基础数据类型求各自值
	///IntSummaryStatistics{count=4, sum=132, min=11, average=33.000000, max=55}
	public static IntSummaryStatistics calculation(List<Integer> list){
		IntSummaryStatistics stat = list.stream().collect(Collectors.summarizingInt(p -> p));
		System.out.println("max:"+stat.getMax());
		System.out.println("min:"+stat.getMin());
		System.out.println("sum:"+stat.getSum());
		System.out.println("count:"+stat.getCount());
		System.out.println("average:"+stat.getAverage());
		Integer max = list.stream().reduce(Integer::max).get();//得到最大值
		Integer min = list.stream().reduce(Integer::min).get();//得到最小值
		System.out.println("max:"+max+"；min:"+min);
		return stat;
	}

	//对象某个属性求各自值
	public static void calculation2(List<City> list){
		System.out.println("sum="+ list.stream().mapToInt(City::getTotal).sum());
		System.out.println("max="+ list.stream().mapToInt(City::getTotal).max().getAsInt());
		System.out.println("min="+ list.stream().mapToInt(City::getTotal).min().getAsInt());
		System.out.println("ave="+ list.stream().mapToInt(City::getTotal).average().getAsDouble());
	}

	// 批量修改list<object>中的某一个属性
	//对象某个属性 等于特定值的累加
	public static void calculation11(List<City> list){
		Map<String, IntSummaryStatistics> intSummaryStatistics = list.stream().
				collect(Collectors.groupingBy(i -> i.getCity(), Collectors.summarizingInt(City::getTotal)));
		System.out.println("-4-->" + intSummaryStatistics);
		System.out.println("-5-->" + intSummaryStatistics.get("武汉").getSum());
	}

	//功能描述 姓名以逗号拼接   上海,武汉,武汉,深圳
	public static String joinStringValueByList(List<City> list){
		return list.stream().map(City::getCity).collect(Collectors.joining(","));
	}

	//功能描述 姓名以逗号拼接  10,1,6,4
	public static String joinStringValueByList2(List<String> list){
		//方式一
		return String.join(",", list);
		//方式二
//		System.out.println(list.stream().collect(Collectors.joining(",")));
	}

	//功能描述 过滤
	public static List<City> filter(List<City> list){
		return list.stream().filter(a -> a.getTotal()>44).collect(Collectors.toList());  //过滤掉list中 对象.getTotal()>44的对象
	}

}

//五、List对象转换
class ObjectSwitch{
	public static List<City> cities = null;
	public static Map<String,Integer> cityMap = null;
	static {
		cities = new ArrayList<City>(){
			{
				add(new City("上海",11));
				add(new City("武汉",55));
				add(new City("武汉",45));
				add(new City("深圳",33));
			}
		};
		cityMap = new HashMap<>();
		cityMap.put("武汉",55);
		cityMap.put("上海",11);
	}

	public static void main(String[] args) {
		arr2list();
		listToMap(cities);
		mapToList(cityMap);
//		stringToList("上海、武汉");
	}

	// 功能描述 数组转集合
	public static void arr2list() {
		// 默认 List<Integer> list = new ArrayList<>() 只能声明, 不能同时初始化
		int [] arr = {1,2,3,4,5,6,7,8};
		// 方法1
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			list.add(arr[i]);
		}
		System.out.println(list);

		// 方法2
		List list2 = new ArrayList<>(Arrays.asList(1,2,3,4,5,6,7,8));  //asList()中必须是具体的值
		System.out.println(list2);

		// 方法3
		//基本类型
		List list3 =  Arrays.stream(arr).boxed().collect(Collectors.toList());

		// Integer
		Integer [] myArray = { 1, 2, 3 };
		List myList = Arrays.stream(myArray).collect(Collectors.toList());
		System.out.println(list3);
	}

	//功能描述 List转map
	public static void listToMap(List<City> list) {
		//用 (k1,k2)->k1 来设置，如果有重复的key,则保留key1,舍弃key2
		Map<String, City> map = list.stream().collect(Collectors.toMap(City::getCity, city -> city, (k1, k2) -> k1));
		map.forEach((k, v) -> System.out.println("k=" + k + ",v=" + v));
		/*
		list.stream(): 将输入的列表转换为流，以便进行流式操作。
		Collectors.toMap(City::getCity, city -> city, (k1, k2) -> k1):
			使用toMap收集器，将流中的对象转换为Map。这个收集器接受三个参数：
				City::getCity: 这是键的提取器，使用每个City对象的getCity()方法作为键。
				city -> city: 这是值的提取器，直接将每个City对象作为值。  // xx -> xx 就表示直接用list中的数据, 这里就是 City对象
				(k1, k2) -> k1: 可选参数, 这是一个合并函数，当遇到具有相同键的元素时，它定义了如何合并这些元素。在这里，它简单地选择保留第一个出现的元素。
		最终结果是一个Map<String, City>，其中键是城市名，而值是具有相应城市名的City对象。
		如果列表中有重复的城市名，合并函数确保只有第一个出现的对象被保留在最终的Map中。
		* */
		/*
		k=上海,v=City@723279cf
		k=武汉,v=City@10f87f48
		k=深圳,v=City@b4c966a
		*/

		//
		Map<String, String> map2 = list.stream().collect(Collectors.toMap(City::getCity, City::getName, (k1, k2) -> k1));
		map2.forEach((k,v)->System.out.println("k="+k+",v="+v));
		/*
		k=上海,v=上海
		k=武汉,v=武汉
		k=深圳,v=深圳
		*/
		//
		//转换成map的时候，可能出现key一样的情况，如果不指定一个覆盖规则，上面的代码是会报错的。转成map的时候，最好使用下面的方式
		Map<Integer, City> map3 = list.stream().collect(Collectors.toMap(City::getTotal, Function.identity(), (k1,k2)->k1));
		map3.forEach((k, v) -> System.out.println("k=" + k + ", v=" + v));
		/*
		k=33, v=City@b4c966a
		k=55, v=City@10f87f48
		k=11, v=City@723279cf
		k=45, v=City@5b6f7412
		*/

	}

	//功能描述 map转list
	public static void mapToList(Map<String,Integer> map){
		List<City> list = map.entrySet().stream().map(entry -> new City(entry.getKey(),entry.getValue())).collect(Collectors.toList());
		/*
		 * map.entrySet().stream(): 这一部分首先将map的键值对转换为一个Stream<Entry>，其中每个Entry表示map中的一对键值。
		 * .map(entry -> new City(entry.getKey(), entry.getValue())): 使用map操作将每个Entry映射为一个新的City对象。这里假设 City 类有一个接受两个参数的构造函数，分别是城市名和城市对象。
		 * .collect(Collectors.toList()): 最后，使用collect操作将流中的元素收集到一个列表中。这个列表包含了通过映射操作创建的所有City对象。
		 * 最终结果是一个City对象的列表
		 */
		map.keySet().stream().collect(Collectors.toList());  // 把map的每一个key转成list
		map.values().stream().collect(Collectors.toList());  // 把map的每一个value转成list

		System.out.println(list);  //[City@30dae81, City@1b2c6ec2]
		list.forEach(bean -> System.out.println(bean.getCity() + "," + bean.getTotal()));
		/*
		上海,11
		武汉,55
		* */
	}

	//功能描述 字符串转list
	public static void stringToList(String str){
		//不需要处理
		//<String> list = Arrays.asList(str.split(","));
		//需要处理
		List<String> list = Arrays.asList(str.split(",")).stream().map(string -> String.valueOf(string)).collect(Collectors.toList());
		list.forEach(string -> System.out.println(string));
	}
}

//六、遍历
class each_Test{
	// 遍历Collection集合
	public static <T> void eachCollection(){
		ArrayList<String> list = new ArrayList<String>();
		list.add("Hello");
		list.add("Java");
		list.add("World");
		list.add("笔记");

		// 高级for遍历
		for (String value : list) {
			System.out.println(value);
		}

		// 使用for循环遍历List
		for (int i = 0; i < list.size(); i++){
			String s = (String) list.get(i);
			System.out.println(s);
		}

	}

	// 遍历map集合
	public static void eachMap(){
		Map<String, Integer> cityMap = new HashMap<>();
		cityMap.put("武汉",55);
		cityMap.put("上海",11);

		//方法1
		cityMap.forEach((k, v) -> System.out.println("key:value = " + k + ":" + v));

		//方法2
		//获取Map中的所有key与value的对应关系
		Set<Map.Entry<String,Integer>> entrySet = cityMap.entrySet();
		//遍历Set集合
		Iterator<Map.Entry<String,Integer>> it =entrySet.iterator();
		while(it.hasNext()){
			//得到每一对对应关系
			Map.Entry<String,Integer> entry = it.next();
			//通过每一对对应关系获取对应的key
			String key = entry.getKey();
			//通过每一对对应关系获取对应的value
			Integer value = entry.getValue();
			System.out.println(key+"="+value);
		}

		//方法3
		Set<String> keySet = cityMap.keySet();  //获取Map中的所有key
		//遍历存放所有key的Set集合
		Iterator<String> it2 =keySet.iterator();
		while(it2.hasNext()){
			//得到每一个key
			String key = it2.next();
			//通过key获取对应的value
			Integer value = cityMap.get(key);
			System.out.println(key+"="+value);
		}
	}

	public static void main(String[] args) {
		eachCollection();
		eachMap();
	}
}

public class List_Test {
	public static void main(String[] args) {

	}
}
```



**组合成列表**

```java
List<ArticleTag> reqTagList = tagIds.stream().map((tagId) ->
    new ArticleTag(articleId, tagId)).collect(Collectors.toList());
```



# 常用 

```java
//		查询结果中排除与给定 id 相同的元素，并返回一个过滤后的 ArticleVo 对象列表
		List<ArticleVo> resultList = this.baseMapper
				.selectArticleVoPage(articlePageQueryWrapper).stream()
				.filter(a -> !id.equals(a.getId())).collect(Collectors.toList());
```

```java
// 请求的文章标签列表 tagIds
		List<ArticleTag> reqTagList = tagIds.stream().map((tagId) ->
				new ArticleTag(articleId, tagId)).collect(Collectors.toList());
```





