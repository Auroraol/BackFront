'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var ElButton = require('../el-button');
var ElInput = require('../el-input');
var locale = require('../locale');
var Dialog = require('../utils/aria-dialog');
var usePopup = require('../utils/popup/usePopup');
var dom = require('../utils/dom');
var isServer = require('../utils/isServer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var ElButton__default = /*#__PURE__*/_interopDefaultLegacy(ElButton);
var ElInput__default = /*#__PURE__*/_interopDefaultLegacy(ElInput);
var Dialog__default = /*#__PURE__*/_interopDefaultLegacy(Dialog);
var usePopup__default = /*#__PURE__*/_interopDefaultLegacy(usePopup);
var isServer__default = /*#__PURE__*/_interopDefaultLegacy(isServer);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

let dialog;
const TypeMap = {
    success: 'success',
    info: 'info',
    warning: 'warning',
    error: 'error',
};
var script = vue.defineComponent({
    name: 'ElMessageBox',
    components: {
        ElButton: ElButton__default['default'],
        ElInput: ElInput__default['default'],
    },
    props: {
        openDelay: {
            type: Number,
            default: 0,
        },
        closeDelay: {
            type: Number,
            default: 0,
        },
        zIndex: Number,
        modalFade: {
            type: Boolean,
            default: true,
        },
        modalClass: {
            type: String,
            default: '',
        },
        modalAppendToBody: {
            type: Boolean,
            default: false,
        },
        modal: {
            type: Boolean,
            default: true,
        },
        lockScroll: {
            type: Boolean,
            default: true,
        },
        showClose: {
            type: Boolean,
            default: true,
        },
        closeOnClickModal: {
            type: Boolean,
            default: true,
        },
        closeOnPressEscape: {
            type: Boolean,
            default: true,
        },
        closeOnHashChange: {
            type: Boolean,
            default: true,
        },
        center: {
            default: false,
            type: Boolean,
        },
        roundButton: {
            default: false,
            type: Boolean,
        },
    },
    setup(props) {
        let vm;
        const popup = usePopup__default['default'](props, doClose);
        const state = vue.reactive({
            uid: 1,
            title: undefined,
            message: '',
            type: '',
            iconClass: '',
            customClass: '',
            showInput: false,
            inputValue: null,
            inputPlaceholder: '',
            inputType: 'text',
            inputPattern: null,
            inputValidator: null,
            inputErrorMessage: '',
            showConfirmButton: true,
            showCancelButton: false,
            action: '',
            confirmButtonText: '',
            cancelButtonText: '',
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonClass: '',
            confirmButtonDisabled: false,
            cancelButtonClass: '',
            editorErrorMessage: null,
            callback: null,
            dangerouslyUseHTMLString: false,
            focusAfterClosed: null,
            isOnComposition: false,
            distinguishCancelAndClose: false,
            type$: '',
            visible: false,
            validateError: false,
        });
        const icon = vue.computed(() => state.iconClass || (state.type && TypeMap[state.type] ? `el-icon-${TypeMap[state.type]}` : ''));
        const hasMessage = vue.computed(() => !!state.message);
        const confirmButtonClasses = vue.computed(() => `el-button--primary ${state.confirmButtonClass}`);
        vue.watch(() => state.inputValue, (val) => __awaiter(this, void 0, void 0, function* () {
            yield vue.nextTick();
            if (state.type$ === 'prompt' && val !== null) {
                validate();
            }
        }), { immediate: true });
        vue.watch(() => state.visible, val => {
            popup.state.visible = val;
            if (val) {
                state.uid++;
                if (state.type$ === 'alert' || state.type$ === 'confirm') {
                    vue.nextTick().then(() => { vm.refs.confirm.$el.focus(); });
                }
                state.focusAfterClosed = document.activeElement;
                dialog = new Dialog__default['default'](vm.vnode.el, state.focusAfterClosed, getFirstFocus());
            }
            if (state.type$ !== 'prompt')
                return;
            if (val) {
                vue.nextTick().then(() => {
                    if (vm.refs.input && vm.refs.input.$el) {
                        getInputElement().focus();
                    }
                });
            }
            else {
                state.editorErrorMessage = '';
                state.validateError = false;
            }
        });
        vue.onBeforeMount(() => {
            vm = vue.getCurrentInstance();
            vm.setupInstall = {
                state,
                doClose,
            };
        });
        vue.onMounted(() => __awaiter(this, void 0, void 0, function* () {
            yield vue.nextTick();
            if (props.closeOnHashChange) {
                dom.on(window, 'hashchange', popup.close);
            }
        }));
        vue.onBeforeUnmount(() => {
            if (props.closeOnHashChange) {
                dom.off(window, 'hashchange', popup.close);
            }
            setTimeout(() => {
                dialog.closeDialog();
            });
        });
        function getSafeClose() {
            const currentId = state.uid;
            return () => __awaiter(this, void 0, void 0, function* () {
                yield vue.nextTick();
                if (currentId === state.uid)
                    doClose();
            });
        }
        function doClose() {
            if (!state.visible)
                return;
            state.visible = false;
            popup.updateClosingFlag(true);
            dialog.closeDialog();
            if (props.lockScroll) {
                setTimeout(popup.restoreBodyStyle, 200);
            }
            popup.state.opened = false;
            popup.doAfterClose();
            setTimeout(() => {
                if (state.action)
                    state.callback(state.action, state);
            });
        }
        const getFirstFocus = () => {
            const btn = vm.vnode.el.querySelector('.el-message-box__btns .el-button');
            const title = vm.vnode.el.querySelector('.el-message-box__btns .el-message-box__title');
            return btn || title;
        };
        const handleWrapperClick = () => {
            if (props.closeOnClickModal) {
                handleAction(state.distinguishCancelAndClose ? 'close' : 'cancel');
            }
        };
        const handleInputEnter = () => {
            if (state.inputType !== 'textarea') {
                return handleAction('confirm');
            }
        };
        const handleAction = action => {
            if (state.type$ === 'prompt' && action === 'confirm' && !validate()) {
                return;
            }
            state.action = action;
            if (typeof vm.setupInstall.state.beforeClose === 'function') {
                vm.setupInstall.state.close = getSafeClose();
                vm.setupInstall.state.beforeClose(action, state, popup.close);
            }
            else {
                doClose();
            }
        };
        const validate = () => {
            if (state.type$ === 'prompt') {
                const inputPattern = state.inputPattern;
                if (inputPattern && !inputPattern.test(state.inputValue || '')) {
                    state.editorErrorMessage = state.inputErrorMessage || locale.t('el.messagebox.error');
                    state.validateError = true;
                    return false;
                }
                const inputValidator = state.inputValidator;
                if (typeof inputValidator === 'function') {
                    const validateResult = inputValidator(state.inputValue);
                    if (validateResult === false) {
                        state.editorErrorMessage = state.inputErrorMessage || locale.t('el.messagebox.error');
                        state.validateError = true;
                        return false;
                    }
                    if (typeof validateResult === 'string') {
                        state.editorErrorMessage = validateResult;
                        state.validateError = true;
                        return false;
                    }
                }
            }
            state.editorErrorMessage = '';
            state.validateError = false;
            return true;
        };
        const getInputElement = () => {
            const inputRefs = vm.refs.input.$refs;
            return inputRefs.input || inputRefs.textarea;
        };
        const handleClose = () => {
            handleAction('close');
        };
        return Object.assign(Object.assign({}, vue.toRefs(state)), { hasMessage,
            icon,
            confirmButtonClasses,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            handleClose,
            t: locale.t,
            doClose });
    },
});

const _hoisted_1 = {
  key: 0,
  class: "el-message-box__header"
};
const _hoisted_2 = { class: "el-message-box__title" };
const _hoisted_3 = /*#__PURE__*/vue.createVNode("i", { class: "el-message-box__close el-icon-close" }, null, -1 /* HOISTED */);
const _hoisted_4 = { class: "el-message-box__content" };
const _hoisted_5 = { class: "el-message-box__container" };
const _hoisted_6 = {
  key: 1,
  class: "el-message-box__message"
};
const _hoisted_7 = { key: 0 };
const _hoisted_8 = { class: "el-message-box__input" };
const _hoisted_9 = { class: "el-message-box__btns" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = vue.resolveComponent("el-input");
  const _component_el_button = vue.resolveComponent("el-button");

  return (vue.openBlock(), vue.createBlock(vue.Transition, { name: "msgbox-fade" }, {
    default: vue.withCtx(() => [
      vue.withDirectives(vue.createVNode("div", {
        ref: "root",
        "aria-label": _ctx.title || 'dialog',
        class: "el-message-box__wrapper",
        tabindex: "-1",
        role: "dialog",
        "aria-modal": "true",
        onClick: _cache[8] || (_cache[8] = vue.withModifiers((...args) => (_ctx.handleWrapperClick(...args)), ["self"]))
      }, [
        vue.createVNode("div", {
          class: ["el-message-box", [_ctx.customClass, _ctx.center && 'el-message-box--center']]
        }, [
          (_ctx.title !== null && _ctx.title !== undefined)
            ? (vue.openBlock(), vue.createBlock("div", _hoisted_1, [
                vue.createVNode("div", _hoisted_2, [
                  (_ctx.icon && _ctx.center)
                    ? (vue.openBlock(), vue.createBlock("div", {
                        key: 0,
                        class: ['el-message-box__status', _ctx.icon]
                      }, null, 2 /* CLASS */))
                    : vue.createCommentVNode("v-if", true),
                  vue.createVNode("span", null, vue.toDisplayString(_ctx.title), 1 /* TEXT */)
                ]),
                (_ctx.showClose)
                  ? (vue.openBlock(), vue.createBlock("button", {
                      key: 0,
                      type: "button",
                      class: "el-message-box__headerbtn",
                      "aria-label": "Close",
                      onClick: _cache[1] || (_cache[1] = $event => (_ctx.handleAction(_ctx.distinguishCancelAndClose ? 'close' : 'cancel'))),
                      onKeydown: _cache[2] || (_cache[2] = vue.withKeys($event => (_ctx.handleAction(_ctx.distinguishCancelAndClose ? 'close' : 'cancel')), ["enter"]))
                    }, [
                      _hoisted_3
                    ], 32 /* HYDRATE_EVENTS */))
                  : vue.createCommentVNode("v-if", true)
              ]))
            : vue.createCommentVNode("v-if", true),
          vue.createVNode("div", _hoisted_4, [
            vue.createVNode("div", _hoisted_5, [
              (_ctx.icon && !_ctx.center && _ctx.hasMessage)
                ? (vue.openBlock(), vue.createBlock("div", {
                    key: 0,
                    class: ['el-message-box__status', _ctx.icon]
                  }, null, 2 /* CLASS */))
                : vue.createCommentVNode("v-if", true),
              (_ctx.hasMessage)
                ? (vue.openBlock(), vue.createBlock("div", _hoisted_6, [
                    vue.renderSlot(_ctx.$slots, "default", {}, () => [
                      (!_ctx.dangerouslyUseHTMLString)
                        ? (vue.openBlock(), vue.createBlock("p", _hoisted_7, vue.toDisplayString(_ctx.message), 1 /* TEXT */))
                        : (vue.openBlock(), vue.createBlock("p", {
                            key: 1,
                            innerHTML: _ctx.message
                          }, null, 8 /* PROPS */, ["innerHTML"]))
                    ])
                  ]))
                : vue.createCommentVNode("v-if", true)
            ]),
            vue.withDirectives(vue.createVNode("div", _hoisted_8, [
              vue.createVNode(_component_el_input, {
                ref: "input",
                modelValue: _ctx.inputValue,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => (_ctx.inputValue = $event)),
                type: _ctx.inputType,
                placeholder: _ctx.inputPlaceholder,
                class: { invalid: _ctx.validateError },
                onKeydown: vue.withKeys(_ctx.handleInputEnter, ["enter"])
              }, null, 8 /* PROPS */, ["modelValue", "type", "placeholder", "class", "onKeydown"]),
              vue.createVNode("div", {
                class: "el-message-box__errormsg",
                style: { visibility: !!_ctx.editorErrorMessage ? 'visible' : 'hidden' }
              }, vue.toDisplayString(_ctx.editorErrorMessage), 5 /* TEXT, STYLE */)
            ], 512 /* NEED_PATCH */), [
              [vue.vShow, _ctx.showInput]
            ])
          ]),
          vue.createVNode("div", _hoisted_9, [
            (_ctx.showCancelButton)
              ? (vue.openBlock(), vue.createBlock(_component_el_button, {
                  key: 0,
                  loading: _ctx.cancelButtonLoading,
                  class: [ _ctx.cancelButtonClass ],
                  round: _ctx.roundButton,
                  size: "small",
                  onClick: _cache[4] || (_cache[4] = $event => (_ctx.handleAction('cancel'))),
                  onKeydown: _cache[5] || (_cache[5] = vue.withKeys($event => (_ctx.handleAction('cancel')), ["enter"]))
                }, {
                  default: vue.withCtx(() => [
                    vue.createTextVNode(vue.toDisplayString(_ctx.cancelButtonText || _ctx.t('el.messagebox.cancel')), 1 /* TEXT */)
                  ]),
                  _: 1
                }, 8 /* PROPS */, ["loading", "class", "round"]))
              : vue.createCommentVNode("v-if", true),
            vue.withDirectives(vue.createVNode(_component_el_button, {
              ref: "confirm",
              loading: _ctx.confirmButtonLoading,
              class: [ _ctx.confirmButtonClasses ],
              round: _ctx.roundButton,
              disabled: _ctx.confirmButtonDisabled,
              size: "small",
              onClick: _cache[6] || (_cache[6] = $event => (_ctx.handleAction('confirm'))),
              onKeydown: _cache[7] || (_cache[7] = vue.withKeys($event => (_ctx.handleAction('confirm')), ["enter"]))
            }, {
              default: vue.withCtx(() => [
                vue.createTextVNode(vue.toDisplayString(_ctx.confirmButtonText || _ctx.t('el.messagebox.confirm')), 1 /* TEXT */)
              ]),
              _: 1
            }, 8 /* PROPS */, ["loading", "class", "round", "disabled"]), [
              [vue.vShow, _ctx.showConfirmButton]
            ])
          ])
        ], 2 /* CLASS */)
      ], 8 /* PROPS */, ["aria-label"]), [
        [vue.vShow, _ctx.visible]
      ])
    ]),
    _: 1
  }))
}

script.render = render;
script.__file = "packages/message-box/src/index.vue";

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
const EMPTY_OBJ = (process.env.NODE_ENV !== 'production')
    ? Object.freeze({})
    : {};
const EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];

let currentMsg, instance;
const PROP_KEYS = [
    'lockScroll',
    'showClose',
    'closeOnClickModal',
    'closeOnPressEscape',
    'closeOnHashChange',
    'center',
    'roundButton',
    'closeDelay',
    'zIndex',
    'modal',
    'modalFade',
    'modalClass',
    'modalAppendToBody',
    'lockScroll',
];
const defaults = {
    title: null,
    message: '',
    type: '',
    iconClass: '',
    showInput: false,
    showClose: true,
    modalFade: true,
    lockScroll: true,
    closeOnClickModal: true,
    closeOnPressEscape: true,
    closeOnHashChange: true,
    inputValue: null,
    inputPlaceholder: '',
    inputType: 'text',
    inputPattern: null,
    inputValidator: null,
    inputErrorMessage: '',
    showConfirmButton: true,
    showCancelButton: false,
    confirmButtonPosition: 'right',
    confirmButtonHighlight: false,
    cancelButtonHighlight: false,
    confirmButtonText: '',
    cancelButtonText: '',
    confirmButtonClass: '',
    cancelButtonClass: '',
    customClass: '',
    beforeClose: null,
    dangerouslyUseHTMLString: false,
    center: false,
    roundButton: false,
    distinguishCancelAndClose: false,
};
let msgQueue = [];
const defaultCallback = (action, ctx) => {
    if (currentMsg) {
        const callback = currentMsg.callback;
        if (typeof callback === 'function') {
            if (ctx.showInput) {
                callback(ctx.inputValue, action);
            }
            else {
                callback(action);
            }
        }
        if (currentMsg.resolve) {
            if (action === 'confirm') {
                if (ctx.showInput) {
                    currentMsg.resolve({ value: ctx.inputValue, action });
                }
                else {
                    currentMsg.resolve(action);
                }
            }
            else if (currentMsg.reject && (action === 'cancel' || action === 'close')) {
                currentMsg.reject(action);
            }
        }
    }
};
const initInstance = () => {
    const container = document.createElement('div');
    const vnode = vue.createVNode(script);
    vue.render(vnode, container);
    instance = vnode.component;
};
const showNextMsg = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!instance) {
        initInstance();
    }
    if (instance && instance.setupInstall.state.visible) {
        return;
    }
    if (msgQueue.length > 0) {
        const props = {};
        const state = {};
        currentMsg = msgQueue.shift();
        const options = currentMsg.options;
        Object.keys(options).forEach(key => {
            if (PROP_KEYS.includes(key)) {
                props[key] = options[key];
            }
            else {
                state[key] = options[key];
            }
        });
        const vmProps = instance.props;
        for (const prop in props) {
            if (props.hasOwnProperty(prop)) {
                vmProps[prop] = props[prop];
            }
        }
        const vmState = instance.setupInstall.state;
        vmState.action = '';
        if (options.callback === undefined) {
            options.callback = defaultCallback;
        }
        for (const prop in state) {
            if (state.hasOwnProperty(prop)) {
                vmState[prop] = state[prop];
            }
        }
        if (vue.isVNode(options.message)) {
            instance.slots.default = () => [options.message];
        }
        const oldCb = options.callback;
        vmState.callback = (action, inst) => {
            oldCb(action, inst);
            showNextMsg();
        };
        document.body.appendChild(instance.vnode.el);
        vmState.visible = true;
    }
});
const MessageBox = function (options, callback) {
    if (isServer__default['default'])
        return;
    if (typeof options === 'string' || vue.isVNode(options)) {
        options = {
            message: options,
        };
        if (typeof callback === 'string') {
            options.title = callback;
        }
    }
    else if (options.callback && !callback) {
        callback = options.callback;
    }
    if (typeof Promise !== 'undefined') {
        return new Promise((resolve, reject) => {
            msgQueue.push({
                options: Object.assign({}, defaults, options),
                callback: callback,
                resolve: resolve,
                reject: reject,
            });
            showNextMsg();
        });
    }
    else {
        msgQueue.push({
            options: Object.assign({}, defaults, options),
            callback: callback,
        });
        showNextMsg();
    }
};
MessageBox.alert = (message, title, options) => {
    if (typeof title === 'object') {
        options = title;
        title = '';
    }
    else if (title === undefined) {
        title = '';
    }
    return MessageBox(Object.assign({
        title: title,
        message: message,
        type$: 'alert',
        closeOnPressEscape: false,
        closeOnClickModal: false,
    }, options));
};
MessageBox.confirm = (message, title, options) => {
    if (typeof title === 'object') {
        options = title;
        title = '';
    }
    else if (title === undefined) {
        title = '';
    }
    return MessageBox(Object.assign({
        title: title,
        message: message,
        type$: 'confirm',
        showCancelButton: true,
    }, options));
};
MessageBox.prompt = (message, title, options) => {
    if (typeof title === 'object') {
        options = title;
        title = '';
    }
    else if (title === undefined) {
        title = '';
    }
    return MessageBox(Object.assign({
        title: title,
        message: message,
        showCancelButton: true,
        showInput: true,
        type$: 'prompt',
    }, options));
};
MessageBox.close = () => {
    instance.setupInstall.doClose();
    instance.setupInstall.state.visible = false;
    msgQueue = [];
    currentMsg = null;
};

MessageBox.install = (app) => {
    app.config.globalProperties.$msgbox = MessageBox;
    app.config.globalProperties.$messageBox = MessageBox;
    app.config.globalProperties.$alert = MessageBox.alert;
    app.config.globalProperties.$confirm = MessageBox.confirm;
    app.config.globalProperties.$prompt = MessageBox.prompt;
};

exports.default = MessageBox;
