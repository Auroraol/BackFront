import { defineComponent, computed, ref, openBlock, createBlock, Transition, withCtx, withDirectives, createVNode, createCommentVNode, toDisplayString, renderSlot, Fragment, vShow, withModifiers, isVNode, render as render$1, nextTick } from 'vue';

const EVENT_CODE = {
    tab: 'Tab',
    enter: 'Enter',
    space: 'Space',
    left: 'ArrowLeft',
    up: 'ArrowUp',
    right: 'ArrowRight',
    down: 'ArrowDown',
    esc: 'Escape',
    delete: 'Delete',
    backspace: 'Backspace',
};

var isServer = typeof window === 'undefined';

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
const EMPTY_OBJ = (process.env.NODE_ENV !== 'production')
    ? Object.freeze({})
    : {};
const EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];

const trim = function (s) {
    return (s || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
const on = function (element, event, handler, useCapture = false) {
    if (element && event && handler) {
        element.addEventListener(event, handler, useCapture);
    }
};
const off = function (element, event, handler) {
    if (element && event && handler) {
        element.removeEventListener(event, handler, false);
    }
};
function hasClass(el, cls) {
    if (!el || !cls)
        return false;
    if (cls.indexOf(' ') !== -1)
        throw new Error('className should not contain space.');
    if (el.classList) {
        return el.classList.contains(cls);
    }
    else {
        return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
    }
}
function addClass(el, cls) {
    if (!el)
        return;
    let curClass = el.className;
    const classes = (cls || '').split(' ');
    for (let i = 0, j = classes.length; i < j; i++) {
        const clsName = classes[i];
        if (!clsName)
            continue;
        if (el.classList) {
            el.classList.add(clsName);
        }
        else if (!hasClass(el, clsName)) {
            curClass += ' ' + clsName;
        }
    }
    if (!el.classList) {
        el.className = curClass;
    }
}
function removeClass(el, cls) {
    if (!el || !cls)
        return;
    const classes = cls.split(' ');
    let curClass = ' ' + el.className + ' ';
    for (let i = 0, j = classes.length; i < j; i++) {
        const clsName = classes[i];
        if (!clsName)
            continue;
        if (el.classList) {
            el.classList.remove(clsName);
        }
        else if (hasClass(el, clsName)) {
            curClass = curClass.replace(' ' + clsName + ' ', ' ');
        }
    }
    if (!el.classList) {
        el.className = trim(curClass);
    }
}

const TypeMap = {
    success: 'success',
    info: 'info',
    warning: 'warning',
    error: 'error',
};
var script = defineComponent({
    name: 'ElNotification',
    props: {
        customClass: { type: String, default: '' },
        dangerouslyUseHTMLString: { type: Boolean, default: false },
        duration: { type: Number, default: 4500 },
        iconClass: { type: String, default: '' },
        id: { type: String, default: '' },
        message: {
            type: [String, Object],
            default: '',
        },
        offset: { type: Number, default: 0 },
        onClick: {
            type: Function,
            default: () => void 0,
        },
        onClose: {
            type: Function,
            required: true,
        },
        position: {
            type: String,
            default: 'top-right',
        },
        showClose: { type: Boolean, default: true },
        title: { type: String, default: '' },
        type: { type: String, default: '' },
        zIndex: { type: Number, default: 0 },
    },
    emits: ['close', 'click'],
    setup(props) {
        const typeClass = computed(() => {
            const type = props.type;
            return type && TypeMap[type] ? `el-icon-${TypeMap[type]}` : '';
        });
        const horizontalClass = computed(() => {
            return props.position.indexOf('right') > 1 ? 'right' : 'left';
        });
        const verticalProperty = computed(() => {
            return props.position.startsWith('top') ? 'top' : 'bottom';
        });
        const positionStyle = computed(() => {
            return {
                [verticalProperty.value]: `${props.offset}px`,
            };
        });
        const visible = ref(false);
        const closed = ref(false);
        const timer = ref(null);
        return {
            horizontalClass,
            typeClass,
            positionStyle,
            verticalProperty,
            visible,
            closed,
            timer,
        };
    },
    watch: {
        closed(newVal) {
            if (newVal) {
                this.visible = false;
                on(this.$el, 'transitionend', this.destroyElement);
            }
        },
    },
    mounted() {
        if (this.duration > 0) {
            this.timer = setTimeout(() => {
                if (!this.closed) {
                    this.close();
                }
            }, this.duration);
        }
        this.visible = true;
        on(document, 'keydown', this.keydown);
    },
    beforeUnmount() {
        off(document, 'keydown', this.keydown);
    },
    methods: {
        destroyElement() {
            this.visible = false;
            off(this.$el, 'transitionend', this.destroyElement);
            this.onClose();
        },
        startTimer() {
            if (this.duration > 0) {
                this.timer = setTimeout(() => {
                    if (!this.closed) {
                        this.close();
                    }
                }, this.duration);
            }
        },
        clearTimer() {
            clearTimeout(this.timer);
            this.timer = null;
        },
        click() {
            this === null || this === void 0 ? void 0 : this.onClick();
        },
        close() {
            this.closed = true;
            this.timer = null;
        },
        keydown({ code }) {
            if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
                this.clearTimer();
            }
            else if (code === EVENT_CODE.esc) {
                if (!this.closed) {
                    this.close();
                }
            }
            else {
                this.startTimer();
            }
        },
    },
});

const _hoisted_1 = { class: "el-notification__content" };
const _hoisted_2 = { key: 0 };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, { name: "el-notification-fade" }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        id: _ctx.id,
        class: ['el-notification', _ctx.customClass, _ctx.horizontalClass],
        style: _ctx.positionStyle,
        role: "alert",
        onMouseenter: _cache[2] || (_cache[2] = $event => (_ctx.clearTimer())),
        onMouseleave: _cache[3] || (_cache[3] = $event => (_ctx.startTimer())),
        onClick: _cache[4] || (_cache[4] = (...args) => (_ctx.click(...args)))
      }, [
        (_ctx.type || _ctx.iconClass)
          ? (openBlock(), createBlock("i", {
              key: 0,
              class: ["el-notification__icon", [_ctx.typeClass, _ctx.iconClass]]
            }, null, 2 /* CLASS */))
          : createCommentVNode("v-if", true),
        createVNode("div", {
          class: ["el-notification__group", { 'is-with-icon': _ctx.typeClass || _ctx.iconClass }]
        }, [
          createVNode("h2", {
            class: "el-notification__title",
            textContent: toDisplayString(_ctx.title)
          }, null, 8 /* PROPS */, ["textContent"]),
          withDirectives(createVNode("div", _hoisted_1, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              (!_ctx.dangerouslyUseHTMLString)
                ? (openBlock(), createBlock("p", _hoisted_2, toDisplayString(_ctx.message), 1 /* TEXT */))
                : (openBlock(), createBlock(Fragment, { key: 1 }, [
                    createCommentVNode(" Caution here, message could've been compromized, nerver use user's input as message "),
                    createCommentVNode(" eslint-disable-next-line "),
                    createVNode("p", { innerHTML: _ctx.message }, null, 8 /* PROPS */, ["innerHTML"])
                  ], 64 /* STABLE_FRAGMENT */))
            ])
          ], 512 /* NEED_PATCH */), [
            [vShow, _ctx.message]
          ]),
          (_ctx.showClose)
            ? (openBlock(), createBlock("div", {
                key: 0,
                class: "el-notification__closeBtn el-icon-close",
                onClick: _cache[1] || (_cache[1] = withModifiers((...args) => (_ctx.close(...args)), ["stop"]))
              }))
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */)
      ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, ["id"]), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }))
}

script.render = render;
script.__file = "packages/notification/src/index.vue";

let $ELEMENT = {};
const getConfig = (key) => {
    return $ELEMENT[key];
};

const onTouchMove = (e) => {
    e.preventDefault();
    e.stopPropagation();
};
const onModalClick = () => {
    PopupManager === null || PopupManager === void 0 ? void 0 : PopupManager.doOnModalClick();
};
let hasModal = false;
let zIndex;
const getModal = function () {
    if (isServer)
        return;
    let modalDom = PopupManager.modalDom;
    if (modalDom) {
        hasModal = true;
    }
    else {
        hasModal = false;
        modalDom = document.createElement('div');
        PopupManager.modalDom = modalDom;
        on(modalDom, 'touchmove', onTouchMove);
        on(modalDom, 'click', onModalClick);
    }
    return modalDom;
};
const instances = {};
const PopupManager = {
    modalFade: true,
    modalDom: undefined,
    zIndex,
    getInstance: function (id) {
        return instances[id];
    },
    register: function (id, instance) {
        if (id && instance) {
            instances[id] = instance;
        }
    },
    deregister: function (id) {
        if (id) {
            instances[id] = null;
            delete instances[id];
        }
    },
    nextZIndex: function () {
        return ++PopupManager.zIndex;
    },
    modalStack: [],
    doOnModalClick: function () {
        const topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
        if (!topItem)
            return;
        const instance = PopupManager.getInstance(topItem.id);
        if (instance && instance.closeOnClickModal.value) {
            instance.close();
        }
    },
    openModal: function (id, zIndex, dom, modalClass, modalFade) {
        if (isServer)
            return;
        if (!id || zIndex === undefined)
            return;
        this.modalFade = modalFade;
        const modalStack = this.modalStack;
        for (let i = 0, j = modalStack.length; i < j; i++) {
            const item = modalStack[i];
            if (item.id === id) {
                return;
            }
        }
        const modalDom = getModal();
        addClass(modalDom, 'v-modal');
        if (this.modalFade && !hasModal) {
            addClass(modalDom, 'v-modal-enter');
        }
        if (modalClass) {
            const classArr = modalClass.trim().split(/\s+/);
            classArr.forEach(item => addClass(modalDom, item));
        }
        setTimeout(() => {
            removeClass(modalDom, 'v-modal-enter');
        }, 200);
        if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
            dom.parentNode.appendChild(modalDom);
        }
        else {
            document.body.appendChild(modalDom);
        }
        if (zIndex) {
            modalDom.style.zIndex = String(zIndex);
        }
        modalDom.tabIndex = 0;
        modalDom.style.display = '';
        this.modalStack.push({ id: id, zIndex: zIndex, modalClass: modalClass });
    },
    closeModal: function (id) {
        const modalStack = this.modalStack;
        const modalDom = getModal();
        if (modalStack.length > 0) {
            const topItem = modalStack[modalStack.length - 1];
            if (topItem.id === id) {
                if (topItem.modalClass) {
                    const classArr = topItem.modalClass.trim().split(/\s+/);
                    classArr.forEach(item => removeClass(modalDom, item));
                }
                modalStack.pop();
                if (modalStack.length > 0) {
                    modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
                }
            }
            else {
                for (let i = modalStack.length - 1; i >= 0; i--) {
                    if (modalStack[i].id === id) {
                        modalStack.splice(i, 1);
                        break;
                    }
                }
            }
        }
        if (modalStack.length === 0) {
            if (this.modalFade) {
                addClass(modalDom, 'v-modal-leave');
            }
            setTimeout(() => {
                if (modalStack.length === 0) {
                    if (modalDom.parentNode)
                        modalDom.parentNode.removeChild(modalDom);
                    modalDom.style.display = 'none';
                    PopupManager.modalDom = undefined;
                }
                removeClass(modalDom, 'v-modal-leave');
            }, 200);
        }
    },
};
Object.defineProperty(PopupManager, 'zIndex', {
    configurable: true,
    get() {
        if (zIndex === undefined) {
            zIndex = getConfig('zIndex') || 2000;
        }
        return zIndex;
    },
    set(value) {
        zIndex = value;
    },
});
const getTopPopup = function () {
    if (isServer)
        return;
    if (PopupManager.modalStack.length > 0) {
        const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
        if (!topPopup)
            return;
        const instance = PopupManager.getInstance(topPopup.id);
        return instance;
    }
};
if (!isServer) {
    on(window, 'keydown', function (event) {
        if (event.code === EVENT_CODE.esc) {
            const topPopup = getTopPopup();
            if (topPopup && topPopup.closeOnPressEscape.value) {
                topPopup.handleClose
                    ? topPopup.handleClose()
                    : topPopup.handleAction
                        ? topPopup.handleAction('cancel')
                        : topPopup.close();
            }
        }
    });
}

let vm;
const notifications = [];
let seed = 1;
const Notification = function (options = {}) {
    if (isServer)
        return;
    const position = options.position || 'top-right';
    let verticalOffset = options.offset || 0;
    notifications
        .filter(({ vm }) => vm.component.props.position === position)
        .forEach(({ vm }) => {
        verticalOffset += (vm.el.offsetHeight || 0) + 16;
    });
    verticalOffset += 16;
    const id = 'notification_' + seed++;
    const userOnClose = options.onClose;
    options = Object.assign(Object.assign({ dangerouslyUseHTMLString: false, duration: 4500, position: 'top-right', showClose: true }, options), { onClose: () => {
            close(id, userOnClose);
        }, offset: verticalOffset, id, zIndex: PopupManager.nextZIndex() });
    const container = document.createElement('div');
    container.className = `container_${id}`;
    container.style.zIndex = String();
    vm = createVNode(script, options, isVNode(options.message)
        ? {
            default: () => options.message,
        }
        : null);
    render$1(vm, container);
    notifications.push({ vm, $el: container });
    document.body.appendChild(container);
    return {
        close: options.onClose,
    };
};
['success', 'warning', 'info', 'error'].forEach(type => {
    Object.assign(Notification, {
        [type]: (options = {}) => {
            if (typeof options === 'string' || isVNode(options)) {
                options = {
                    message: options,
                };
            }
            options.type = type;
            return Notification(options);
        },
    });
});
function close(id, userOnClose) {
    const idx = notifications.findIndex(({ vm }) => {
        const { id: _id } = vm.component.props;
        return id === _id;
    });
    if (idx === -1) {
        return;
    }
    const { vm, $el } = notifications[idx];
    if (!vm)
        return;
    userOnClose === null || userOnClose === void 0 ? void 0 : userOnClose(vm);
    const removedHeight = vm.el.offsetHeight;
    render$1(null, $el);
    notifications.splice(idx, 1);
    const len = notifications.length;
    nextTick(() => {
        document.body.removeChild($el);
    });
    if (len < 1)
        return;
    const position = vm.props.position;
    for (let i = idx; i < len; i++) {
        if (notifications[i].vm.component.props.position === position) {
            const verticalPos = vm.props.position.split('-')[0];
            const pos = parseInt(notifications[i].vm.el.style[verticalPos], 10) -
                removedHeight -
                16;
            notifications[i].vm.component.props.offset = pos;
            requestAnimationFrame(() => {
                render$1(notifications[i].vm, notifications[i].$el);
            });
        }
    }
}

Notification.install = (app) => {
    app.config.globalProperties.$notify = Notification;
};

export default Notification;
