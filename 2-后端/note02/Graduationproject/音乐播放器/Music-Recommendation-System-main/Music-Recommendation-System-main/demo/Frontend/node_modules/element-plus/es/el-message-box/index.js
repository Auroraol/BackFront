import { defineComponent, reactive, computed, watch, nextTick, onBeforeMount, getCurrentInstance, onMounted, onBeforeUnmount, toRefs, resolveComponent, openBlock, createBlock, Transition, withCtx, withDirectives, createVNode, withModifiers, createCommentVNode, toDisplayString, withKeys, renderSlot, vShow, createTextVNode, isVNode, render as render$1 } from 'vue';
import ElButton from '../el-button';
import ElInput from '../el-input';
import { t } from '../locale';
import Dialog from '../utils/aria-dialog';
import usePopup from '../utils/popup/usePopup';
import { on, off } from '../utils/dom';
import isServer from '../utils/isServer';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

let dialog;
const TypeMap = {
    success: 'success',
    info: 'info',
    warning: 'warning',
    error: 'error',
};
var script = defineComponent({
    name: 'ElMessageBox',
    components: {
        ElButton,
        ElInput,
    },
    props: {
        openDelay: {
            type: Number,
            default: 0,
        },
        closeDelay: {
            type: Number,
            default: 0,
        },
        zIndex: Number,
        modalFade: {
            type: Boolean,
            default: true,
        },
        modalClass: {
            type: String,
            default: '',
        },
        modalAppendToBody: {
            type: Boolean,
            default: false,
        },
        modal: {
            type: Boolean,
            default: true,
        },
        lockScroll: {
            type: Boolean,
            default: true,
        },
        showClose: {
            type: Boolean,
            default: true,
        },
        closeOnClickModal: {
            type: Boolean,
            default: true,
        },
        closeOnPressEscape: {
            type: Boolean,
            default: true,
        },
        closeOnHashChange: {
            type: Boolean,
            default: true,
        },
        center: {
            default: false,
            type: Boolean,
        },
        roundButton: {
            default: false,
            type: Boolean,
        },
    },
    setup(props) {
        let vm;
        const popup = usePopup(props, doClose);
        const state = reactive({
            uid: 1,
            title: undefined,
            message: '',
            type: '',
            iconClass: '',
            customClass: '',
            showInput: false,
            inputValue: null,
            inputPlaceholder: '',
            inputType: 'text',
            inputPattern: null,
            inputValidator: null,
            inputErrorMessage: '',
            showConfirmButton: true,
            showCancelButton: false,
            action: '',
            confirmButtonText: '',
            cancelButtonText: '',
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonClass: '',
            confirmButtonDisabled: false,
            cancelButtonClass: '',
            editorErrorMessage: null,
            callback: null,
            dangerouslyUseHTMLString: false,
            focusAfterClosed: null,
            isOnComposition: false,
            distinguishCancelAndClose: false,
            type$: '',
            visible: false,
            validateError: false,
        });
        const icon = computed(() => state.iconClass || (state.type && TypeMap[state.type] ? `el-icon-${TypeMap[state.type]}` : ''));
        const hasMessage = computed(() => !!state.message);
        const confirmButtonClasses = computed(() => `el-button--primary ${state.confirmButtonClass}`);
        watch(() => state.inputValue, (val) => __awaiter(this, void 0, void 0, function* () {
            yield nextTick();
            if (state.type$ === 'prompt' && val !== null) {
                validate();
            }
        }), { immediate: true });
        watch(() => state.visible, val => {
            popup.state.visible = val;
            if (val) {
                state.uid++;
                if (state.type$ === 'alert' || state.type$ === 'confirm') {
                    nextTick().then(() => { vm.refs.confirm.$el.focus(); });
                }
                state.focusAfterClosed = document.activeElement;
                dialog = new Dialog(vm.vnode.el, state.focusAfterClosed, getFirstFocus());
            }
            if (state.type$ !== 'prompt')
                return;
            if (val) {
                nextTick().then(() => {
                    if (vm.refs.input && vm.refs.input.$el) {
                        getInputElement().focus();
                    }
                });
            }
            else {
                state.editorErrorMessage = '';
                state.validateError = false;
            }
        });
        onBeforeMount(() => {
            vm = getCurrentInstance();
            vm.setupInstall = {
                state,
                doClose,
            };
        });
        onMounted(() => __awaiter(this, void 0, void 0, function* () {
            yield nextTick();
            if (props.closeOnHashChange) {
                on(window, 'hashchange', popup.close);
            }
        }));
        onBeforeUnmount(() => {
            if (props.closeOnHashChange) {
                off(window, 'hashchange', popup.close);
            }
            setTimeout(() => {
                dialog.closeDialog();
            });
        });
        function getSafeClose() {
            const currentId = state.uid;
            return () => __awaiter(this, void 0, void 0, function* () {
                yield nextTick();
                if (currentId === state.uid)
                    doClose();
            });
        }
        function doClose() {
            if (!state.visible)
                return;
            state.visible = false;
            popup.updateClosingFlag(true);
            dialog.closeDialog();
            if (props.lockScroll) {
                setTimeout(popup.restoreBodyStyle, 200);
            }
            popup.state.opened = false;
            popup.doAfterClose();
            setTimeout(() => {
                if (state.action)
                    state.callback(state.action, state);
            });
        }
        const getFirstFocus = () => {
            const btn = vm.vnode.el.querySelector('.el-message-box__btns .el-button');
            const title = vm.vnode.el.querySelector('.el-message-box__btns .el-message-box__title');
            return btn || title;
        };
        const handleWrapperClick = () => {
            if (props.closeOnClickModal) {
                handleAction(state.distinguishCancelAndClose ? 'close' : 'cancel');
            }
        };
        const handleInputEnter = () => {
            if (state.inputType !== 'textarea') {
                return handleAction('confirm');
            }
        };
        const handleAction = action => {
            if (state.type$ === 'prompt' && action === 'confirm' && !validate()) {
                return;
            }
            state.action = action;
            if (typeof vm.setupInstall.state.beforeClose === 'function') {
                vm.setupInstall.state.close = getSafeClose();
                vm.setupInstall.state.beforeClose(action, state, popup.close);
            }
            else {
                doClose();
            }
        };
        const validate = () => {
            if (state.type$ === 'prompt') {
                const inputPattern = state.inputPattern;
                if (inputPattern && !inputPattern.test(state.inputValue || '')) {
                    state.editorErrorMessage = state.inputErrorMessage || t('el.messagebox.error');
                    state.validateError = true;
                    return false;
                }
                const inputValidator = state.inputValidator;
                if (typeof inputValidator === 'function') {
                    const validateResult = inputValidator(state.inputValue);
                    if (validateResult === false) {
                        state.editorErrorMessage = state.inputErrorMessage || t('el.messagebox.error');
                        state.validateError = true;
                        return false;
                    }
                    if (typeof validateResult === 'string') {
                        state.editorErrorMessage = validateResult;
                        state.validateError = true;
                        return false;
                    }
                }
            }
            state.editorErrorMessage = '';
            state.validateError = false;
            return true;
        };
        const getInputElement = () => {
            const inputRefs = vm.refs.input.$refs;
            return inputRefs.input || inputRefs.textarea;
        };
        const handleClose = () => {
            handleAction('close');
        };
        return Object.assign(Object.assign({}, toRefs(state)), { hasMessage,
            icon,
            confirmButtonClasses,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            handleClose,
            t,
            doClose });
    },
});

const _hoisted_1 = {
  key: 0,
  class: "el-message-box__header"
};
const _hoisted_2 = { class: "el-message-box__title" };
const _hoisted_3 = /*#__PURE__*/createVNode("i", { class: "el-message-box__close el-icon-close" }, null, -1 /* HOISTED */);
const _hoisted_4 = { class: "el-message-box__content" };
const _hoisted_5 = { class: "el-message-box__container" };
const _hoisted_6 = {
  key: 1,
  class: "el-message-box__message"
};
const _hoisted_7 = { key: 0 };
const _hoisted_8 = { class: "el-message-box__input" };
const _hoisted_9 = { class: "el-message-box__btns" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");

  return (openBlock(), createBlock(Transition, { name: "msgbox-fade" }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        ref: "root",
        "aria-label": _ctx.title || 'dialog',
        class: "el-message-box__wrapper",
        tabindex: "-1",
        role: "dialog",
        "aria-modal": "true",
        onClick: _cache[8] || (_cache[8] = withModifiers((...args) => (_ctx.handleWrapperClick(...args)), ["self"]))
      }, [
        createVNode("div", {
          class: ["el-message-box", [_ctx.customClass, _ctx.center && 'el-message-box--center']]
        }, [
          (_ctx.title !== null && _ctx.title !== undefined)
            ? (openBlock(), createBlock("div", _hoisted_1, [
                createVNode("div", _hoisted_2, [
                  (_ctx.icon && _ctx.center)
                    ? (openBlock(), createBlock("div", {
                        key: 0,
                        class: ['el-message-box__status', _ctx.icon]
                      }, null, 2 /* CLASS */))
                    : createCommentVNode("v-if", true),
                  createVNode("span", null, toDisplayString(_ctx.title), 1 /* TEXT */)
                ]),
                (_ctx.showClose)
                  ? (openBlock(), createBlock("button", {
                      key: 0,
                      type: "button",
                      class: "el-message-box__headerbtn",
                      "aria-label": "Close",
                      onClick: _cache[1] || (_cache[1] = $event => (_ctx.handleAction(_ctx.distinguishCancelAndClose ? 'close' : 'cancel'))),
                      onKeydown: _cache[2] || (_cache[2] = withKeys($event => (_ctx.handleAction(_ctx.distinguishCancelAndClose ? 'close' : 'cancel')), ["enter"]))
                    }, [
                      _hoisted_3
                    ], 32 /* HYDRATE_EVENTS */))
                  : createCommentVNode("v-if", true)
              ]))
            : createCommentVNode("v-if", true),
          createVNode("div", _hoisted_4, [
            createVNode("div", _hoisted_5, [
              (_ctx.icon && !_ctx.center && _ctx.hasMessage)
                ? (openBlock(), createBlock("div", {
                    key: 0,
                    class: ['el-message-box__status', _ctx.icon]
                  }, null, 2 /* CLASS */))
                : createCommentVNode("v-if", true),
              (_ctx.hasMessage)
                ? (openBlock(), createBlock("div", _hoisted_6, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      (!_ctx.dangerouslyUseHTMLString)
                        ? (openBlock(), createBlock("p", _hoisted_7, toDisplayString(_ctx.message), 1 /* TEXT */))
                        : (openBlock(), createBlock("p", {
                            key: 1,
                            innerHTML: _ctx.message
                          }, null, 8 /* PROPS */, ["innerHTML"]))
                    ])
                  ]))
                : createCommentVNode("v-if", true)
            ]),
            withDirectives(createVNode("div", _hoisted_8, [
              createVNode(_component_el_input, {
                ref: "input",
                modelValue: _ctx.inputValue,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => (_ctx.inputValue = $event)),
                type: _ctx.inputType,
                placeholder: _ctx.inputPlaceholder,
                class: { invalid: _ctx.validateError },
                onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
              }, null, 8 /* PROPS */, ["modelValue", "type", "placeholder", "class", "onKeydown"]),
              createVNode("div", {
                class: "el-message-box__errormsg",
                style: { visibility: !!_ctx.editorErrorMessage ? 'visible' : 'hidden' }
              }, toDisplayString(_ctx.editorErrorMessage), 5 /* TEXT, STYLE */)
            ], 512 /* NEED_PATCH */), [
              [vShow, _ctx.showInput]
            ])
          ]),
          createVNode("div", _hoisted_9, [
            (_ctx.showCancelButton)
              ? (openBlock(), createBlock(_component_el_button, {
                  key: 0,
                  loading: _ctx.cancelButtonLoading,
                  class: [ _ctx.cancelButtonClass ],
                  round: _ctx.roundButton,
                  size: "small",
                  onClick: _cache[4] || (_cache[4] = $event => (_ctx.handleAction('cancel'))),
                  onKeydown: _cache[5] || (_cache[5] = withKeys($event => (_ctx.handleAction('cancel')), ["enter"]))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t('el.messagebox.cancel')), 1 /* TEXT */)
                  ]),
                  _: 1
                }, 8 /* PROPS */, ["loading", "class", "round"]))
              : createCommentVNode("v-if", true),
            withDirectives(createVNode(_component_el_button, {
              ref: "confirm",
              loading: _ctx.confirmButtonLoading,
              class: [ _ctx.confirmButtonClasses ],
              round: _ctx.roundButton,
              disabled: _ctx.confirmButtonDisabled,
              size: "small",
              onClick: _cache[6] || (_cache[6] = $event => (_ctx.handleAction('confirm'))),
              onKeydown: _cache[7] || (_cache[7] = withKeys($event => (_ctx.handleAction('confirm')), ["enter"]))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t('el.messagebox.confirm')), 1 /* TEXT */)
              ]),
              _: 1
            }, 8 /* PROPS */, ["loading", "class", "round", "disabled"]), [
              [vShow, _ctx.showConfirmButton]
            ])
          ])
        ], 2 /* CLASS */)
      ], 8 /* PROPS */, ["aria-label"]), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  }))
}

script.render = render;
script.__file = "packages/message-box/src/index.vue";

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
const EMPTY_OBJ = (process.env.NODE_ENV !== 'production')
    ? Object.freeze({})
    : {};
const EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];

let currentMsg, instance;
const PROP_KEYS = [
    'lockScroll',
    'showClose',
    'closeOnClickModal',
    'closeOnPressEscape',
    'closeOnHashChange',
    'center',
    'roundButton',
    'closeDelay',
    'zIndex',
    'modal',
    'modalFade',
    'modalClass',
    'modalAppendToBody',
    'lockScroll',
];
const defaults = {
    title: null,
    message: '',
    type: '',
    iconClass: '',
    showInput: false,
    showClose: true,
    modalFade: true,
    lockScroll: true,
    closeOnClickModal: true,
    closeOnPressEscape: true,
    closeOnHashChange: true,
    inputValue: null,
    inputPlaceholder: '',
    inputType: 'text',
    inputPattern: null,
    inputValidator: null,
    inputErrorMessage: '',
    showConfirmButton: true,
    showCancelButton: false,
    confirmButtonPosition: 'right',
    confirmButtonHighlight: false,
    cancelButtonHighlight: false,
    confirmButtonText: '',
    cancelButtonText: '',
    confirmButtonClass: '',
    cancelButtonClass: '',
    customClass: '',
    beforeClose: null,
    dangerouslyUseHTMLString: false,
    center: false,
    roundButton: false,
    distinguishCancelAndClose: false,
};
let msgQueue = [];
const defaultCallback = (action, ctx) => {
    if (currentMsg) {
        const callback = currentMsg.callback;
        if (typeof callback === 'function') {
            if (ctx.showInput) {
                callback(ctx.inputValue, action);
            }
            else {
                callback(action);
            }
        }
        if (currentMsg.resolve) {
            if (action === 'confirm') {
                if (ctx.showInput) {
                    currentMsg.resolve({ value: ctx.inputValue, action });
                }
                else {
                    currentMsg.resolve(action);
                }
            }
            else if (currentMsg.reject && (action === 'cancel' || action === 'close')) {
                currentMsg.reject(action);
            }
        }
    }
};
const initInstance = () => {
    const container = document.createElement('div');
    const vnode = createVNode(script);
    render$1(vnode, container);
    instance = vnode.component;
};
const showNextMsg = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!instance) {
        initInstance();
    }
    if (instance && instance.setupInstall.state.visible) {
        return;
    }
    if (msgQueue.length > 0) {
        const props = {};
        const state = {};
        currentMsg = msgQueue.shift();
        const options = currentMsg.options;
        Object.keys(options).forEach(key => {
            if (PROP_KEYS.includes(key)) {
                props[key] = options[key];
            }
            else {
                state[key] = options[key];
            }
        });
        const vmProps = instance.props;
        for (const prop in props) {
            if (props.hasOwnProperty(prop)) {
                vmProps[prop] = props[prop];
            }
        }
        const vmState = instance.setupInstall.state;
        vmState.action = '';
        if (options.callback === undefined) {
            options.callback = defaultCallback;
        }
        for (const prop in state) {
            if (state.hasOwnProperty(prop)) {
                vmState[prop] = state[prop];
            }
        }
        if (isVNode(options.message)) {
            instance.slots.default = () => [options.message];
        }
        const oldCb = options.callback;
        vmState.callback = (action, inst) => {
            oldCb(action, inst);
            showNextMsg();
        };
        document.body.appendChild(instance.vnode.el);
        vmState.visible = true;
    }
});
const MessageBox = function (options, callback) {
    if (isServer)
        return;
    if (typeof options === 'string' || isVNode(options)) {
        options = {
            message: options,
        };
        if (typeof callback === 'string') {
            options.title = callback;
        }
    }
    else if (options.callback && !callback) {
        callback = options.callback;
    }
    if (typeof Promise !== 'undefined') {
        return new Promise((resolve, reject) => {
            msgQueue.push({
                options: Object.assign({}, defaults, options),
                callback: callback,
                resolve: resolve,
                reject: reject,
            });
            showNextMsg();
        });
    }
    else {
        msgQueue.push({
            options: Object.assign({}, defaults, options),
            callback: callback,
        });
        showNextMsg();
    }
};
MessageBox.alert = (message, title, options) => {
    if (typeof title === 'object') {
        options = title;
        title = '';
    }
    else if (title === undefined) {
        title = '';
    }
    return MessageBox(Object.assign({
        title: title,
        message: message,
        type$: 'alert',
        closeOnPressEscape: false,
        closeOnClickModal: false,
    }, options));
};
MessageBox.confirm = (message, title, options) => {
    if (typeof title === 'object') {
        options = title;
        title = '';
    }
    else if (title === undefined) {
        title = '';
    }
    return MessageBox(Object.assign({
        title: title,
        message: message,
        type$: 'confirm',
        showCancelButton: true,
    }, options));
};
MessageBox.prompt = (message, title, options) => {
    if (typeof title === 'object') {
        options = title;
        title = '';
    }
    else if (title === undefined) {
        title = '';
    }
    return MessageBox(Object.assign({
        title: title,
        message: message,
        showCancelButton: true,
        showInput: true,
        type$: 'prompt',
    }, options));
};
MessageBox.close = () => {
    instance.setupInstall.doClose();
    instance.setupInstall.state.visible = false;
    msgQueue = [];
    currentMsg = null;
};

MessageBox.install = (app) => {
    app.config.globalProperties.$msgbox = MessageBox;
    app.config.globalProperties.$messageBox = MessageBox;
    app.config.globalProperties.$alert = MessageBox.alert;
    app.config.globalProperties.$confirm = MessageBox.confirm;
    app.config.globalProperties.$prompt = MessageBox.prompt;
};

export default MessageBox;
