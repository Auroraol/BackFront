import mitt from 'mitt';
import { inject, computed, defineComponent, reactive, ref, getCurrentInstance, provide, onBeforeMount, onMounted, onBeforeUnmount, resolveComponent, openBlock, createBlock, withCtx, createVNode, Transition, withDirectives, renderSlot, vShow, createCommentVNode } from 'vue';
import ElCollapseTransition from '../el-collapse-transition';
import ElPopper from '../el-popper';

function useMenu(instance, currentIndex) {
    const rootMenu = inject('rootMenu');
    const indexPath = computed(() => {
        let parent = instance.parent;
        const path = [currentIndex];
        while (parent.type.name !== 'ElMenu') {
            if (parent.props.index) {
                path.unshift(parent.props.index);
            }
            parent = parent.parent;
        }
        return path;
    });
    const parentMenu = computed(() => {
        let parent = instance.parent;
        while (parent && ['ElMenu', 'ElSubmenu'].indexOf(parent.type.name) === -1) {
            parent = parent.parent;
        }
        return parent;
    });
    const paddingStyle = computed(() => {
        let parent = instance.parent;
        if (rootMenu.props.mode !== 'vertical')
            return {};
        let padding = 20;
        if (rootMenu.props.collapse) {
            padding = 20;
        }
        else {
            while (parent && parent.type.name !== 'ElMenu') {
                if (parent.type.name === 'ElSubmenu') {
                    padding += 20;
                }
                parent = parent.parent;
            }
        }
        return { paddingLeft: padding + 'px' };
    });
    return { parentMenu, paddingStyle, indexPath };
}

var script = defineComponent({
    name: 'ElSubmenu',
    componentName: 'ElSubmenu',
    components: { ElCollapseTransition, ElPopper },
    props: {
        index: {
            type: String,
            required: true,
        },
        showTimeout: {
            type: Number,
            default: 300,
        },
        hideTimeout: {
            type: Number,
            default: 300,
        },
        popperClass: String,
        disabled: Boolean,
        popperAppendToBody: {
            type: Boolean,
            default: undefined,
        },
    },
    setup(props) {
        const data = reactive({
            popperJS: null,
            timeout: null,
            items: {},
            submenus: {},
            currentPlacement: '',
            mouseInChild: false,
            opened: false,
        });
        const verticalTitleRef = ref(null);
        const popperVnode = ref(null);
        const instance = getCurrentInstance();
        const { paddingStyle, indexPath, parentMenu } = useMenu(instance, props.index);
        const { openedMenus, isMenuPopup, hoverBackground: rootHoverBackground, methods: rootMethods, props: rootProps, methods: { closeMenu }, rootMenuOn, rootMenuEmit, } = inject('rootMenu');
        const { addSubMenu: parentAddSubmenu, removeSubMenu: parentRemoveSubmenu, handleMouseleave: parentHandleMouseleave, } = inject(`subMenu:${parentMenu.value.uid}`);
        const submenuTitleIcon = computed(() => {
            return (mode.value === 'horizontal' && isFirstLevel.value) ||
                (mode.value === 'vertical' && !rootProps.collapse)
                ? 'el-icon-arrow-down'
                : 'el-icon-arrow-right';
        });
        const isFirstLevel = computed(() => {
            let isFirstLevel = true;
            let parent = instance.parent;
            while (parent && parent.type.name !== 'ElMenu') {
                if (['ElSubmenu', 'ElMenuItemGroup'].includes(parent.type.name)) {
                    isFirstLevel = false;
                    break;
                }
                else {
                    parent = parent.parent;
                }
            }
            return isFirstLevel;
        });
        const appendToBody = computed(() => {
            return props.popperAppendToBody === undefined
                ? isFirstLevel.value
                : Boolean(props.popperAppendToBody);
        });
        const menuTransitionName = computed(() => {
            return rootProps.collapse ? 'el-zoom-in-left' : 'el-zoom-in-top';
        });
        const opened = computed(() => {
            return openedMenus.value.includes(props.index);
        });
        const active = computed(() => {
            let isActive = false;
            const submenus = data.submenus;
            const items = data.items;
            Object.keys(items).forEach(index => {
                if (items[index].active) {
                    isActive = true;
                }
            });
            Object.keys(submenus).forEach(index => {
                if (submenus[index].active) {
                    isActive = true;
                }
            });
            return isActive;
        });
        const backgroundColor = computed(() => {
            return rootProps.backgroundColor || '';
        });
        const activeTextColor = computed(() => {
            return rootProps.activeTextColor || '';
        });
        const textColor = computed(() => {
            return rootProps.textColor || '';
        });
        const mode = computed(() => {
            return rootProps.mode;
        });
        const titleStyle = computed(() => {
            if (mode.value !== 'horizontal') {
                return {
                    color: textColor.value,
                };
            }
            return {
                borderBottomColor: active.value
                    ? rootProps.activeTextColor
                        ? activeTextColor.value
                        : ''
                    : 'transparent',
                color: active.value ? activeTextColor.value : textColor.value,
            };
        });
        const subMenuEmitter = mitt();
        const doDestroy = () => {
            var _a;
            (_a = popperVnode.value) === null || _a === void 0 ? void 0 : _a.doDestroy();
        };
        const handleCollapseToggle = value => {
            if (value) {
                updatePlacement();
            }
            else {
                doDestroy();
            }
        };
        const addItem = item => {
            data.items[item.index] = item;
        };
        const removeItem = item => {
            delete data.items[item.index];
        };
        const addSubMenu = item => {
            data.submenus[item.index] = item;
        };
        const removeSubMenu = item => {
            delete data.submenus[item.index];
        };
        const handleClick = () => {
            const disabled = props.disabled;
            if ((rootProps.menuTrigger === 'hover' &&
                rootProps.mode === 'horizontal') ||
                (rootProps.collapse && rootProps.mode === 'vertical') ||
                disabled) {
                return;
            }
            rootMenuEmit('submenu:submenu-click', { index: props.index, indexPath });
        };
        const handleMouseenter = (event, showTimeout = props.showTimeout) => {
            if (!('ActiveXObject' in window) &&
                event.type === 'focus' &&
                !event.relatedTarget) {
                return;
            }
            const disabled = props.disabled;
            if ((rootProps.menuTrigger === 'click' &&
                rootProps.mode === 'horizontal') ||
                (!rootProps.collapse && rootProps.mode === 'vertical') ||
                disabled) {
                return;
            }
            subMenuEmitter.emit('submenu:mouse-enter-child');
            clearTimeout(data.timeout);
            data.timeout = setTimeout(() => {
                rootMethods.openMenu(props.index, indexPath);
            }, showTimeout);
            if (appendToBody.value) {
                parentMenu.value.vnode.el.dispatchEvent(new MouseEvent('mouseenter'));
            }
        };
        const handleMouseleave = (deepDispatch = false) => {
            if ((rootProps.menuTrigger === 'click' &&
                rootProps.mode === 'horizontal') ||
                (!rootProps.collapse && rootProps.mode === 'vertical')) {
                return;
            }
            subMenuEmitter.emit('submenu:mouse-leave-child');
            clearTimeout(data.timeout);
            data.timeout = setTimeout(() => {
                !data.mouseInChild && closeMenu(props.index);
            }, props.hideTimeout);
            if (appendToBody.value && deepDispatch) {
                if (instance.parent.type.name === 'ElSubmenu') {
                    parentHandleMouseleave(true);
                }
            }
        };
        const handleTitleMouseenter = () => {
            var _a;
            if (mode.value === 'horizontal' && !rootProps.backgroundColor)
                return;
            const title = ((_a = popperVnode.value) === null || _a === void 0 ? void 0 : _a.triggerRef) || verticalTitleRef.value;
            title && (title.style.backgroundColor = rootHoverBackground.value);
        };
        const handleTitleMouseleave = () => {
            var _a;
            if (mode.value === 'horizontal' && !rootProps.backgroundColor)
                return;
            const title = ((_a = popperVnode.value) === null || _a === void 0 ? void 0 : _a.triggerRef) || verticalTitleRef.value;
            title && (title.style.backgroundColor = rootProps.backgroundColor || '');
        };
        const updatePlacement = () => {
            data.currentPlacement =
                mode.value === 'horizontal' && isFirstLevel.value
                    ? 'bottom-start'
                    : 'right-start';
        };
        provide(`subMenu:${instance.uid}`, {
            addSubMenu,
            removeSubMenu,
            handleMouseleave,
        });
        onBeforeMount(() => {
            rootMenuOn('rootMenu:toggle-collapse', (val) => {
                handleCollapseToggle(val);
            });
            subMenuEmitter.on('submenu:mouse-enter-child', () => {
                data.mouseInChild = true;
                clearTimeout(data.timeout);
            });
            subMenuEmitter.on('submenu:mouse-leave-child', () => {
                data.mouseInChild = false;
                clearTimeout(data.timeout);
            });
        });
        onMounted(() => {
            rootMethods.addSubMenu({
                index: props.index,
                indexPath,
                active,
            });
            parentAddSubmenu({
                index: props.index,
                indexPath,
                active,
            });
            updatePlacement();
        });
        onBeforeUnmount(() => {
            parentRemoveSubmenu({
                index: props.index,
                indexPath,
                active,
            });
            rootMethods.removeSubMenu({
                index: props.index,
                indexPath,
                active,
            });
        });
        return {
            data,
            props,
            mode,
            active,
            isMenuPopup,
            opened,
            paddingStyle,
            titleStyle,
            backgroundColor,
            rootProps,
            menuTransitionName,
            submenuTitleIcon,
            appendToBody,
            handleClick,
            handleMouseenter,
            handleMouseleave,
            handleTitleMouseenter,
            handleTitleMouseleave,
            addItem,
            removeItem,
            addSubMenu,
            removeSubMenu,
            popperVnode,
            verticalTitleRef,
        };
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popper = resolveComponent("el-popper");
  const _component_el_collapse_transition = resolveComponent("el-collapse-transition");

  return (openBlock(), createBlock("li", {
    class: [
      'el-submenu',
      _ctx.active && 'is-active',
      _ctx.opened && 'is-opened',
      _ctx.disabled && 'is-disabled',
    ],
    role: "menuitem",
    "aria-haspopup": "true",
    "aria-expanded": "opened",
    onMouseenter: _cache[11] || (_cache[11] = (...args) => (_ctx.handleMouseenter(...args))),
    onMouseleave: _cache[12] || (_cache[12] = () => _ctx.handleMouseleave(false)),
    onFocus: _cache[13] || (_cache[13] = (...args) => (_ctx.handleMouseenter(...args)))
  }, [
    (_ctx.isMenuPopup)
      ? (openBlock(), createBlock(_component_el_popper, {
          key: 0,
          ref: "popperVnode",
          visible: _ctx.opened,
          "onUpdate:visible": _cache[7] || (_cache[7] = $event => (_ctx.opened = $event)),
          "manual-mode": true,
          effect: "light",
          pure: true,
          offset: 6,
          "show-arrow": false,
          "popper-class": _ctx.props.popperClass,
          placement: _ctx.data.currentPlacement,
          "append-to-body": _ctx.appendToBody
        }, {
          default: withCtx(() => [
            createVNode(Transition, { name: _ctx.menuTransitionName }, {
              default: withCtx(() => [
                withDirectives(createVNode("div", {
                  ref: "menu",
                  class: [`el-menu--${_ctx.mode}`, _ctx.props.popperClass],
                  onMouseenter: _cache[1] || (_cache[1] = $event => _ctx.handleMouseenter($event, 100)),
                  onMouseleave: _cache[2] || (_cache[2] = () => _ctx.handleMouseleave(true)),
                  onFocus: _cache[3] || (_cache[3] = $event => _ctx.handleMouseenter($event, 100))
                }, [
                  createVNode("ul", {
                    role: "menu",
                    class: [
                'el-menu el-menu--popup',
                `el-menu--popup-${_ctx.data.currentPlacement}`,
              ],
                    style: { backgroundColor: _ctx.rootProps.backgroundColor || '' }
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 6 /* CLASS, STYLE */)
                ], 34 /* CLASS, HYDRATE_EVENTS */), [
                  [vShow, _ctx.opened]
                ])
              ]),
              _: 3
            }, 8 /* PROPS */, ["name"])
          ]),
          trigger: withCtx(() => [
            createVNode("div", {
              class: "el-submenu__title",
              style: [_ctx.paddingStyle, _ctx.titleStyle, { backgroundColor: _ctx.backgroundColor }],
              onClick: _cache[4] || (_cache[4] = (...args) => (_ctx.handleClick(...args))),
              onMouseenter: _cache[5] || (_cache[5] = (...args) => (_ctx.handleTitleMouseenter(...args))),
              onMouseleave: _cache[6] || (_cache[6] = (...args) => (_ctx.handleTitleMouseleave(...args)))
            }, [
              renderSlot(_ctx.$slots, "title"),
              createVNode("i", {
                class: ['el-submenu__icon-arrow', _ctx.submenuTitleIcon]
              }, null, 2 /* CLASS */)
            ], 36 /* STYLE, HYDRATE_EVENTS */)
          ]),
          _: 1
        }, 8 /* PROPS */, ["visible", "popper-class", "placement", "append-to-body"]))
      : createCommentVNode("v-if", true),
    (!_ctx.isMenuPopup)
      ? (openBlock(), createBlock("div", {
          key: 1,
          ref: "verticalTitleRef",
          class: "el-submenu__title",
          style: [_ctx.paddingStyle, _ctx.titleStyle, { backgroundColor: _ctx.backgroundColor }],
          onClick: _cache[8] || (_cache[8] = (...args) => (_ctx.handleClick(...args))),
          onMouseenter: _cache[9] || (_cache[9] = (...args) => (_ctx.handleTitleMouseenter(...args))),
          onMouseleave: _cache[10] || (_cache[10] = (...args) => (_ctx.handleTitleMouseleave(...args)))
        }, [
          renderSlot(_ctx.$slots, "title"),
          createVNode("i", {
            class: ['el-submenu__icon-arrow', _ctx.submenuTitleIcon]
          }, null, 2 /* CLASS */)
        ], 36 /* STYLE, HYDRATE_EVENTS */))
      : createCommentVNode("v-if", true),
    (!_ctx.isMenuPopup)
      ? (openBlock(), createBlock(_component_el_collapse_transition, { key: 2 }, {
          default: withCtx(() => [
            withDirectives(createVNode("ul", {
              role: "menu",
              class: "el-menu el-menu--inline",
              style: { backgroundColor: _ctx.rootProps.backgroundColor || '' }
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 4 /* STYLE */), [
              [vShow, _ctx.opened]
            ])
          ]),
          _: 3
        }))
      : createCommentVNode("v-if", true)
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script.render = render;
script.__file = "packages/menu/src/submenu.vue";

script.install = (app) => {
    app.component(script.name, script);
};
const _Submenu = script;

export default _Submenu;
