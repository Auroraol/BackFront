import { defineComponent, ref, computed, watch, nextTick, onMounted, openBlock, createBlock, Transition, withCtx, createVNode, createCommentVNode, Fragment, renderList, withDirectives, vShow, onBeforeUnmount, resolveComponent, renderSlot, toDisplayString, mergeProps } from 'vue';
import throttle from 'lodash/throttle';
import { useAttrs } from '../hooks';
import isServer from '../utils/isServer';
import { on, off, getScrollContainer, isInContainer } from '../utils/dom';
import { t } from '../locale';
import { isFirefox, rafThrottle } from '../utils/util';
import { EVENT_CODE } from '../utils/aria';

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
const EMPTY_OBJ = (process.env.NODE_ENV !== 'production')
    ? Object.freeze({})
    : {};
const EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];
const isString = (val) => typeof val === 'string';

const Mode = {
    CONTAIN: {
        name: 'contain',
        icon: 'el-icon-full-screen',
    },
    ORIGINAL: {
        name: 'original',
        icon: 'el-icon-c-scale-to-original',
    },
};
const mousewheelEventName = isFirefox() ? 'DOMMouseScroll' : 'mousewheel';
var script = defineComponent({
    name: 'ElImageViewer',
    props: {
        urlList: {
            type: Array,
            default: () => [],
        },
        zIndex: {
            type: Number,
            default: 2000,
        },
        onSwitch: {
            type: Function,
            default: () => ({}),
        },
        onClose: {
            type: Function,
            default: () => ({}),
        },
        initialIndex: {
            type: Number,
            default: 0,
        },
    },
    setup(props) {
        let _keyDownHandler = null;
        let _mouseWheelHandler = null;
        let _dragHandler = null;
        const loading = ref(true);
        const index = ref(props.initialIndex);
        const infinite = ref(true);
        const wrapper = ref(null);
        const img = ref(null);
        const mode = ref(Mode.CONTAIN);
        let transform = ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false,
        });
        const isSingle = computed(() => {
            const { urlList } = props;
            return urlList.length <= 1;
        });
        const isFirst = computed(() => {
            return index.value === 0;
        });
        const isLast = computed(() => {
            return index.value === 0;
        });
        const currentImg = computed(() => {
            return props.urlList[index.value];
        });
        const imgStyle = computed(() => {
            const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
            const style = {
                transform: `scale(${scale}) rotate(${deg}deg)`,
                transition: enableTransition ? 'transform .3s' : '',
                'margin-left': `${offsetX}px`,
                'margin-top': `${offsetY}px`,
            };
            if (mode.value.name === Mode.CONTAIN.name) {
                style.maxWidth = style.maxHeight = '100%';
            }
            return style;
        });
        function hide() {
            deviceSupportUninstall();
            props.onClose();
        }
        function deviceSupportInstall() {
            _keyDownHandler = rafThrottle(e => {
                switch (e.code) {
                    case EVENT_CODE.esc:
                        hide();
                        break;
                    case EVENT_CODE.space:
                        toggleMode();
                        break;
                    case EVENT_CODE.left:
                        prev();
                        break;
                    case EVENT_CODE.up:
                        handleActions('zoomIn');
                        break;
                    case EVENT_CODE.right:
                        next();
                        break;
                    case EVENT_CODE.down:
                        handleActions('zoomOut');
                        break;
                }
            });
            _mouseWheelHandler = rafThrottle(e => {
                const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
                if (delta > 0) {
                    handleActions('zoomIn', {
                        zoomRate: 0.015,
                        enableTransition: false,
                    });
                }
                else {
                    handleActions('zoomOut', {
                        zoomRate: 0.015,
                        enableTransition: false,
                    });
                }
            });
            on(document, 'keydown', _keyDownHandler);
            on(document, mousewheelEventName, _mouseWheelHandler);
        }
        function deviceSupportUninstall() {
            off(document, 'keydown', _keyDownHandler);
            off(document, mousewheelEventName, _mouseWheelHandler);
            _keyDownHandler = null;
            _mouseWheelHandler = null;
        }
        function handleImgLoad() {
            loading.value = false;
        }
        function handleImgError(e) {
            loading.value = false;
            e.target.alt = t('el.image.error');
        }
        function handleMouseDown(e) {
            if (loading.value || e.button !== 0)
                return;
            const { offsetX, offsetY } = transform.value;
            const startX = e.pageX;
            const startY = e.pageY;
            _dragHandler = rafThrottle(ev => {
                transform.value = Object.assign(Object.assign({}, transform.value), { offsetX: offsetX + ev.pageX - startX, offsetY: offsetY + ev.pageY - startY });
            });
            on(document, 'mousemove', _dragHandler);
            on(document, 'mouseup', () => {
                off(document, 'mousemove', _dragHandler);
            });
            e.preventDefault();
        }
        function reset() {
            transform.value = {
                scale: 1,
                deg: 0,
                offsetX: 0,
                offsetY: 0,
                enableTransition: false,
            };
        }
        function toggleMode() {
            if (loading.value)
                return;
            const modeNames = Object.keys(Mode);
            const modeValues = Object.values(Mode);
            const currentMode = mode.value.name;
            const index = modeValues.findIndex(i => i.name === currentMode);
            const nextIndex = (index + 1) % modeNames.length;
            mode.value = Mode[modeNames[nextIndex]];
            reset();
        }
        function prev() {
            if (isFirst.value && !infinite.value)
                return;
            const len = props.urlList.length;
            index.value = (index.value - 1 + len) % len;
        }
        function next() {
            if (isLast.value && !infinite.value)
                return;
            const len = props.urlList.length;
            index.value = (index.value + 1) % len;
        }
        function handleActions(action, options = {}) {
            if (loading.value)
                return;
            const { zoomRate, rotateDeg, enableTransition } = Object.assign({ zoomRate: 0.2, rotateDeg: 90, enableTransition: true }, options);
            switch (action) {
                case 'zoomOut':
                    if (transform.value.scale > 0.2) {
                        transform.value.scale = parseFloat((transform.value.scale - zoomRate).toFixed(3));
                    }
                    break;
                case 'zoomIn':
                    transform.value.scale = parseFloat((transform.value.scale + zoomRate).toFixed(3));
                    break;
                case 'clocelise':
                    transform.value.deg += rotateDeg;
                    break;
                case 'anticlocelise':
                    transform.value.deg -= rotateDeg;
                    break;
            }
            transform.value.enableTransition = enableTransition;
        }
        watch(currentImg, () => {
            nextTick(() => {
                const $img = img.value;
                if (!$img.complete) {
                    loading.value = true;
                }
            });
        });
        watch(index, val => {
            reset();
            props.onSwitch(val);
        });
        onMounted(() => {
            var _a;
            deviceSupportInstall();
            (_a = wrapper.value) === null || _a === void 0 ? void 0 : _a.focus();
        });
        return {
            index,
            wrapper,
            img,
            infinite: true,
            loading: false,
            isSingle,
            isFirst,
            isLast,
            currentImg,
            imgStyle,
            mode,
            handleActions,
            prev,
            next,
            hide,
            toggleMode,
            handleImgLoad,
            handleImgError,
            handleMouseDown,
        };
    },
});

const _hoisted_1 = /*#__PURE__*/createVNode("div", { class: "el-image-viewer__mask" }, null, -1 /* HOISTED */);
const _hoisted_2 = /*#__PURE__*/createVNode("i", { class: "el-icon-circle-close" }, null, -1 /* HOISTED */);
const _hoisted_3 = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-left" }, null, -1 /* HOISTED */);
const _hoisted_4 = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-right" }, null, -1 /* HOISTED */);
const _hoisted_5 = { class: "el-image-viewer__btn el-image-viewer__actions" };
const _hoisted_6 = { class: "el-image-viewer__actions__inner" };
const _hoisted_7 = /*#__PURE__*/createVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1 /* HOISTED */);
const _hoisted_8 = /*#__PURE__*/createVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1 /* HOISTED */);
const _hoisted_9 = { class: "el-image-viewer__canvas" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, { name: "viewer-fade" }, {
    default: withCtx(() => [
      createVNode("div", {
        ref: "wrapper",
        tabindex: "-1",
        class: "el-image-viewer__wrapper",
        style: { 'z-index': _ctx.zIndex }
      }, [
        _hoisted_1,
        createCommentVNode(" CLOSE "),
        createVNode("span", {
          class: "el-image-viewer__btn el-image-viewer__close",
          onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.hide(...args)))
        }, [
          _hoisted_2
        ]),
        createCommentVNode(" ARROW "),
        (!_ctx.isSingle)
          ? (openBlock(), createBlock(Fragment, { key: 0 }, [
              createVNode("span", {
                class: ["el-image-viewer__btn el-image-viewer__prev", { 'is-disabled': !_ctx.infinite && _ctx.isFirst }],
                onClick: _cache[2] || (_cache[2] = (...args) => (_ctx.prev(...args)))
              }, [
                _hoisted_3
              ], 2 /* CLASS */),
              createVNode("span", {
                class: ["el-image-viewer__btn el-image-viewer__next", { 'is-disabled': !_ctx.infinite && _ctx.isLast }],
                onClick: _cache[3] || (_cache[3] = (...args) => (_ctx.next(...args)))
              }, [
                _hoisted_4
              ], 2 /* CLASS */)
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" ACTIONS "),
        createVNode("div", _hoisted_5, [
          createVNode("div", _hoisted_6, [
            createVNode("i", {
              class: "el-icon-zoom-out",
              onClick: _cache[4] || (_cache[4] = $event => (_ctx.handleActions('zoomOut')))
            }),
            createVNode("i", {
              class: "el-icon-zoom-in",
              onClick: _cache[5] || (_cache[5] = $event => (_ctx.handleActions('zoomIn')))
            }),
            _hoisted_7,
            createVNode("i", {
              class: _ctx.mode.icon,
              onClick: _cache[6] || (_cache[6] = (...args) => (_ctx.toggleMode(...args)))
            }, null, 2 /* CLASS */),
            _hoisted_8,
            createVNode("i", {
              class: "el-icon-refresh-left",
              onClick: _cache[7] || (_cache[7] = $event => (_ctx.handleActions('anticlocelise')))
            }),
            createVNode("i", {
              class: "el-icon-refresh-right",
              onClick: _cache[8] || (_cache[8] = $event => (_ctx.handleActions('clocelise')))
            })
          ])
        ]),
        createCommentVNode(" CANVAS "),
        createVNode("div", _hoisted_9, [
          (openBlock(true), createBlock(Fragment, null, renderList(_ctx.urlList, (url, i) => {
            return withDirectives((openBlock(), createBlock("img", {
              ref: "img",
              key: url,
              src: _ctx.currentImg,
              style: _ctx.imgStyle,
              class: "el-image-viewer__img",
              onLoad: _cache[9] || (_cache[9] = (...args) => (_ctx.handleImgLoad(...args))),
              onError: _cache[10] || (_cache[10] = (...args) => (_ctx.handleImgError(...args))),
              onMousedown: _cache[11] || (_cache[11] = (...args) => (_ctx.handleMouseDown(...args)))
            }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, ["src"])), [
              [vShow, i === _ctx.index]
            ])
          }), 128 /* KEYED_FRAGMENT */))
        ])
      ], 4 /* STYLE */)
    ]),
    _: 1
  }))
}

script.render = render;
script.__file = "packages/image/src/image-viewer.vue";

const isSupportObjectFit = () => document.documentElement.style.objectFit !== undefined;
const isHtmlEle = e => e && e.nodeType === 1;
const ObjectFit = {
    NONE: 'none',
    CONTAIN: 'contain',
    COVER: 'cover',
    FILL: 'fill',
    SCALE_DOWN: 'scale-down',
};
let prevOverflow = '';
var script$1 = defineComponent({
    name: 'ElImage',
    components: {
        ImageViewer: script,
    },
    inheritAttrs: false,
    props: {
        src: {
            type: String,
            default: '',
        },
        fit: {
            type: String,
            default: '',
        },
        lazy: {
            type: Boolean,
            default: false,
        },
        scrollContainer: {
            type: [String, Object],
            default: null,
        },
        previewSrcList: {
            type: Array,
            default: () => [],
        },
        zIndex: {
            type: Number,
            default: 2000,
        },
    },
    emits: ['error'],
    setup(props, { emit }) {
        const attrs = useAttrs();
        const hasLoadError = ref(false);
        const loading = ref(true);
        const imgWidth = ref(0);
        const imgHeight = ref(0);
        const showViewer = ref(false);
        const container = ref(null);
        let _scrollContainer = null;
        let _lazyLoadHandler = null;
        const imageStyle = computed(() => {
            const { fit } = props;
            if (!isServer && fit) {
                return isSupportObjectFit()
                    ? { 'object-fit': fit }
                    : getImageStyle(fit);
            }
            return {};
        });
        const alignCenter = computed(() => {
            const { fit } = props;
            return !isServer && !isSupportObjectFit() && fit !== ObjectFit.FILL;
        });
        const preview = computed(() => {
            const { previewSrcList } = props;
            return Array.isArray(previewSrcList) && previewSrcList.length > 0;
        });
        const imageIndex = computed(() => {
            const { src, previewSrcList } = props;
            let previewIndex = 0;
            const srcIndex = previewSrcList.indexOf(src);
            if (srcIndex >= 0) {
                previewIndex = srcIndex;
            }
            return previewIndex;
        });
        function getImageStyle(fit) {
            const imageWidth = imgWidth.value;
            const imageHeight = imgHeight.value;
            if (!container.value)
                return {};
            const { clientWidth: containerWidth, clientHeight: containerHeight, } = container.value;
            if (!imageWidth || !imageHeight || !containerWidth || !containerHeight)
                return {};
            const vertical = imageWidth / imageHeight < 1;
            if (fit === ObjectFit.SCALE_DOWN) {
                const isSmaller = imageWidth < containerWidth && imageHeight < containerHeight;
                fit = isSmaller ? ObjectFit.NONE : ObjectFit.CONTAIN;
            }
            switch (fit) {
                case ObjectFit.NONE:
                    return { width: 'auto', height: 'auto' };
                case ObjectFit.CONTAIN:
                    return vertical ? { width: 'auto' } : { height: 'auto' };
                case ObjectFit.COVER:
                    return vertical ? { height: 'auto' } : { width: 'auto' };
                default:
                    return {};
            }
        }
        const loadImage = () => {
            if (isServer)
                return;
            const attributes = attrs.value;
            loading.value = true;
            hasLoadError.value = false;
            const img = new Image();
            img.onload = e => handleLoad(e, img);
            img.onerror = handleError;
            Object.keys(attributes)
                .forEach(key => {
                const value = attributes[key];
                img.setAttribute(key, value);
            });
            img.src = props.src;
        };
        function handleLoad(e, img) {
            imgWidth.value = img.width;
            imgHeight.value = img.height;
            loading.value = false;
            hasLoadError.value = false;
        }
        function handleError(e) {
            loading.value = false;
            hasLoadError.value = true;
            emit('error', e);
        }
        function handleLazyLoad() {
            if (isInContainer(container.value, _scrollContainer)) {
                loadImage();
                removeLazyLoadListener();
            }
        }
        function addLazyLoadListener() {
            if (isServer)
                return;
            const { scrollContainer } = props;
            if (isHtmlEle(scrollContainer)) {
                _scrollContainer = scrollContainer;
            }
            else if (isString(scrollContainer) && scrollContainer !== '') {
                _scrollContainer = document.querySelector(scrollContainer);
            }
            else {
                _scrollContainer = getScrollContainer(container.value);
            }
            if (_scrollContainer) {
                _lazyLoadHandler = throttle(handleLazyLoad, 200);
                on(_scrollContainer, 'scroll', _lazyLoadHandler);
                setTimeout(() => handleLazyLoad(), 100);
            }
        }
        function removeLazyLoadListener() {
            if (isServer || !_scrollContainer || !_lazyLoadHandler)
                return;
            off(_scrollContainer, 'scroll', _lazyLoadHandler);
            _scrollContainer = null;
            _lazyLoadHandler = null;
        }
        function clickHandler() {
            if (!preview.value) {
                return;
            }
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = 'hidden';
            showViewer.value = true;
        }
        function closeViewer() {
            document.body.style.overflow = prevOverflow;
            showViewer.value = false;
        }
        watch(() => props.src, () => {
            loadImage();
        });
        onMounted(() => {
            if (props.lazy) {
                nextTick(addLazyLoadListener);
            }
            else {
                loadImage();
            }
        });
        onBeforeUnmount(() => {
            props.lazy && removeLazyLoadListener();
        });
        return {
            attrs,
            loading,
            hasLoadError,
            showViewer,
            imgWidth,
            imgHeight,
            imageStyle,
            alignCenter,
            preview,
            imageIndex,
            clickHandler,
            closeViewer,
            container,
            handleError,
            t,
        };
    },
});

const _hoisted_1$1 = /*#__PURE__*/createVNode("div", { class: "el-image__placeholder" }, null, -1 /* HOISTED */);
const _hoisted_2$1 = { class: "el-image__error" };

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_image_viewer = resolveComponent("image-viewer");

  return (openBlock(), createBlock("div", {
    ref: "container",
    class: ['el-image', _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, [
    (_ctx.loading)
      ? renderSlot(_ctx.$slots, "placeholder", { key: 0 }, () => [
          _hoisted_1$1
        ])
      : (_ctx.hasLoadError)
        ? renderSlot(_ctx.$slots, "error", { key: 1 }, () => [
            createVNode("div", _hoisted_2$1, toDisplayString(_ctx.t('el.image.error')), 1 /* TEXT */)
          ])
        : (openBlock(), createBlock("img", mergeProps({
            key: 2,
            class: "el-image__inner"
          }, _ctx.attrs, {
            src: _ctx.src,
            style: _ctx.imageStyle,
            class: { 'el-image__inner--center': _ctx.alignCenter, 'el-image__preview': _ctx.preview },
            onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.clickHandler(...args)))
          }), null, 16 /* FULL_PROPS */, ["src"])),
    (_ctx.preview)
      ? (openBlock(), createBlock(Fragment, { key: 3 }, [
          (_ctx.showViewer)
            ? (openBlock(), createBlock(_component_image_viewer, {
                key: 0,
                "z-index": _ctx.zIndex,
                "initial-index": _ctx.imageIndex,
                "on-close": _ctx.closeViewer,
                "url-list": _ctx.previewSrcList
              }, null, 8 /* PROPS */, ["z-index", "initial-index", "on-close", "url-list"]))
            : createCommentVNode("v-if", true)
        ], 64 /* STABLE_FRAGMENT */))
      : createCommentVNode("v-if", true)
  ], 6 /* CLASS, STYLE */))
}

script$1.render = render$1;
script$1.__file = "packages/image/src/index.vue";

script$1.install = (app) => {
    app.component(script$1.name, script$1);
};
const _Image = script$1;

export default _Image;
