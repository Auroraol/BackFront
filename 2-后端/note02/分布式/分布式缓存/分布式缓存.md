#  缓存介绍

系统的性能指标一般包括响应时间、延迟时间、吞吐量，并发用户数和资源利用率等。在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。

缓存常用语：
数据不一致性、缓存更新机制、缓存可用性、缓存服务降级、缓存预热、缓存穿透

推荐使用项目: [xiaolyuh/layering-cache: 为监控而生的分布式多级缓存框架 (github.com)](https://github.com/xiaolyuh/layering-cache)

具体使用见官方文档

# Redis序列化方式对比

[Redis序列化同一个User对象对比](https://github.com/xiaolyuh/layering-cache/wiki/Redis序列化方式对比)

|            | size   | serialize(get 10W次) | deserialize(set 10W次) | serialize(cpu) | deserialize(cpu) |
| ---------- | ------ | -------------------- | ---------------------- | -------------- | ---------------- |
| Kryo       | 273 b  | 82919 ms             | 90917 ms               | 8%             | 12%              |
| FastJson   | 329 b  | 15405 ms             | 18886 ms               | 12%            | 13%              |
| Jackson    | 473 b  | 16066 ms             | 16140 ms               | 15%            | 14%              |
| Jdk        | 1036 b | 17344 ms             | 24917 ms               | 14%            | 13%              |
| Protostuff | 282 b  | 14295 ms             | 14355 ms               | 15%            | 13%              |

# 文档

xiaolyuh123 edited this page on Apr 25, 2022 · [23 revisions](https://github.com/xiaolyuh/layering-cache/wiki/文档/_history)

# 快速开始

## 集成 Spring Boot

1. 引入layering-cache

```
<dependency>
    <groupId>com.github.xiaolyuh</groupId>
    <artifactId>layering-cache-starter</artifactId>
    <version>${layering.version}</version>
</dependency>
```

1. 添加配置

```
server.port=8082

#layering-cache 配置
layering-cache.stats=true
# 缓存命名空间，如果不配置取 "spring.application.name"
layering-cache.namespace=layering-cache-web

layering-cache.redis.database=0
layering-cache.redis.timeout=60
layering-cache.redis.password=
# redis单机
#layering-cache.redis.host=127.0.0.1
#layering-cache.redis.port=6378
# redis集群
#layering-cache.redis.cluster=127.0.0.1:6379,127.0.0.1:6378
# redis sentinel
layering-cache.redis.sentinel-nodes=127.0.0.1:26379,127.0.0.1:26380,127.0.0.1:26381
layering-cache.redis.sentinel-master=mymaster

# 设置redis值的序列化方式,默认是kryo
#com.github.xiaolyuh.redis.serializer.KryoRedisSerializer
#com.github.xiaolyuh.redis.serializer.FastJsonRedisSerializer
#com.github.xiaolyuh.redis.serializer.JacksonRedisSerializer
#com.github.xiaolyuh.redis.serializer.JdkRedisSerializer
#com.github.xiaolyuh.redis.serializer.ProtostuffRedisSerializer
layering-cache.redis.serializer=com.github.xiaolyuh.redis.serializer.KryoRedisSerializer
```



1. 配置类中添加注解`@EnableLayeringCache`启用`layering-cache`

```
@SpringBootApplication
@EnableLayeringCache
public class LayeringCacheStartDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(LayeringCacheStartDemoApplication.class, args);
    }
}
```



## 集成 Spring



1. 引入layering-cache

- maven 方式

```
<dependency>
    <groupId>com.github.xiaolyuh</groupId>
    <artifactId>layering-cache-aspectj</artifactId>
    <version>${layering.version}</version>
</dependency>
```



- gradle 方式

```
compile 'com.github.xiaolyuh:layering-cache:${layering.version}'
```



1. RedisClient（可以参考layering-cache-aspectj的Test配置）

```
@Configuration
@PropertySource({"classpath:application.properties"})
public class RedisConfig {

    @Value("${spring.redis.database:0}")
    private int database;

    @Value("${spring.redis.host:192.168.83.128}")
    private String host;

    @Value("${spring.redis.password:}")
    private String password;

    @Value("${spring.redis.port:6378}")
    private int port;

    @Bean
    public RedisClient layeringCacheRedisClient() {
        RedisProperties redisProperties = new RedisProperties();
        redisProperties.setDatabase(database);
        redisProperties.setHost(host);
        redisProperties.setPassword(StringUtils.isBlank(password) ? null : password);
        redisProperties.setPort(port);

        KryoRedisSerializer<Object> kryoRedisSerializer = new KryoRedisSerializer<>(Object.class);
        StringRedisSerializer keyRedisSerializer = new StringRedisSerializer();
        SingleRedisClient redisClient = new SingleRedisClient(redisProperties);
        redisClient.setKeySerializer(keyRedisSerializer);
        redisClient.setValueSerializer(kryoRedisSerializer);
        return redisClient;
    }
}
```



1. 声明CacheManager和LayeringAspect

```
/**
 * 多级缓存配置
 *
 * @author yuhao.wang3
 */
@Configuration
@Import({RedisConfig.class})
@EnableAspectJAutoProxy
public class CacheConfig {

    @Bean
    public CacheManager layeringCacheManager(RedisClient layeringCacheRedisClient, CacheStatsReportService cacheStatsReportService, LayeringCacheProperties layeringCacheProperties) {

        LayeringCacheManager layeringCacheManager = new LayeringCacheManager(layeringCacheRedisClient);
        // 默认开启统计功能
        layeringCacheManager.setStats(layeringCacheProperties.isStats());
        // 上报缓存统计信息
        layeringCacheManager.setCacheStatsReportService(cacheStatsReportService);
        // 设置缓存命名空间
        GlobalConfig.setNamespace(StringUtils.isBlank(layeringCacheProperties.getNamespace()) ? applicationName : layeringCacheProperties.getNamespace());
        return layeringCacheManager;
    }

    @Bean
    @ConditionalOnMissingBean(CacheStatsReportService.class)
    public CacheStatsReportService cacheStatsReportService() {
        return new DefaultCacheStatsReportServiceImpl();
    }
}
```



# 使用



## 注解形式



直接在需要缓存的方法上加上Cacheable、CacheEvict、CachePut、Caching注解。

- Cacheable注解

```java
@Cacheable(value = "user:info", depict = "用户信息缓存", cacheMode = CacheMode.ALL,
		firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),
		secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 3, forceRefresh = true, timeUnit = TimeUnit.SECONDS))
public User getUser(User user) {
	logger.debug("调用方法获取用户名称");
	return user;
}
```

- CachePut注解

```
@CachePut(value = "user:info", key = "#userId", depict = "用户信息缓存", cacheMode = CacheMode.ALL,
		firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),
		secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 3, forceRefresh = true, timeUnit = TimeUnit.SECONDS))
public User putUser(long userId) {
	User user = new User();
	user.setUserId(userId);
	user.setAge(31);
	user.setLastName(new String[]{"w", "y", "h"});

	return user;
}
```



- CacheEvict注解

```
@CacheEvict(value = "user:info", key = "#userId")
public void evictUser(long userId) {

}

@CacheEvict(value = "user:info", allEntries = true)
public void evictAllUser() {
}
```



- Caching注解

```
@Caching(evict = {@CacheEvict(value = "user:info:caching:3-4-0", key = "'evict'+#userId"), @CacheEvict(value = "user:info:caching", allEntries = true)},
        put = {@CachePut(value = "user:info:caching:3-4-0", key = "'put'+#userId",
                secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 3, timeUnit = TimeUnit.SECONDS))},
        cacheable = {@Cacheable(value = "user:info:caching:3-4-0", key = "#userId",
                firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),
                secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 7, timeUnit = TimeUnit.SECONDS))})
public User cachingAll(long userId) {
    return user;
}
```



## 直接使用API

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {CacheConfig.class})
public class CacheCoreTest {
    private Logger logger = LoggerFactory.getLogger(CacheCoreTest.class);

    @Autowired
    private CacheManager cacheManager;

    @Test
    public void testCacheExpiration() {
        FirstCacheSetting firstCacheSetting = new FirstCacheSetting(10, 1000, 4, TimeUnit.SECONDS, ExpireMode.WRITE);
        SecondaryCacheSetting secondaryCacheSetting = new SecondaryCacheSetting(10, 4, TimeUnit.SECONDS, true);
        LayeringCacheSetting layeringCacheSetting = new LayeringCacheSetting(firstCacheSetting, secondaryCacheSetting);

        String cacheName = "cache:name";
        String cacheKey = "cache:key1";
        LayeringCache cache = (LayeringCache) cacheManager.getCache(cacheName, layeringCacheSetting);
        cache.get(cacheKey, () -> initCache(String.class));
        cache.put(cacheKey, "test");
        cache.evict(cacheKey);
        cache.clear();
    }

    private <T> T initCache(Class<T> t) {
        logger.debug("加载缓存");
        return (T) "test";
    }
}
```



## 使用API清除缓存

```
@Resource
private LayeringCacheManager layeringCacheManager;

@PostMapping("/clear-layering-cache")
@ApiOperation(value = "清空layering-cache缓存", httpMethod = "POST")
public Boolean clearLayeringCache(String cacheName) {
    LayeringCacheSetting defaultSetting = new LayeringCacheSetting(new FirstCacheSetting(), new SecondaryCacheSetting(), "默认缓存配置（删除时生成）", CacheMode.ALL);
    Cache cache = layeringCacheManager.getCache(cacheName, defaultSetting);
    cache.clear();
    return true;
}
```



# 注解说明



## @Cacheable

当该方法被调用时先检查缓存是否命中(及缓存中是否有)，如果没有命中再调用被缓存的方法，并将其返回值放到缓存中。有就直接拿缓存中的。

| 名称           | 默认值        | 说明                                                |
| -------------- | ------------- | --------------------------------------------------- |
| value          | 空字符串数组  | 缓存名称，cacheNames的别名, 存放redis中的value      |
| cacheNames     | 空字符串数组  | 缓存名称                                            |
| key            | 空字符串      | 缓存key，支持SpEL表达式,  必须唯一,存放redis中的key |
| depict         | 空字符串      | 缓存描述（在缓存统计页面会用到）                    |
| cacheMode      | CacheMode.ALL | 缓存模式(只使用一级缓存或者二级缓存)                |
| firstCache     |               | 一级缓存配置                                        |
| secondaryCache |               | 二级缓存配置                                        |

### @FirstCache

一级缓存配置项

| 名称            | 默认值           | 说明                                                         |
| --------------- | ---------------- | ------------------------------------------------------------ |
| initialCapacity | 10               | 缓存初始Size                                                 |
| maximumSize     | 5000             | 缓存最大Size                                                 |
| expireTime      | 9                | 缓存有效时间                                                 |
| timeUnit        | TimeUnit.MINUTES | 时间单位，默认分钟                                           |
| expireMode      | ExpireMode.WRITE | 缓存失效模式，ExpireMode.WRITE：最后一次写入后到期失效，ExpireMode.ACCESS：最后一次访问后到期失效 |

### @SecondaryCache

二级缓存配置项

| 名称          | 默认值         | 说明                                                         |
| ------------- | -------------- | ------------------------------------------------------------ |
| expireTime    | 5              | 缓存有效时间                                                 |
| preloadTime   | 1              | 缓存主动在失效前强制刷新缓存的时间，建议是 expireTime * 0.2  |
| timeUnit      | TimeUnit.HOURS | 时间单位，默认小时                                           |
| forceRefresh  | false          | 是否强制刷新（直接执行被缓存方法）                           |
| magnification | 1              | 非空值和null值之间的时间倍率，默认是1。如expireTime=60秒，magnification=10，那么当缓存空值时，空值的缓存过期时间是60/10=6秒。 |

## @CachePut

将数据放到缓存中

| 名称           | 默认值        | 说明                                 |
| -------------- | ------------- | ------------------------------------ |
| value          | 空字符串数组  | 缓存名称，cacheNames的别名           |
| cacheNames     | 空字符串数组  | 缓存名称                             |
| key            | 空字符串      | 缓存key，支持SpEL表达式              |
| depict         | 空字符串      | 缓存描述（在缓存统计页面会用到）     |
| cacheMode      | CacheMode.ALL | 缓存模式(只使用一级缓存或者二级缓存) |
| firstCache     |               | 一级缓存配置                         |
| secondaryCache |               | 二级缓存配置                         |

## @CacheEvict

删除缓存。@CacheEvict不这么用, 一般@Cacheable会设置过期时间的

| 名称       | 默认值        | 说明                                                         |
| ---------- | ------------- | ------------------------------------------------------------ |
| value      | 空字符串数组  | 缓存名称，cacheNames的别名                                   |
| cacheNames | 空字符串数组  | 缓存名称                                                     |
| key        | 空字符串      | 缓存key，支持SpEL表达式                                      |
| allEntries | false         | 是否删除缓存中所有数据，默认情况下是只删除关联key的缓存数据，当该参数设置成 true 时 key 参数将无效 |
| cacheMode  | CacheMode.ALL | 缓存模式(只使用一级缓存或者二级缓存)                         |

## @Caching

同时使用多个缓存注解

| 名称      | 默认值         | 说明           |
| --------- | -------------- | -------------- |
| cacheable | Cacheable数组  | Cacheable注解  |
| put       | CachePut数组   | CachePut注解   |
| evict     | CacheEvict数组 | CacheEvict注解 |

# 案例

## 具体代码

![image-20240301100759122](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301100759122.png)

## 运行结果

### 添加

```java
    // 放
    @Override
    @CachePut(value = "cache-prefix:people", key = "#person.id", depict = "用户信息缓存")
    public Person save(Person person) {
        logger.info("为id、key为:" + person.getId() + "数据做了缓存");
        return person;
    }
```

![image-20240301103209631](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301103209631.png)

### 查询

```java
    // 查
    @Override
    @Cacheable(value = "cache-prefix:people", key = "#person.id", depict = "用户信息缓存",
            firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),  //	一级缓存配置
            secondaryCache = @SecondaryCache(expireTime = 15, preloadTime = 8, forceRefresh = true, timeUnit = TimeUnit.MINUTES)) // 二级缓存配置
    public Person findOne(Person person) {
        // 没有走缓存, 就执行方法中
        Person p = new Person(2L, "name2", 12, "address2");
        logger.info("为id、key为:" + p.getId() + "数据做了缓存");
        try {
            Thread.sleep(2050);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return p;
    }
```

**情况1:** ==查询数据存在走缓存==

![image-20240301104627134](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301104627134.png)

**情况2**:==查询数据不存在走方法, 并且将方法返回结果进行缓存==

![image-20240301104656798](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301104656798.png)

### redis已经缓存的数据

<img src="%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301105608955.png" alt="image-20240301105608955" style="zoom:80%;" />

# 其他案例

## 需求

**比如，**

+ **首页中的那几张幻灯片，每次进入首页都需要查询数据库，可以直接放入缓存里，减少数据库的压力，还有就是那些热门文章，访问量比较大的，也放进缓存里。**

+ **实现登录过期的功能,比如在用户提交登录时,通过设置一个过期时间,当用户30分钟内没有访问,redis就会自动将该用户的登录数据删除,从而释放宝贵的用户资源。**

```java
  
	// 得到幻灯片
	@Override
    @Cacheable(value = "getBanner", keyGenerator = "customKeyGenerator")
    public List<Blog> getBanner() {
        return blogMapper.getBanner();
    }

	// 得到热门文章
    @Override
    @Cacheable(value = "getBlogDetail", key = "'blogid'.concat(#blogid)")
    public Blog getBlogDetail(Integer blogid) {
        Blog blog = blogMapper.selectByPrimaryKey(blogid);
        if (blog == null) {
            return null;
        }
        Category category = categoryMapper.selectByPrimaryKey(blog.getCategoryid());
        blog.setCategory(category);
        List<Tag> tags = tagMapper.getTagByBlogId(blog.getBlogid());
        blog.setTags(tags.size() > 0 ? tags : null);
        asyncService.updatebloghits(blogid);//异步更新阅读次数
        logger.info("没有走缓存");
        return blog;
    }
```

## 测试

调用一个getBlogDetail（获取博客详情）100次来对比一下时间。

```java
public class SpringTest {
    @Test
    public void init() {
        ApplicationContext ctx = new FileSystemXmlApplicationContext("classpath:spring-test.xml");
        IBlogService blogService = (IBlogService) ctx.getBean("blogService");
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 100; i++) {
            blogService.getBlogDetail(615);
        }
        System.out.println(System.currentTimeMillis() - startTime);
    }
}
```

为了做一下对比，同时使用mybatis自身缓存来进行测试。

##  实验结果

统计出结果如下：

```html
没有使用任何缓存（mybatis一级缓存没有关闭）：18305
使用远程Redis缓存：12727
使用Mybatis缓存：6649
使用本地Redis缓存：5818
```

由结果看出，缓存的使用大大较少了获取数据的时间。


redis已经缓存的数据：

<img src="%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/20180120052757.png">

# 分页的数据缓存

个人网站中共有两个栏目，一个是技术杂谈，另一个是生活笔记，每点击一次栏目的时候，会根据页数从数据库中查询数据，百度了下，大概有三种方法：
（1）以页码作为Key，然后缓存整个页面。
（2）分条存取，只从数据库中获取分页的文章ID序列，然后从service（缓存策略在service中实现）中获取。
第一种，由于使用了第三方的插件PageHelper，分页获取的话会比较麻烦，同时整页缓存对内存压力也蛮大的，毕竟服务器只有2g。

第二中实现方式简单，缺陷是依旧需要查询数据库，想了想还是放弃了。缓存的初衷是对请求频繁又不易变的数据，实际使用中很少会反复的请求同一页的数据（查询条件也相同），当然对数据中某些字段做缓存还是有必要的。

# 准则

## [缓存雪崩](https://so.csdn.net/so/search?q=缓存雪崩&spm=1001.2101.3001.7020)

缓存在统一时间大面积失效，导致所有的请求都会落到数据库上，对数据库CPU和[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)造成巨大压力，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统的崩溃。
解决办法：

- 缓存数据过期时间随机：过期时间设置随机，防止同一时间大量数据过期；
- 热点数据不设置过期时间，主动刷新缓存：缓存设置成永不过期，在更新和删除DB时，也主动把缓存中的数据核心或删除；
- 检查更新：缓存依然保持设置过期时间，每次get缓存的时候，都把数据过期时间与当前时间进行对比，当间隔时间小于一定阈值的时候，主动更新缓存。

## [缓存击穿](https://so.csdn.net/so/search?q=缓存击穿&spm=1001.2101.3001.7020)

缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时候由于[并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)访问很多，缓存中没有读到数据，造成数据库短时间内承受大量请求而崩溃。和缓存雪崩的区别是：缓存击穿指并发查询一条数据，缓存崩溃是指缓存同一时间大量失效。
解决方法：

- 加互斥锁；
- 设置热点数据永不过期。

## 缓存穿透

缓存和数据库中都没有的数据。这样会导致用户查询的时候，在缓存中找不到，每次都要去数据库中查一遍，然后返回空（相当于进行了两次无用的查询），这样请求就绕过了缓存直接查库（命中率问题）。
解决方法：

- 使用布隆过滤器；
- 返回数据为空时设置一个默认缓存，过期时间很短。

## 缓存预热

系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候直接查询数据库，然后再将数据缓存。用户直接查询实现被预热的缓存数据。

## 缓存更新

缓存更新除了缓存服务器自带的缓存失效策略之外，还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
（1）定时区清理过期缓存；
（2）当有用户请求过来时，再判断所用到的请求是否过期，过期的话就去底层系统得到新的数据并更新缓存。

例如，在缓存中存放了近3年的10亿条博文数据，但是经常被访问的可能只有10万条，其他的可能几个月才访问一次。那么，就没有必要让所有的博文数据长期存在于缓存中。设置一个过期时间比方说7天，超过7天未被访问的博文数据将会自动失效，如此节省大量内存。

例如：游戏中的发言间隔为10秒钟，可以通过缓存实现。

## 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响大核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级 ，可以配置开关人工降级。降级的最终目的是报这个核心服务的可用（即使是有损的）。



参考:

[Redis缓存何以一枝独秀？(2) —— 聊聊Redis的数据过期、数据淘汰以及数据持久化的实现机制 - 架构悟道 - 博客园 (cnblogs.com)](https://www.cnblogs.com/softwarearch/p/16927956.html)