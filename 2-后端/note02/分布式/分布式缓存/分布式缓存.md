#  缓存介绍

系统的性能指标一般包括响应时间、延迟时间、吞吐量，并发用户数和资源利用率等。在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。

缓存常用语：
数据不一致性、缓存更新机制、缓存可用性、缓存服务降级、缓存预热、缓存穿透

# Spring自带的缓存

**Spring Boot支持的缓存组件有：**

![image-20240317102319831](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240317102319831.png)

![image-20240317181050073](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240317181050073.png)

 springboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。

**步骤①**：导入springboot提供的缓存技术对应的[starter](https://so.csdn.net/so/search?q=starter&spm=1001.2101.3001.7020)

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

**步骤②**：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存

```java
@SpringBootApplication
//开启缓存功能
@EnableCaching
public class Springboot19CacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot19CacheApplication.class, args);
    }
}
```

**步骤③**：设置操作的数据是否使用缓存

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    private BookDao bookDao;

    @Cacheable(value="cacheSpace",key="#id")
    public Book getById(Integer id) {
        return bookDao.selectById(id);
    }
}
```

 在业务方法上面使用注解@[Cacheable](https://so.csdn.net/so/search?q=Cacheable&spm=1001.2101.3001.7020)声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。

 使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。

**手机验证码案例**

 为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。

 手机验证码案例需求如下：

- 输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）
- 输入手机号和验证码验证结果

 为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。

**步骤①**：导入springboot提供的缓存技术对应的starter

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
1234
```

**步骤②**：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存

```java
@SpringBootApplication
//开启缓存功能
@EnableCaching
public class Springboot19CacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot19CacheApplication.class, args);
    }
}
12345678
```

**步骤③**：定义验证码对应的实体类，封装手机号与验证码两个属性

```java
@Data
public class SMSCode {
    private String tele;
    private String code;
}
12345
```

**步骤④**：定义验证码功能的业务层接口与实现类

```java
public interface SMSCodeService {
    public String sendCodeToSMS(String tele);
    public boolean checkCode(SMSCode smsCode);
}

@Service
public class SMSCodeServiceImpl implements SMSCodeService {
    @Autowired
    private CodeUtils codeUtils;

    @CachePut(value = "smsCode", key = "#tele")
    public String sendCodeToSMS(String tele) {
        String code = codeUtils.generator(tele);
        return code;
    }

    public boolean checkCode(SMSCode smsCode) {
        //取出内存中的验证码与传递过来的验证码比对，如果相同，返回true
        String code = smsCode.getCode();
        String cacheCode = codeUtils.get(smsCode.getTele());
        return code.equals(cacheCode);
    }
}
1234567891011121314151617181920212223
```

 获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@Cacheable注解，@Cacheable注解是缓存中没有值则放入值，缓存中有值则取值。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@Cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@CachePut注解即可。

 对于校验验证码的功能建议放入工具类中进行。

**步骤⑤**：定义验证码的生成策略与根据手机号读取验证码的功能

```java
@Component
public class CodeUtils {
    private String [] patch = {"000000","00000","0000","000","00","0",""};

    public String generator(String tele){
        int hash = tele.hashCode();
        int encryption = 20206666;
        long result = hash ^ encryption;
        long nowTime = System.currentTimeMillis();
        result = result ^ nowTime;
        long code = result % 1000000;
        code = code < 0 ? -code : code;
        String codeStr = code + "";
        int len = codeStr.length();
        return patch[len] + codeStr;
    }

    //如果把该函数写在SMSCodeServiceImpl中，会导致get调用的是成员函数，不能从缓存中读取数据
    @Cacheable(value = "smsCode",key="#tele")
    public String get(String tele){
        return null;
    }
}
1234567891011121314151617181920212223
```

**步骤⑥**：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验

```java
@RestController
@RequestMapping("/sms")
public class SMSCodeController {
    @Autowired
    private SMSCodeService smsCodeService;
    
    @GetMapping
    public String getCode(String tele){
        String code = smsCodeService.sendCodeToSMS(tele);
        return code;
    }
    
    @PostMapping
    public boolean checkCode(SMSCode smsCode){
        return smsCodeService.checkCode(smsCode);
    }
}
1234567891011121314151617
```

文章知识点与官方知识档案匹配，可进一步学习相关知识

# `MyBatis`的缓存

## `MyBatis`的一级缓存

一级缓存是`SqlSession`级别的，通过同一个`SqlSession`查询的数据会缓存，下次查询相同的数据就会从缓存中直接获取，不会从数据重新访问，**前提必须是同一个`SqlSession`对象，并且查询的数据相同**

**注意是：`SqlSession`是只针对`查询的`，并且一级`SqlSession`是默认开启的**, 增删改操作，`MyBatis`就是将一级缓存，自动清空掉。

[`MyBatis`的缓存_mybatis 缓存 怎么清理-CSDN博客](https://blog.csdn.net/weixin_47267628/article/details/124588936)

## 使用Redis实现Mybatis二级缓存 :crossed_swords:

### 依赖

```xml
        <!-- redis配置 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- lecttuce 缓存连接池-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>

```

### 配置

```yaml
 #配置Mybatis-Plus
  mybatis-plus:
    mapper-locations: classpath:mybatis/mapper/*.xml
    configuration:
      cache-enabled: true
      map-underscore-to-camel-case: true
```

### 开启缓存

> #### 在启动类上添加@EnableCaching注解

```java
package com.chenyx;
 
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
 
 
@MapperScan("com.chenyx.mapper")
@SpringBootApplication
@EnableCaching  // 开启缓存
public class MainApplication {
 
	public static void main(String[] args) {
		SpringApplication.run(MainApplication.class, args);
		System.out.println("Spring-Boot启动成功！");
	}
 
}
```

> #### 设置RedisTemplate，在这可以对Redis的存储类型进行序列化，但是这里mybatis缓存没有使用

```java
package com.chenyx.config;
 
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
 
/**
 */
@Configuration
public class RedisConfiguration {
 
	/**
	 * 设置redisTemplate
	 */
	@Bean(name = "redisTemplate")
	public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory redisConnectionFactory) {
		RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();
		redisTemplate.setConnectionFactory(redisConnectionFactory);
		redisTemplate.afterPropertiesSet();
		return redisTemplate;
	}
}
 
```

### 重写Mybatis二级缓存的Cache接口

> 创建MybatisRedisCache类重写Mybatis二级缓存的Cache接口的实现

```java
package com.chenyx.config;
 
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.cache.Cache;
import org.springframework.data.redis.connection.RedisServerCommands;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.util.CollectionUtils;
 
import javax.annotation.Resource;
import java.util.Set;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
 
/**
 *
 * 使用redis实现Mybatis Plus二级缓存
 *
 */
@Slf4j
public class MybatisRedisCache implements Cache {
 
 
	// 读写锁
	private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);
	
	private RedisTemplate redisTemplate;
 
	private RedisTemplate getRedisTemplate(){
		//通过ApplicationContextHolder工具类获取RedisTemplate
		if (redisTemplate == null) {
			redisTemplate = (RedisTemplate) ApplicationContextHolder.getBeanByName("redisTemplate");
		}
		return redisTemplate;
	}
 
	private final String id;
 
	public MybatisRedisCache(String id) {
		if (id == null) {
			throw new IllegalArgumentException("Cache instances require an ID");
		}
		this.id = id;
	}
 
	@Override
	public String getId() {
		return this.id;
	}
 
	@Override
	public void putObject(Object key, Object value) {
		//使用redis的Hash类型进行存储
		getRedisTemplate().opsForHash().put(id,key.toString(),value);
	}
 
	@Override
	public Object getObject(Object key) {
		try {
			//根据key从redis中获取数据
			return getRedisTemplate().opsForHash().get(id,key.toString());
		} catch (Exception e) {
			e.printStackTrace();
			log.error("缓存出错 ");
		}
		return null;
	}
 
	@Override
	public Object removeObject(Object key) {
		if (key != null) {
			getRedisTemplate().delete(key.toString());
		}
		return null;
	}
 
	@Override
	public void clear() {
        log.debug("清空缓存");
		if (redisTemplate == null) {
			redisTemplate = (RedisTemplate<String, Object>) ApplicationContextHolder.getBean("redisTemplate");
		}
		try {
			Set<String> keys = scanMatch(this.id);
			if (!CollectionUtils.isEmpty(keys)) {
				redisTemplate.delete(keys);
			}
		} catch (Exception e) {
			log.error("清空缓存", e);
		}
	}
 
	@Override
	public int getSize() {
		Long size = (Long) getRedisTemplate().execute((RedisCallback<Long>) RedisServerCommands::dbSize);
		return size.intValue();
	}
 
	@Override
	public ReadWriteLock getReadWriteLock() {
		return this.readWriteLock;
	}
    
    private static final Integer SCAN_COUNT = 10000;
    /**
	 * 使用scan遍历key
	 * 为什么不使用keys 因为Keys会引发Redis锁，并且增加Redis的CPU占用,特别是数据庞大的情况下。这个命令千万别在生产环境乱用。
	 * 支持redis单节点和集群调用
	 *
	 * @param matchKey
	 * @return
	 */
	public Set<String> scanMatch(String matchKey) {
		Set<String> keys = new HashSet();
		RedisConnectionFactory connectionFactory = redisTemplate.getConnectionFactory();
		RedisConnection redisConnection = connectionFactory.getConnection();
		Cursor<byte[]> scan = null;
		//集群
		if(redisConnection instanceof JedisClusterConnection){
			RedisClusterConnection clusterConnection = connectionFactory.getClusterConnection();
			Iterable<RedisClusterNode> redisClusterNodes = clusterConnection.clusterGetNodes();
			Iterator<RedisClusterNode> iterator = redisClusterNodes.iterator();
			while (iterator.hasNext()) {
				RedisClusterNode next = iterator.next();
				scan = clusterConnection.scan(next, ScanOptions.scanOptions().match(matchKey).count(Integer.MAX_VALUE).build());
				while (scan.hasNext()) {
					keys.add(new String(scan.next()));
				}
				try {
					if(scan !=null){
						scan.close();
					}
				} catch (Exception e) {
					log.error("scan遍历key关闭游标异常",e);
				}
			}
			return keys;
		}
		//单机
		if(redisConnection instanceof JedisConnection){
			scan = redisConnection.scan(ScanOptions.scanOptions().match(matchKey + "*").count(SCAN_COUNT).build());
			while (scan.hasNext()) {
				//找到一次就添加一次
				keys.add(new String(scan.next()));
			}
			try {
				if (scan != null) {
					scan.close();
				}
			} catch (Exception e) {
				log.error("scan遍历key关闭游标异常", e);
			}
			return keys;
		}

		return keys;

	}
}
```

 因为RedisTemplate的实例化需要使用Spring的工厂进行创建，而我们创建的MybatisRedisCache类实现的是Mybatis的Cache接口，所以这个类不是由工厂进行管理的，所以我们不能直接在该类中直接使用注解注入RedisTemplate，所以我们创建一个获取Spring Boot创建好的工厂的ApplicationContextHolder工具类，用于获取RedisTemplate

```java
package com.chenyx.config;
 
 
 
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;
 
@Component
public class ApplicationContextHolder implements ApplicationContextAware {
    private static ApplicationContext applicationContext;
 
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        ApplicationContextHolder.applicationContext = applicationContext;
    }
 
    //根据bean name 获取实例
    public static Object getBeanByName(String beanName) {
        if (beanName == null || applicationContext == null) {
            return null;
        }
        return applicationContext.getBean(beanName);
    }
    //只适合一个class只被定义一次的bean（也就是说，根据class不能匹配出多个该class的实例）
    public static Object getBeanByType(Class clazz) {
        if (clazz == null || applicationContext == null) {
            return null;
        }
        return applicationContext.getBean(clazz);
    }
    public static String[] getBeanDefinitionNames() {
        return applicationContext.getBeanDefinitionNames();
    }
}
```

  实现ApplicationContextAware接口后，在Spring Boot启动创建工厂后，就会自动调用这个接口的setApplicationContext方法，将创建的工厂以参数的形式传递给这个类，在这个方法中我们就可以把工厂给保存下来。

### 使用mybatis二级缓存

> #### 最后我们只需要在Mapper接口上添加@CacheNamespace注解，就完成了

```java
package com.chenyx.mapper;
 
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.chenyx.config.MybatisRedisCache;
import com.chenyx.entity.WeChatUser;
import org.apache.ibatis.annotations.CacheNamespace;
 
/**
 */
@CacheNamespace(implementation= MybatisRedisCache.class,eviction=MybatisRedisCache.class)
public interface WeChatUserListMapper extends BaseMapper<WeChatUser>{
}
```

# redis缓存(弃)

## 一、知识点

@Cacheable、@CachePut、@CacheEvit、@Caching注解**

| 注解       | 解释                                                         |
| :--------- | :----------------------------------------------------------- |
| @Cacheable | 在方法执行前Spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放进缓存 |
| @CachePut  | 无论怎样，都会将方法的缓存值放到缓存中，查询数据库的方法总会被调用 |
| @CacheEvit | 将一条或多条数据从缓存中删除                                 |
| @Caching   | 可以通过@Caching注解组合多个注解策略在一个方法上             |

**注解相关属性**

cacheNames/value：指定缓存组件的名称

key：缓存数据使用的key，默认是使用方法参数的值

condition：指定符合条件的情况下缓存

unless：否定缓存，当unless指定的条件为true的时候不进行缓存

**Spring Boot中配置缓存**

spring.cache.type=   //配置要使用的缓存

spring.cache.cache-name=   //程序启动时创建缓存的名称

## 二、使用工具

1、mysql数据库

2、安装redis

3、安装redis客户端工具：RedisDesktopManager

## **三、准备工作**

创建Spring Boot工程

​    在Spring中使用缓存技术的关键是配置CacheManager，而Spring Boot中自动配置了多个CacheManager的实现。

## 四、编写程序

1、引用依赖

> ```html
> <dependencies>
>    <dependency>
>       <groupId>org.springframework.boot</groupId>
>       <artifactId>spring-boot-starter-web</artifactId>
>    </dependency>
>  
>    <!-- SpringBoot启动器-->
>    <dependency>
>       <groupId>org.springframework.boot</groupId>
>       <artifactId>spring-boot-starter</artifactId>
>    </dependency>
>  
>    <!-- SpringBoot test启动器-->
>    <dependency>
>       <groupId>org.springframework.boot</groupId>
>       <artifactId>spring-boot-starter-test</artifactId>
>       <scope>test</scope>
>    </dependency>
>  
>    <!-- MySql jdbc驱动 -->
>    <dependency>
>       <groupId>mysql</groupId>
>       <artifactId>mysql-connector-java</artifactId>
>    </dependency>
>  
>    <!-- MyBatis-Plus启动器 -->
>    <dependency>
>       <groupId>com.baomidou</groupId>
>       <artifactId>mybatis-plus-boot-starter</artifactId>
>       <version>3.3.0</version>
>    </dependency>
>  
>    <!-- lombok简化代码-->
>    <dependency>
>       <groupId>org.projectlombok</groupId>
>       <artifactId>lombok</artifactId>
>       <optional>true</optional>
>    </dependency>
>  
>    <!-- p6spy 组件,用于完美的输出打印 SQL 及执行时长-->
>    <dependency>
>       <groupId>p6spy</groupId>
>       <artifactId>p6spy</artifactId>
>       <version>3.8.2</version>
>    </dependency>
>  
>     <!--引入缓存-->
>      <dependency>
>             <groupId>org.springframework.boot</groupId>
>             <artifactId>spring-boot-starter-cache</artifactId>
>         </dependency>
>    <!-- redis-->
>    <dependency>
>       <groupId>org.springframework.boot</groupId>
>       <artifactId>spring-boot-starter-data-redis</artifactId>
>       <version>2.2.2.RELEASE</version>
>    </dependency>
>  
> </dependencies>
> ```

2、配置application.yml文件

> ```xml
> server:
>   port: 9999
> spring:
>   # 配置数据库信息
>   datasource:
>     driver-class-name: com.p6spy.engine.spy.P6SpyDriver
>     url: jdbc:p6spy:mysql://localhost:3306/mp?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC
>     username: root
>     password: 123456
>   # 配置redis
>   redis:
>     database: 15
>     host: 127.0.0.1
>     port: 6379
>   # 配置使用的缓存：redis   [核心]
>   cache:
>     type: redis
> mybatis-plus:
>   configuration:
>     # 这个配置会将执行的sql打印出来，在开发或测试的时候可以用
>     log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
> ```

 3、编写dao层

```java
package com.test.redis.dao;
 
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.test.redis.entity.User;
import org.apache.ibatis.annotations.Mapper;
 
@Mapper
public interface UserMapper extends BaseMapper<User>{
    
}
```

4、编写service

```java
package com.test.redis.service;
 
import com.baomidou.mybatisplus.extension.service.IService;
import com.test.redis.entity.User;
 
public interface UserService extends IService<User> {
     User updateUser(User user);
 
     User getUser(String userId);
 
     int deleteUser(String userId);
}
```

实现类：

```java
package com.test.redis.service.impl;
 
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.test.redis.dao.UserMapper;
import com.test.redis.entity.User;
import com.test.redis.service.UserService;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
 
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper,User> implements UserService {
    @Override
    @CachePut(cacheNames = "user", key = "#user.id")
    public User updateUser(User user) {
        baseMapper.updateById(user);
        return baseMapper.selectById(user.getId());
    }
 
    @Override
    @Cacheable(cacheNames = "user", key = "#id",unless="#result == null")
    public User getUser(String id) {
        return baseMapper.selectById(id);
    }
 
    @Override
    @CacheEvict(cacheNames = "user",key = "#id")
    public int deleteUser(String id) {
        return  baseMapper.deleteById(id);
    }
}
```

5、编写controller

```java
package com.test.redis.controller;
 
import com.test.redis.entity.User;
import com.test.redis.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
 
@RestController
@RequestMapping("/user")
public class UserController {
    @Autowired
    UserService userService;
 
    @PutMapping
    public User updateUser(@RequestBody User user) {
        return userService.updateUser(user);
    }
 
    @GetMapping(value = "/{id}")
    public User getUser(@PathVariable String id) {
        User user = userService.getUser(id);
        return user;
    }
 
    @DeleteMapping(value = "/{id}")
    public String deleteUser(@PathVariable String id) {
        int i = userService.deleteUser(id);
        if(i==1){
            return "删除成功";
        }
        return "删除失败";
    }
}
```

6、在启动类上使用@EnableCaching来开启缓存

```java
package com.test.redis;
 
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
 
@SpringBootApplication
@EnableCaching
public class RedisApplication {
 
	public static void main(String[] args) {
		SpringApplication.run(RedisApplication.class, args);
	}
 
}
```

## 五、使用postman进行测试

数据表中的数据：

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70.png)

#### 1、先来从数据库查询一条数据，缓存到redis数据库中（@Cacheable注解 ）

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921251.png)

第一次查询之后，经过查询mysql数据库查询出来之后缓存到redis数据库中

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921252.png)

之后再查询该数据，不经过查询数据库的方法，就直接从redis数据库中返回，如下图可看到控制台没有输出sql语句：

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921253.png)

**结论**：**使用@Cacheable注解，第一次查询会经过mysql数据库进行查询，得到结果缓存到redis中。如果redis中已经存在要查询的数据，则就会从redis中取，而不经过mysql数据库。**

#### 2、修改一条数据，并更新缓存（@CachePut）

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921254.png)

**结论：使用@CachePut注解来更新缓存中的数据，每次都会执行操作数据库的方法，将数据库的数据更新之后，再将新的数据更新到缓存中。**

此时，再次查询刚刚更新的数据，可看到控制台中没有输出，这次是在缓存中拿到了最新的数据，如下图：

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921255.png)

#### 3、删除一条数据，并从缓存中将此数据删除（@CacheEvit）

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921256.png)

执行之后，可查看redis中已经将该缓存的数据删除。

## 六、扩展知识

**6.1、Redis默认支持16个数据库可以通过调整Redis的配置文件redis/redis.windows.conf中的databases来修改这一个值，设置完毕后重启Redis便完成配置。**

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921257.png)

6.2、在实际项目中可以通过配置文件来指定Redis使用的数据库：

![img](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkbl9rYg==,size_16,color_FFFFFF,t_70-17110905921258.png)

6.3、Redis不支持自定义数据库的名字，所以每个数据库都以编号命名。这样，就需要开发者记录存储的数据与数据库的对应关系。

6.4、Redis不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部的数据库，要么全部数据库都没有权限访问。

6.5、清空Redis实例中所有数据库中数据的命令：FLUSHALL

6.6、对于Redis来说，一个Redis实例不适宜存储不同应用程序的数据。一个Redis实例中不同的数据库可用于存放不同环境的数据；不同应用应该使用不同的Redis实例存储数据。

6.7、Redis集群下只有db0，不支持多db。







# springboot整合Redis缓存:crossed_swords:

##  添加依赖

```xml
        <!-- redis配置 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- lecttuce 缓存连接池-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
```

##  修改配置

现在spring中配置redis。需要设置ip，port和lettuce连接池信息。因为我们是在本地，所以host地址是127.0.0.1。

```yaml
spring:
  # redis配置
  redis:
    host: 192.168.200.134
    port: 6379
    password: 741106
    # lettuce配置(需引入 commons-pool2依赖)
    lettuce:
      pool:
        # 连接池最大连接数（使用负值表示没有限制）
        max-active: 200
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: -1
        # 连接池中的最大空闲连接
        max-idle: 10
        # 连接池中的最小空闲连接
        min-idle: 0
    database: 10
  # 配置使用的缓存：redis
  cache:
    type: redis
```

##  开启缓存

```java
@EnableAsync
@EnableCaching   //开启spring缓存
@SpringBootApplication
public class WebBasicApplication  {
	public static void main(String[] args) {
		SpringApplication.run(WebBasicApplication.class, args);
	}
}
```

## Config设置

```java
package com.lfj.blog.config;

import org.springframework.cache.CacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.*;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

/**
 * redis 配置
 **/
@Configuration
public class RedisConfig {
	/**
	 * 对象模板自定义存储序列化
	 *
	 * @param redisConnectionFactory
	 * @return RedisTemplate
	 */
	@Bean
	public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
		RedisTemplate<String, Object> template = new RedisTemplate<>();
		template.setConnectionFactory(redisConnectionFactory);
		template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
		template.setKeySerializer(new StringRedisSerializer());
		template.afterPropertiesSet();
		return template;
	}

	/**
	 * redis缓存管理器
	 *
	 * @param redisConnectionFactory
	 * @return
	 */
	@Bean
	public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
		RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofHours(2));
		return RedisCacheManager.builder(redisConnectionFactory)
				.cacheDefaults(cacheConfiguration)
				.build();
	}


	/**
	 * 对hash类型的数据操作
	 *
	 * @param redisTemplate
	 * @return
	 */
	@Bean
	public HashOperations<String, String, Object> hashOperations(RedisTemplate<String, Object> redisTemplate) {
		return redisTemplate.opsForHash();
	}

	/**
	 * 对redis字符串类型数据操作
	 *
	 * @param redisTemplate
	 * @return
	 */
	@Bean
	public ValueOperations<String, Object> valueOperations(RedisTemplate<String, Object> redisTemplate) {
		return redisTemplate.opsForValue();
	}

	/**
	 * 对链表类型的数据操作
	 *
	 * @param redisTemplate
	 * @return
	 */
	@Bean
	public ListOperations<String, Object> listOperations(RedisTemplate<String, Object> redisTemplate) {
		return redisTemplate.opsForList();
	}

	/**
	 * 对无序集合类型的数据操作
	 *
	 * @param redisTemplate
	 * @return
	 */
	@Bean
	public SetOperations<String, Object> setOperations(RedisTemplate<String, Object> redisTemplate) {
		return redisTemplate.opsForSet();
	}

	/**
	 * 对有序集合类型的数据操作
	 *
	 * @param redisTemplate
	 * @return
	 */
	@Bean
	public ZSetOperations<String, Object> zSetOperations(RedisTemplate<String, Object> redisTemplate) {
		return redisTemplate.opsForZSet();
	}

	/**
	 * 字符串模板
	 *
	 * @param redisConnectionFactory
	 * @return
	 */
	@Bean
	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
		StringRedisTemplate template = new StringRedisTemplate();
		template.setConnectionFactory(redisConnectionFactory);
		template.setKeySerializer(new StringRedisSerializer());
		return template;
	}
}
```

## 使用

```java

	/**
	 * 根据用户id获取userVo
	 *
	 * @param id
	 * @return
	 */
	@Override
	@Cacheable(value = "user", key = "#id")
	public UserVo selectUserVoById(Integer id) {
		User user = getById(id);
		if (user == null) {
			return null;
		}
		UserVo userVo = new UserVo();
		BeanUtils.copyProperties(user, userVo);
		Integer admin = user.getAdmin();
		List<String> roleList = new ArrayList<>();
		roleList.add(admin.equals(UserConstant.ADMIN) ? RoleConstant.ADMIN : RoleConstant.ORDINARY);
		userVo.setRoles(roleList);
		return userVo;
	}
```

# 推荐

推荐使用项目: [xiaolyuh/layering-cache: 为监控而生的分布式多级缓存框架 (github.com)](https://github.com/xiaolyuh/layering-cache)

具体使用见官方文档

### Redis序列化方式对比

[Redis序列化同一个User对象对比](https://github.com/xiaolyuh/layering-cache/wiki/Redis序列化方式对比)

|            | size   | serialize(get 10W次) | deserialize(set 10W次) | serialize(cpu) | deserialize(cpu) |
| ---------- | ------ | -------------------- | ---------------------- | -------------- | ---------------- |
| Kryo       | 273 b  | 82919 ms             | 90917 ms               | 8%             | 12%              |
| FastJson   | 329 b  | 15405 ms             | 18886 ms               | 12%            | 13%              |
| Jackson    | 473 b  | 16066 ms             | 16140 ms               | 15%            | 14%              |
| Jdk        | 1036 b | 17344 ms             | 24917 ms               | 14%            | 13%              |
| Protostuff | 282 b  | 14295 ms             | 14355 ms               | 15%            | 13%              |

### 文档

xiaolyuh123 edited this page on Apr 25, 2022 · [23 revisions](https://github.com/xiaolyuh/layering-cache/wiki/文档/_history)

### 快速开始

### 集成 Spring Boot

1. 引入layering-cache

```
<dependency>
    <groupId>com.github.xiaolyuh</groupId>
    <artifactId>layering-cache-starter</artifactId>
    <version>${layering.version}</version>
</dependency>
```

1. 添加配置

```
server.port=8082

#layering-cache 配置
layering-cache.stats=true
# 缓存命名空间，如果不配置取 "spring.application.name"
layering-cache.namespace=layering-cache-web

layering-cache.redis.database=0
layering-cache.redis.timeout=60
layering-cache.redis.password=
# redis单机
#layering-cache.redis.host=127.0.0.1
#layering-cache.redis.port=6378
# redis集群
#layering-cache.redis.cluster=127.0.0.1:6379,127.0.0.1:6378
# redis sentinel
layering-cache.redis.sentinel-nodes=127.0.0.1:26379,127.0.0.1:26380,127.0.0.1:26381
layering-cache.redis.sentinel-master=mymaster

# 设置redis值的序列化方式,默认是kryo
#com.github.xiaolyuh.redis.serializer.KryoRedisSerializer
#com.github.xiaolyuh.redis.serializer.FastJsonRedisSerializer
#com.github.xiaolyuh.redis.serializer.JacksonRedisSerializer
#com.github.xiaolyuh.redis.serializer.JdkRedisSerializer
#com.github.xiaolyuh.redis.serializer.ProtostuffRedisSerializer
layering-cache.redis.serializer=com.github.xiaolyuh.redis.serializer.KryoRedisSerializer
```



1. 配置类中添加注解`@EnableLayeringCache`启用`layering-cache`

```
@SpringBootApplication
@EnableLayeringCache
public class LayeringCacheStartDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(LayeringCacheStartDemoApplication.class, args);
    }
}
```



## 集成 Spring



1. 引入layering-cache

- maven 方式

```
<dependency>
    <groupId>com.github.xiaolyuh</groupId>
    <artifactId>layering-cache-aspectj</artifactId>
    <version>${layering.version}</version>
</dependency>
```



- gradle 方式

```
compile 'com.github.xiaolyuh:layering-cache:${layering.version}'
```



1. RedisClient（可以参考layering-cache-aspectj的Test配置）

```
@Configuration
@PropertySource({"classpath:application.properties"})
public class RedisConfig {

    @Value("${spring.redis.database:0}")
    private int database;

    @Value("${spring.redis.host:192.168.83.128}")
    private String host;

    @Value("${spring.redis.password:}")
    private String password;

    @Value("${spring.redis.port:6378}")
    private int port;

    @Bean
    public RedisClient layeringCacheRedisClient() {
        RedisProperties redisProperties = new RedisProperties();
        redisProperties.setDatabase(database);
        redisProperties.setHost(host);
        redisProperties.setPassword(StringUtils.isBlank(password) ? null : password);
        redisProperties.setPort(port);

        KryoRedisSerializer<Object> kryoRedisSerializer = new KryoRedisSerializer<>(Object.class);
        StringRedisSerializer keyRedisSerializer = new StringRedisSerializer();
        SingleRedisClient redisClient = new SingleRedisClient(redisProperties);
        redisClient.setKeySerializer(keyRedisSerializer);
        redisClient.setValueSerializer(kryoRedisSerializer);
        return redisClient;
    }
}
```



1. 声明CacheManager和LayeringAspect

```
/**
 * 多级缓存配置
 *
 * @author yuhao.wang3
 */
@Configuration
@Import({RedisConfig.class})
@EnableAspectJAutoProxy
public class CacheConfig {

    @Bean
    public CacheManager layeringCacheManager(RedisClient layeringCacheRedisClient, CacheStatsReportService cacheStatsReportService, LayeringCacheProperties layeringCacheProperties) {

        LayeringCacheManager layeringCacheManager = new LayeringCacheManager(layeringCacheRedisClient);
        // 默认开启统计功能
        layeringCacheManager.setStats(layeringCacheProperties.isStats());
        // 上报缓存统计信息
        layeringCacheManager.setCacheStatsReportService(cacheStatsReportService);
        // 设置缓存命名空间
        GlobalConfig.setNamespace(StringUtils.isBlank(layeringCacheProperties.getNamespace()) ? applicationName : layeringCacheProperties.getNamespace());
        return layeringCacheManager;
    }

    @Bean
    @ConditionalOnMissingBean(CacheStatsReportService.class)
    public CacheStatsReportService cacheStatsReportService() {
        return new DefaultCacheStatsReportServiceImpl();
    }
}
```



## 使用

### 注解形式

直接在需要缓存的方法上加上Cacheable、CacheEvict、CachePut、Caching注解。

- Cacheable注解

```java
@Cacheable(value = "user:info", depict = "用户信息缓存", cacheMode = CacheMode.ALL,
		firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),
		secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 3, forceRefresh = true, timeUnit = TimeUnit.SECONDS))
public User getUser(User user) {
	logger.debug("调用方法获取用户名称");
	return user;
}
```

- CachePut注解

```
@CachePut(value = "user:info", key = "#userId", depict = "用户信息缓存", cacheMode = CacheMode.ALL,
		firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),
		secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 3, forceRefresh = true, timeUnit = TimeUnit.SECONDS))
public User putUser(long userId) {
	User user = new User();
	user.setUserId(userId);
	user.setAge(31);
	user.setLastName(new String[]{"w", "y", "h"});

	return user;
}
```

- CacheEvict注解

```
@CacheEvict(value = "user:info", key = "#userId")
public void evictUser(long userId) {

}

@CacheEvict(value = "user:info", allEntries = true)
public void evictAllUser() {
}
```

- Caching注解

```
@Caching(evict = {@CacheEvict(value = "user:info:caching:3-4-0", key = "'evict'+#userId"), @CacheEvict(value = "user:info:caching", allEntries = true)},
        put = {@CachePut(value = "user:info:caching:3-4-0", key = "'put'+#userId",
                secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 3, timeUnit = TimeUnit.SECONDS))},
        cacheable = {@Cacheable(value = "user:info:caching:3-4-0", key = "#userId",
                firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),
                secondaryCache = @SecondaryCache(expireTime = 10, preloadTime = 7, timeUnit = TimeUnit.SECONDS))})
public User cachingAll(long userId) {
    return user;
}
```

### 直接使用API

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {CacheConfig.class})
public class CacheCoreTest {
    private Logger logger = LoggerFactory.getLogger(CacheCoreTest.class);

    @Autowired
    private CacheManager cacheManager;

    @Test
    public void testCacheExpiration() {
        FirstCacheSetting firstCacheSetting = new FirstCacheSetting(10, 1000, 4, TimeUnit.SECONDS, ExpireMode.WRITE);
        SecondaryCacheSetting secondaryCacheSetting = new SecondaryCacheSetting(10, 4, TimeUnit.SECONDS, true);
        LayeringCacheSetting layeringCacheSetting = new LayeringCacheSetting(firstCacheSetting, secondaryCacheSetting);

        String cacheName = "cache:name";
        String cacheKey = "cache:key1";
        LayeringCache cache = (LayeringCache) cacheManager.getCache(cacheName, layeringCacheSetting);
        cache.get(cacheKey, () -> initCache(String.class));
        cache.put(cacheKey, "test");
        cache.evict(cacheKey);
        cache.clear();
    }

    private <T> T initCache(Class<T> t) {
        logger.debug("加载缓存");
        return (T) "test";
    }
}
```



### 使用API清除缓存

```
@Resource
private LayeringCacheManager layeringCacheManager;

@PostMapping("/clear-layering-cache")
@ApiOperation(value = "清空layering-cache缓存", httpMethod = "POST")
public Boolean clearLayeringCache(String cacheName) {
    LayeringCacheSetting defaultSetting = new LayeringCacheSetting(new FirstCacheSetting(), new SecondaryCacheSetting(), "默认缓存配置（删除时生成）", CacheMode.ALL);
    Cache cache = layeringCacheManager.getCache(cacheName, defaultSetting);
    cache.clear();
    return true;
}
```

## 注解说明

### @Cacheable

当该方法被调用时先检查缓存是否命中(及缓存中是否有)，如果没有命中再调用被缓存的方法，并将其返回值放到缓存中。有就直接拿缓存中的。

| 名称           | 默认值        | 说明                                                |
| -------------- | ------------- | --------------------------------------------------- |
| value          | 空字符串数组  | 缓存名称，cacheNames的别名, 存放redis中的value      |
| cacheNames     | 空字符串数组  | 缓存名称                                            |
| key            | 空字符串      | 缓存key，支持SpEL表达式,  必须唯一,存放redis中的key |
| depict         | 空字符串      | 缓存描述（在缓存统计页面会用到）                    |
| cacheMode      | CacheMode.ALL | 缓存模式(只使用一级缓存或者二级缓存)                |
| firstCache     |               | 一级缓存配置                                        |
| secondaryCache |               | 二级缓存配置                                        |

#### @FirstCache

一级缓存配置项

| 名称            | 默认值           | 说明                                                         |
| --------------- | ---------------- | ------------------------------------------------------------ |
| initialCapacity | 10               | 缓存初始Size                                                 |
| maximumSize     | 5000             | 缓存最大Size                                                 |
| expireTime      | 9                | 缓存有效时间                                                 |
| timeUnit        | TimeUnit.MINUTES | 时间单位，默认分钟                                           |
| expireMode      | ExpireMode.WRITE | 缓存失效模式，ExpireMode.WRITE：最后一次写入后到期失效，ExpireMode.ACCESS：最后一次访问后到期失效 |

#### @SecondaryCache

二级缓存配置项

| 名称          | 默认值         | 说明                                                         |
| ------------- | -------------- | ------------------------------------------------------------ |
| expireTime    | 5              | 缓存有效时间                                                 |
| preloadTime   | 1              | 缓存主动在失效前强制刷新缓存的时间，建议是 expireTime * 0.2  |
| timeUnit      | TimeUnit.HOURS | 时间单位，默认小时                                           |
| forceRefresh  | false          | 是否强制刷新（直接执行被缓存方法）                           |
| magnification | 1              | 非空值和null值之间的时间倍率，默认是1。如expireTime=60秒，magnification=10，那么当缓存空值时，空值的缓存过期时间是60/10=6秒。 |

#### @CachePut

将数据放到缓存中

| 名称           | 默认值        | 说明                                 |
| -------------- | ------------- | ------------------------------------ |
| value          | 空字符串数组  | 缓存名称，cacheNames的别名           |
| cacheNames     | 空字符串数组  | 缓存名称                             |
| key            | 空字符串      | 缓存key，支持SpEL表达式              |
| depict         | 空字符串      | 缓存描述（在缓存统计页面会用到）     |
| cacheMode      | CacheMode.ALL | 缓存模式(只使用一级缓存或者二级缓存) |
| firstCache     |               | 一级缓存配置                         |
| secondaryCache |               | 二级缓存配置                         |

#### @CacheEvict

删除缓存。@CacheEvict不这么用, 一般@Cacheable会设置过期时间的

| 名称       | 默认值        | 说明                                                         |
| ---------- | ------------- | ------------------------------------------------------------ |
| value      | 空字符串数组  | 缓存名称，cacheNames的别名                                   |
| cacheNames | 空字符串数组  | 缓存名称                                                     |
| key        | 空字符串      | 缓存key，支持SpEL表达式                                      |
| allEntries | false         | 是否删除缓存中所有数据，默认情况下是只删除关联key的缓存数据，当该参数设置成 true 时 key 参数将无效 |
| cacheMode  | CacheMode.ALL | 缓存模式(只使用一级缓存或者二级缓存)                         |

#### @Caching

同时使用多个缓存注解

| 名称      | 默认值         | 说明           |
| --------- | -------------- | -------------- |
| cacheable | Cacheable数组  | Cacheable注解  |
| put       | CachePut数组   | CachePut注解   |
| evict     | CacheEvict数组 | CacheEvict注解 |

## 案例

### 具体代码

![image-20240301100759122](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301100759122.png)

### 运行结果

#### 添加

```java
    // 放
    @Override
    @CachePut(value = "cache-prefix:people", key = "#person.id", depict = "用户信息缓存")
    public Person save(Person person) {
        logger.info("为id、key为:" + person.getId() + "数据做了缓存");
        return person;
    }
```

![image-20240301103209631](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301103209631.png)

#### 查询

```java
    // 查
    @Override
    @Cacheable(value = "cache-prefix:people", key = "#person.id", depict = "用户信息缓存",
            firstCache = @FirstCache(expireTime = 4, timeUnit = TimeUnit.SECONDS),  //	一级缓存配置
            secondaryCache = @SecondaryCache(expireTime = 15, preloadTime = 8, forceRefresh = true, timeUnit = TimeUnit.MINUTES)) // 二级缓存配置
    public Person findOne(Person person) {
        // 没有走缓存, 就执行方法中
        Person p = new Person(2L, "name2", 12, "address2");
        logger.info("为id、key为:" + p.getId() + "数据做了缓存");
        try {
            Thread.sleep(2050);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return p;
    }
```

**情况1:** ==查询数据存在走缓存==

![image-20240301104627134](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301104627134.png)

**情况2**:==查询数据不存在走方法, 并且将方法返回结果进行缓存==

![image-20240301104656798](%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301104656798.png)

#### redis已经缓存的数据

<img src="%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/image-20240301105608955.png" alt="image-20240301105608955" style="zoom:80%;" />

# 其他案例

## 需求

**比如，**

+ **首页中的那几张幻灯片，每次进入首页都需要查询数据库，可以直接放入缓存里，减少数据库的压力，还有就是那些热门文章，访问量比较大的，也放进缓存里。**

+ **实现登录过期的功能,比如在用户提交登录时,通过设置一个过期时间,当用户30分钟内没有访问,redis就会自动将该用户的登录数据删除,从而释放宝贵的用户资源。**

```java
  
	// 得到幻灯片
	@Override
    @Cacheable(value = "getBanner", keyGenerator = "customKeyGenerator")
    public List<Blog> getBanner() {
        return blogMapper.getBanner();
    }

	// 得到热门文章
    @Override
    @Cacheable(value = "getBlogDetail", key = "'blogid'.concat(#blogid)")
    public Blog getBlogDetail(Integer blogid) {
        Blog blog = blogMapper.selectByPrimaryKey(blogid);
        if (blog == null) {
            return null;
        }
        Category category = categoryMapper.selectByPrimaryKey(blog.getCategoryid());
        blog.setCategory(category);
        List<Tag> tags = tagMapper.getTagByBlogId(blog.getBlogid());
        blog.setTags(tags.size() > 0 ? tags : null);
        asyncService.updatebloghits(blogid);//异步更新阅读次数
        logger.info("没有走缓存");
        return blog;
    }
```

## 测试

调用一个getBlogDetail（获取博客详情）100次来对比一下时间。

```java
public class SpringTest {
    @Test
    public void init() {
        ApplicationContext ctx = new FileSystemXmlApplicationContext("classpath:spring-test.xml");
        IBlogService blogService = (IBlogService) ctx.getBean("blogService");
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 100; i++) {
            blogService.getBlogDetail(615);
        }
        System.out.println(System.currentTimeMillis() - startTime);
    }
}
```

为了做一下对比，同时使用mybatis自身缓存来进行测试。

##  实验结果

统计出结果如下：

```html
没有使用任何缓存（mybatis一级缓存没有关闭）：18305
使用远程Redis缓存：12727
使用Mybatis缓存：6649
使用本地Redis缓存：5818
```

由结果看出，缓存的使用大大较少了获取数据的时间。


redis已经缓存的数据：

<img src="%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.assets/20180120052757.png">

# 分页的数据缓存

个人网站中共有两个栏目，一个是技术杂谈，另一个是生活笔记，每点击一次栏目的时候，会根据页数从数据库中查询数据，百度了下，大概有三种方法：
（1）以页码作为Key，然后缓存整个页面。
（2）分条存取，只从数据库中获取分页的文章ID序列，然后从service（缓存策略在service中实现）中获取。
第一种，由于使用了第三方的插件PageHelper，分页获取的话会比较麻烦，同时整页缓存对内存压力也蛮大的，毕竟服务器只有2g。

第二中实现方式简单，缺陷是依旧需要查询数据库，想了想还是放弃了。缓存的初衷是对请求频繁又不易变的数据，实际使用中很少会反复的请求同一页的数据（查询条件也相同），当然对数据中某些字段做缓存还是有必要的。

# 准则

## [缓存雪崩](https://so.csdn.net/so/search?q=缓存雪崩&spm=1001.2101.3001.7020)

缓存在统一时间大面积失效，导致所有的请求都会落到数据库上，对数据库CPU和[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)造成巨大压力，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统的崩溃。
解决办法：

- 缓存数据过期时间随机：过期时间设置随机，防止同一时间大量数据过期；
- 热点数据不设置过期时间，主动刷新缓存：缓存设置成永不过期，在更新和删除DB时，也主动把缓存中的数据核心或删除；
- 检查更新：缓存依然保持设置过期时间，每次get缓存的时候，都把数据过期时间与当前时间进行对比，当间隔时间小于一定阈值的时候，主动更新缓存。

## [缓存击穿](https://so.csdn.net/so/search?q=缓存击穿&spm=1001.2101.3001.7020)

缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时候由于[并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)访问很多，缓存中没有读到数据，造成数据库短时间内承受大量请求而崩溃。和缓存雪崩的区别是：缓存击穿指并发查询一条数据，缓存崩溃是指缓存同一时间大量失效。
解决方法：

- 加互斥锁；
- 设置热点数据永不过期。

## 缓存穿透

缓存和数据库中都没有的数据。这样会导致用户查询的时候，在缓存中找不到，每次都要去数据库中查一遍，然后返回空（相当于进行了两次无用的查询），这样请求就绕过了缓存直接查库（命中率问题）。
解决方法：

- 使用布隆过滤器；
- 返回数据为空时设置一个默认缓存，过期时间很短。

## 缓存预热

系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候直接查询数据库，然后再将数据缓存。用户直接查询实现被预热的缓存数据。

## 缓存更新

缓存更新除了缓存服务器自带的缓存失效策略之外，还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
（1）定时区清理过期缓存；
（2）当有用户请求过来时，再判断所用到的请求是否过期，过期的话就去底层系统得到新的数据并更新缓存。

例如，在缓存中存放了近3年的10亿条博文数据，但是经常被访问的可能只有10万条，其他的可能几个月才访问一次。那么，就没有必要让所有的博文数据长期存在于缓存中。设置一个过期时间比方说7天，超过7天未被访问的博文数据将会自动失效，如此节省大量内存。

例如：游戏中的发言间隔为10秒钟，可以通过缓存实现。

## 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响大核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级 ，可以配置开关人工降级。降级的最终目的是报这个核心服务的可用（即使是有损的）。



参考:

[Redis缓存何以一枝独秀？(2) —— 聊聊Redis的数据过期、数据淘汰以及数据持久化的实现机制 - 架构悟道 - 博客园 (cnblogs.com)](https://www.cnblogs.com/softwarearch/p/16927956.html)



# 工具类(不用)

> 工具类最好是公共方法都是静态方法

[Spring Data Redis](https://docs.spring.io/spring-data/redis/docs/2.1.9.RELEASE/reference/html/)

**RedisConfig.java**

```java
@Configuration
public class RedisConfig {

 /*..其他配置..*/

 
    // 让工具类自动注册, 一般工具类都需要这一步
    @Bean
    public RedisCacheUtils redisCacheUtils(RedisTemplate redisTemplate){
        return new RedisCacheUtils(redisTemplate);
    }

}
```

**RedisCacheUtils.java**

```java
package com.fox.sms.util;

import cn.hutool.core.util.BooleanUtil;
import org.springframework.data.redis.core.BoundSetOperations;
import org.springframework.data.redis.core.HashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;

import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * Redis缓存工具
 *
 * @author 狐狸半面添
 * @create 2023-04-01 16:39
 */
@SuppressWarnings(value = {"unchecked", "rawtypes"})
public class RedisCacheUtils {
    private final RedisTemplate redisTemplate;

    public RedisCacheUtils(RedisTemplate redisTemplate){
        this.redisTemplate = redisTemplate;
    }

    /**
     * 获取剩余TTL有效期
     *
     * @param key 缓存的键值
     * @return 剩余有效期，单位：s
     */
    public Long getExpire(final String key){
        return redisTemplate.getExpire(key);
    }

    /**
     * 缓存基本的对象，Long、String、实体类等
     *
     * @param key   缓存的键值
     * @param value 缓存的值
     */
    public <T> void setCacheObject(final String key, final T value) {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Long、String、实体类等
     *
     * @param key      缓存的键值
     * @param value    缓存的值
     * @param timeout  时间
     * @param timeUnit 时间颗粒度
     */
    public <T> void setCacheObject(final String key, final T value, final Long timeout, final TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 缓存基本的对象，Long、String、实体类等
     *
     * @param key      缓存的键值
     * @param value    缓存的值
     * @param timeout  时间 单位：s
     */
    public <T> void setCacheObject(final String key, final T value, final Long timeout) {
        redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);
    }
    
     /**
     * 缓存基本的对象，Long、String、实体类等
     *
     * @param key      缓存的键值
     * @param value    缓存的值
     * @param timeout  时间
     * @param timeUnit 枚举, 确定时间单位
     */
    public <T> void setCacheObject(final String key, final T value, final Long timeout,
                                   TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout) {
        return expire(key, timeout, TimeUnit.SECONDS);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @param unit    时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit) {
        return Boolean.TRUE.equals(redisTemplate.expire(key, timeout, unit));
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public <T> T getCacheObject(final String key) {
        ValueOperations<String, T> operation = redisTemplate.opsForValue();
        return operation.get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key) {
        return Boolean.TRUE.equals(redisTemplate.delete(key));
    }

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public long deleteObject(final Collection collection) {
        return redisTemplate.delete(collection);
    }

    /**
     * 缓存List数据
     *
     * @param key      缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public <T> long setCacheList(final String key, final List<T> dataList) {
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
        return count == null ? 0 : count;
    }

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public <T> List<T> getCacheList(final String key) {
        return redisTemplate.opsForList().range(key, 0, -1);
    }

    /**
     * 缓存Set
     *
     * @param key     缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet) {
        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);
        Iterator<T> it = dataSet.iterator();
        while (it.hasNext()) {
            setOperation.add(it.next());
        }
        return setOperation;
    }

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public <T> Set<T> getCacheSet(final String key) {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public <T> void setCacheMap(final String key, final Map<String, T> dataMap) {
        if (dataMap != null) {
            redisTemplate.opsForHash().putAll(key, dataMap);
        }
    }

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public <T> Map<String, T> getCacheMap(final String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 往Hash中存入数据
     *
     * @param key   Redis键
     * @param hKey  Hash键
     * @param value 值
     */
    public <T> void setCacheMapValue(final String key, final String hKey, final T value) {
        redisTemplate.opsForHash().put(key, hKey, value);
    }

    /**
     * 获取Hash中的数据
     *
     * @param key  Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public <T> T getCacheMapValue(final String key, final String hKey) {
        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    }

    /**
     * 删除Hash中的数据
     *
     * @param key
     * @param hKey
     */
    public void delCacheMapValue(final String key, final String hKey) {
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.delete(key, hKey);
    }

    /**
     * 获取多个Hash中的数据
     *
     * @param key   Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys) {
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    }

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection<String> keys(final String pattern) {
        return redisTemplate.keys(pattern);
    }

    /**
     * 判断某个键是否存在
     *
     * @param key 键
     * @return true-存在 false-不存在
     */
    public boolean existKey(final String key){
        return BooleanUtil.isTrue(redisTemplate.hasKey(key));
    }
}

```

使用

```java
 @Resource
 private RedisCacheUtils redisCacheUtils;

//******
redisCacheUtils.setCacheObject(key,code+",0",RedisConstants.LOGIN_USER_CODE_TTL);
```

